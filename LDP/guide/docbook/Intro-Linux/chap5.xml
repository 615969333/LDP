<?xml version='1.0' encoding='UTF-8'?>
<chapter id="chap_05">
<title>I/O redirection</title>
<abstract>
<para>This chapter describes more about the powerful UNIX mechanism of redirecting input, output and errors.  Topics include:</para>
<para>
<itemizedlist>
<listitem><para>Standard input, output and errors</para></listitem>
<listitem><para>Redirection operators</para></listitem>
<listitem><para>How to use output of one command as input for another</para></listitem>
<listitem><para>Input redirection</para></listitem>
<listitem><para>Handling standard error messages</para></listitem>
<listitem><para>Combining redirection of input, output and error streams</para></listitem>
<listitem><para>Output filters</para></listitem>

</itemizedlist>
</para>
</abstract>

<sect1 id="sect_05_01"><title>What are standard input and standard output?</title>
<para>
Most Linux commands read input, such as a file or another attribute for the command, and write output.  By default, input is being given with the keyboard, and output is displayed on your screen.  Your keyboard is your <quote>standard input</quote> (stdin) device, and the screen is the <quote>standard output</quote> (stdout) device.
</para>
<para>However, since Linux is a flexible system, these default settings don't necessarily have to be applied.  The standard output, for example, on a heavily monitored server in a large environment may be a printer.</para>
<sect2 id="sect_05_01_01"><title>The redirection operators</title>
<sect3 id="sect_05_01_01_01"><title>Output redirection with &gt; and |</title>
<para>Sometimes you will want to put output of a command in a file, or you may want to issue another command on the output of one command.  This is known as redirecting output.  Redirection is done using either the <quote>&gt;</quote> (greater-than symbol), or using the <quote>|</quote> (pipe) operator which sends the standard output of one command to another command as standard input.</para>
<para>As we saw before, the <command>cat</command> command concatenates files and puts them all together to the standard output.  By redirecting this output to a file, this file name will be created - or overwritten if it already exists, so take care.</para>
<screen>
nancy:~&gt; cat test1
some words

nancy:~&gt; cat test2
some other words

nancy:~&gt; cat test1 test2 &gt; test3

nancy:~&gt; cat test3
some words
some other words
</screen>
<para>Redirecting <quote>nothing</quote> to an existing file is equal to emptying the file:</para>
<screen>
nancy:~&gt; ls -l list
-rw-rw-r--    1 nancy   nancy     117 Apr  2 18:09 list

nancy:~&gt; &gt; list

nancy:~&gt; ls -l list
-rw-rw-r--    1 nancy   nancy       0 Apr  4 12:01 list
</screen>
<para>This process is called <emphasis>truncating</emphasis>.</para>
<para>The same redirection to an nonexistent file will create a new empty file with the given name:</para>
<screen>
nancy:~&gt; ls -l newlist
ls: newlist: No such file or directory

nancy:~&gt; &gt; newlist

nancy:~&gt;  ls -l newlist
-rw-rw-r--  1 nancy   nancy	    0 Apr  4 12:05 newlist
</screen>
<para><xref linkend="chap_07" /> gives some more examples on the use of this sort of redirection.</para>
<para>Some examples using piping of commands:</para>
<para>To find a word within some text, display all lines matching <quote>pattern1</quote>, and exclude lines also matching <quote>pattern2</quote> from being displayed:</para>
<cmdsynopsis><command>grep <parameter>pattern1</parameter> <filename>file</filename> | grep <option>-v</option> <parameter>pattern2</parameter></command></cmdsynopsis>
<para>To display output of a directory listing one page at a time:</para>
<cmdsynopsis><command>ls <option>-la</option> | less</command></cmdsynopsis>
<para>To find a file in a directory:</para>
<cmdsynopsis><command>ls <option>-l</option> | grep <parameter>part_of_file_name</parameter></command></cmdsynopsis>
</sect3>
<sect3 id="sect_05_01_01_02"><title>Input redirection</title>
<para>In another case, you may want a file to be the input for a command that normally wouldn't accept a file as an option.  This redirecting of input is done using the <quote>&lt;</quote> (less-than symbol) operator.</para>
<para>Below is an example of sending a file to somebody, using input redirection.</para>
<screen>
andy:~&gt;mail mike@somewhere.org &lt; to_do
</screen>
<para>If the user <emphasis>mike</emphasis> exists on the system, you don't need to type the full address.  If you want to reach somebody on the Internet, enter the fully qualified address as an argument to <command>mail</command>.</para>
<para>This reads a bit more difficult than the beginner's <command>cat <filename>file</filename> | mail <parameter>someone</parameter></command>, but it is of course a much more elegant way of using the available tools.</para>
</sect3>
<sect3 id="sect_05_01_01_03"><title>Combining redirections</title>
<para>The following example combines input and output redirection.  The file <filename>text.txt</filename> is first checked for spelling mistakes, and the output is redirected to an error log file:</para>
<para><command>aspell &lt; <filename>text.txt</filename> &gt; <filename>error.log</filename></command></para>
<para>It might be that you have to use the following syntax to spell a file (check with the man pages):</para>
<cmdsynopsis><command>aspell <option>-H</option> <parameter>list</parameter> &lt; <filename>file.txt</filename> | sort <option>-u</option></command></cmdsynopsis>
<para>This also uses input and output redirection.</para>
<para>The following command lists all commands that you can issue to examine another file when using <command>less</command>:</para>
<screen>
mike:~&gt; less --help | grep -i examine
  :e [file]      Examine a new file.
  :n          *  Examine the (N-th) next file from the command line.
  :p          *  Examine the (N-th) previous file from the command line.
  :x          *  Examine the first (or N-th) file from the command line.
</screen>
<para>The <option>-i</option> option is used for case-insensitive searches - remember that UNIX systems are very case-sensitive.</para>
<para>If you want to save output of this command for future reference, redirect the output to a file:</para>
<screen>
mike:~&gt; less --help | grep -i examine &gt; examine-files-in-less

mike:~&gt; cat examine-files-in-less
  :e [file]      Examine a new file.
  :n          *  Examine the (N-th) next file from the command line.
  :p          *  Examine the (N-th) previous file from the command line.
  :x          *  Examine the first (or N-th) file from the command line.
</screen>
<para>Output of one command can be piped into another command virtually as many times as you want, just as long as these commands would normally read input from standard input and write output to the standard output.  Sometimes they don't, but then there may be special options that instruct these commands to behave according to the standard definitions; so read the documentation (man and info pages) of the commands you use if you should encounter errors.</para>

<note><title>Don't overwrite!</title>
<para>Be careful not to overwrite existing (important) files when redirecting output.  Many shells, including Bash, have a built-in feature to protect you from that risk: <command>noclobber</command>.  See the Info pages for more information.  In Bash, you would want to add the <command>set <option>-o</option> <parameter>noclobber</parameter></command> command to your <filename>.bashrc</filename> configuration file in order to prevent accidental overwriting of files.</para></note>

</sect3>


<sect3 id="sect_05_01_01_04"><title>The &gt;&gt; operator</title>
<para>Instead of overwriting file data, you can also append text to an existing file using two subsequent greater-than signs:</para>
<para>Example:</para>
<screen>
mike:~&gt;date &gt;&gt; wishlist

mike:~&gt;cat wishlist
more money
less work
Thu Feb 28 20:23:07 CET 2002
</screen>
<para>The <command>date</command> command would normally put the last line on the screen; now it is appended to the file <filename>wishlist</filename>.
</para>
</sect3>
</sect2>

<sect2 id="sect_05_01_02"><title>Advanced redirection features</title>
<sect3 id="sect_05_01_02_01"><title>Use of file descriptors</title> 
<para>There are three types of I/O, which each have their own identifier, called a file descriptor:</para>
<itemizedlist>
<listitem><para>standard input: 0</para></listitem>
<listitem><para>standard output: 1</para></listitem>
<listitem><para>standard error: 2</para></listitem>
</itemizedlist>

<para>In the following descriptions, if the file descriptor number is omitted, and the first character of the redirection operator is &lt;, the redirection refers to the standard input (file descriptor 0).  If the first character of the redirection operator is &gt;, the redirection refers to the standard output (file descriptor 1).</para>
<para>Some practical examples will make this more clear:</para>
<cmdsynopsis><command>ls &gt; <filename>dirlist</filename> 2&gt;&amp;1</command></cmdsynopsis>
<para>will direct both standard output and standard error to the file <filename>dirlist</filename>, while the command</para>
<cmdsynopsis><command>ls 2&gt;&amp;1 &gt; <filename>dirlist</filename></command></cmdsynopsis> 
<para>will only direct standard output to <filename>dirlist</filename>.  This can be a useful option for programmers.</para>
<para>All this is explained in detail in the Bash Info pages.</para>
</sect3>
<sect3 id="sect_05_01_02_02"><title>Examples</title>
<sect4><title>Analyzing errors</title>
<para>If your process generates a lot of errors, this is a way to thoroughly examine them:</para>
<cmdsynopsis><command>command 2&gt;&amp;1 | less</command></cmdsynopsis>
<para>This is often used when creating new software using the <command>make</command>, such as in:</para>
<screen>
andy:~/newsoft&gt; make all 2&gt;&amp;1 | less
--output ommitted--
</screen>
</sect4>
<sect4><title>Separating standard output from standard error</title>
<para>Constructs like these are often used by programmers, so that output is displayed in one terminal window, and errors in another.  Find out which pseudo terminal you are using issuing the <command>tty</command> command first:</para>
<screen>
andy:~/newsoft&gt; make all 2&gt; /dev/pts/7
</screen>
</sect4>
</sect3>

</sect2>
<sect2 id="sect_05_01_03">
<title>Filters</title>
<para>When a program performs operations on input and writes the result to the standard output, it is called a filter.  One of the most common uses of filters is to restructure output.  We'll discuss a couple of the most important filters below.</para>
<sect3 id="sect_05_01_03_01"><title>More about grep</title>
<para>As we saw in <xref linkend="sect_03_03_03_04" />, <command>grep</command> scans the output line per line, searching for matching patterns.  All lines containing the pattern will be printed to standard output.  This behavior can be reversed using the <option>-v</option> option.
</para>
<para>Some examples: suppose we want to know which files in a certain directory have been modified in February:</para>
<screen>
jenny:~&gt;ls -la | grep Feb
</screen>
<para>The <command>grep</command> command, like most commands, is case sensitive. Use the <option>-i</option> option to make no difference between upper and lower case.  A lot of GNU extensions are available as well, such as <option>--colour</option>, which is helpful to highlight searchterms in long lines, and <option>--after-context</option>, which prints the number of lines after the last matching line.  You can issue a recursive <command>grep</command> that searches all subdirectories of encountered directories using the <option>-r</option> option.  As usual, options can be combined.</para>
<para>Regular expressions can be used to further detail the exact character matches you want to select out of all the input lines.  The best way to start with regular expressions is indeed to read the <command>grep</command> documentation.  An excellent chapter is included in the <command>info <parameter>grep</parameter></command> page.  Since it would lead us too far discussing the ins and outs of regular expressions, it is strongly advised to start here if you want to know more about them.</para>
<para>Play around a bit with <command>grep</command>, it will be worth the trouble putting some time in this most basic but very powerful filtering command.  The exercises at the end of this chapter will help you started, see <xref linkend="sect_05_03" />.</para>
</sect3>

<sect3 id="sect_05_01_03_02"><title>Filtering output</title>
<para>The command <command>sort</command> arranges lines in alphabetical order by default:</para>
<screen>
thomas:~&gt;cat people-I-like | sort
Auntie Emmy
Boyfriend
Dad
Grandma
Mum
My boss
</screen>
<para>But there are many more things <command>sort</command> can do.  Looking at the file size, for instance.  With this command, directory content is sorted smallest files first, biggest files last:</para>
<cmdsynopsis><command>ls <option>-la</option> | sort <option>-nk</option> <parameter>5</parameter></command></cmdsynopsis>
<note><title>Old sort syntax</title>
<para>You might obtain the same result with <command>ls <option>-la</option> | sort <option>+4n</option></command>, but this is an old form which does not comply with the current standards.</para></note>
<para>The <command>sort</command> command is also used in combination with the <command>uniq</command> program (or <command>sort <option>-u</option></command>) to sort output and filter out double entries.</para>
</sect3>
</sect2>
</sect1>
<sect1 id="sect_05_02"><title>Summary</title>
<para>In this chapter we learned how commands can be linked to each other, and how input from one command can be used as output for another command.</para>
<para>Input/output redirection is a common task on UNIX and Linux machines.  This powerful mechanism allows flexible use of the building blocks UNIX is made of.</para>
</sect1>
<sect1 id="sect_05_03"><title>Exercises</title>
<para>These exercises give more examples on how to combine commands.  The main goal is to try and use the <keycap>Enter</keycap> key as little as possible.</para>
<para>All exercises are done using a normal user ID, so as to generate some errors.  While you're at it, don't forget to read those man pages!</para>
<itemizedlist>
<listitem><para>Use the <command>cut</command> command on the output of a long directory listing in order to display only the file permissions.  Then pipe this output to <command>sort</command> and <command>uniq</command> to filter out any double lines.  Then use the <command>wc</command> to count the different permission types in this directory.</para></listitem>
<listitem><para>Put the output of <command>date</command> in a file.  Append the output of <command>ls</command> to this file.  Send this file to your local mailbox (don't specify anything <email>@domain</email>, just the user name will do).  When using Bash, you will see a new mail notice upon success.</para></listitem>
<listitem><para>List the devices in <filename>/dev</filename> which are currently used by your UID.  Pipe through <command>less</command> to view them properly.</para></listitem>
<listitem><para>Use the command <command>bash <option>-x</option></command> to start up the HTTP daemon with the script in <filename>/etc/rc.d/init.d</filename>.  Send standard error to a file.  Do the same but now send standard output to the file.  Note the difference.</para></listitem>
<listitem><para>How many processes are you currently running?</para></listitem>
<listitem><para>How many invisible files are in your home directory?</para></listitem>
<listitem><para>Use <command>locate</command> to find documentation about the kernel.</para></listitem>
<listitem><para>Find out which file contains the following entry:</para>
<screen>
root:x:0:0:root:/root:/bin/bash
</screen>
<para>And this one:</para>
<screen>
system:		root
</screen></listitem>
<listitem><para>See what happens upon issuing this command:</para>
<screen>&gt; time; date &gt;&gt; time; cat &lt; time</screen>
</listitem>
</itemizedlist>

</sect1>


</chapter>
