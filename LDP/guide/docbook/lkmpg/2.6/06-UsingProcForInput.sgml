<sect1><title>Using /proc For Input</title>

	<indexterm><primary>input</primary><secondary>using /proc for</secondary></indexterm>
	<indexterm><primary>proc</primary><secondary>using for input</secondary></indexterm>

	<para>So far we have two ways to generate output from kernel modules: we can register a device driver and
	<command>mknod</command> a device file, or we can create a <filename role="directory">/proc</filename> file. This allows the
	kernel module to tell us anything it likes. The only problem is that there is no way for us to talk back. The first way we'll
	send input to kernel modules will be by writing back to the <filename role="directory">/proc</filename> file.</para>

	<para>Because the proc filesystem was written mainly to allow the kernel to report its situation to processes, there are no
	special provisions for input.  The <varname>struct proc_dir_entry</varname> doesn't include a pointer to an input function,
	the way it includes a pointer to an output function. Instead, to write into a <filename role="directory">/proc</filename>
	file, we need to use the standard filesystem mechanism.</para>

	<indexterm><primary><varname>proc_dir_entry</varname></primary></indexterm>

	<para>In Linux there is a standard mechanism for file system registration. Since every file system has to have its own
	functions to handle inode and file operations<footnote><para>The difference between the two is that file operations deal with
	the file itself, and inode operations deal with ways of referencing the file, such as creating links to it.</para></footnote>,
	there is a special structure to hold pointers to all those functions, <varname>struct inode_operations</varname>, which
	includes a pointer to <varname>struct file_operations</varname>. In /proc, whenever we register a new file, we're allowed to
	specify which <varname>struct inode_operations</varname> will be used for access to it. This is the mechanism we use, a
	<varname>struct inode_operations</varname> which includes a pointer to a <varname>struct file_operations</varname> which
	includes pointers to our <function>module_input</function> and <function>module_output</function> functions.</para>

	<indexterm><primary>filesystem</primary><secondary>registration</secondary></indexterm>
	<indexterm><primary>filesystem registration</primary></indexterm>
	<indexterm><primary><varname>struct inode_operations</varname></primary></indexterm>
	<indexterm><primary><varname>inode_operations</varname> structure</primary></indexterm>
	<indexterm><primary><varname>struct file_operations</varname></primary></indexterm>
	<indexterm><primary><varname>file_operations</varname> structure</primary></indexterm>

	<para>It's important to note that the standard roles of read and write are reversed in the kernel. Read functions are used for
	output, whereas write functions are used for input. The reason for that is that read and write refer to the user's point of
	view --- if a process reads something from the kernel, then the kernel needs to output it, and if a process writes something
	to the kernel, then the kernel receives it as input.</para>

	<indexterm><primary>read</primary><secondary>in the kernel</secondary></indexterm>
	<indexterm><primary>write</primary><secondary>in the kernel</secondary></indexterm>

	<para>Another interesting point here is the <function>module_permission</function> function. This function is called whenever
	a process tries to do something with the <filename role="directory">/proc</filename> file, and it can decide whether to allow
	access or not. Right now it is only based on the operation and the uid of the current user (as available in
	<varname>current</varname>, a pointer to a structure which includes information on the currently running process), but it
	could be based on anything we like, such as what other processes are doing with the same file, the time of day, or the last
	input we received.</para>

	<indexterm><primary>pointer</primary><secondary>current</secondary></indexterm>
	<indexterm><primary>permission</primary></indexterm>
	<indexterm><primary><varname>module_permissions</varname></primary></indexterm>

	<para>The reason for <function>put_user</function> and <function>get_user</function> is that Linux memory (under Intel
	architecture, it may be different under some other processors) is segmented.  This means that a pointer, by itself, does not
	reference a unique location in memory, only a location in a memory segment, and you need to know which memory segment it is to
	be able to use it. There is one memory segment for the kernel, and one of each of the processes.</para> 

	<indexterm><primary><function>put_user</function></primary></indexterm>
	<indexterm><primary><function>get_user</function></primary></indexterm>
	<indexterm><primary>memory segments</primary></indexterm>
	<indexterm><primary>segment</primary><secondary>memory</secondary></indexterm>

	<para>The only memory segment accessible to a process is its own, so when writing regular programs to run as processes,
	there's no need to worry about segments. When you write a kernel module, normally you want to access the kernel memory
	segment, which is handled automatically by the system. However, when the content of a memory buffer needs to be passed between
	the currently running process and the kernel, the kernel function receives a pointer to the memory buffer which is in the
	process segment. The <function>put_user</function> and <function>get_user</function> macros allow you to access that
	memory.</para>


<example><title>procfs.c</title><programlisting><inlinegraphic fileref="lkmpg-examples/06-UsingProcForInput/procfs.c" format="linespecific"/></inlinegraphic></programlisting></example>

	<para> Still hungry for procfs examples? Well, first of all keep in mind, there are rumors around, claiming
	that procfs is on it's way out, consider using sysfs instead. Second, if you really can't get enough, 
	there's a highly recommendable bonus level for procfs below <filename> linux/Documentation/DocBook/ </filename>. 
	Use <command> make help </command> in your toplevel kernel directory for instructions about how to convert it into 
	your favourite format. Example: <command> make htmldocs </command>. Consider using this mechanism, 
	in case you want to document something kernel related yourself.</para>

</sect1>

<!--
vim: tw=128
-->
