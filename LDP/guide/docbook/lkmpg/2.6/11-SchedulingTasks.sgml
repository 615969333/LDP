<sect1><title>Scheduling Tasks</title>

	<indexterm><primary>scheduling tasks</primary></indexterm>
	<indexterm><primary>tasks</primary><secondary>scheduling</secondary></indexterm>
	<indexterm><primary>housekeeping</primary></indexterm>
	<indexterm><primary>crontab</primary></indexterm>

	<para>Very often, we have <quote>housekeeping</quote> tasks which have to be done at a certain time, or every so often. If the
	task is to be done by a process, we do it by putting it in the <filename>crontab</filename> file.  If the task is to be done
	by a kernel module, we have two possibilities.  The first is to put a process in the <filename>crontab</filename> file which
	will wake up the module by a system call when necessary, for example by opening a file. This is terribly inefficient, however
	-- we run a new process off of <filename>crontab</filename>, read a new executable to memory, and all this just to wake up a
	kernel module which is in memory anyway.</para>

	<indexterm><primary>task</primary></indexterm>
	<indexterm><primary>tq_struct</primary></indexterm>
	<indexterm><primary>queue_task</primary></indexterm>
	<indexterm><primary>tq_timer</primary></indexterm>

	<para>Instead of doing that, we can create a function that will be called once for every timer interrupt.  The way we do this
	is we create a task, held in a <structname>tq_struct</structname> structure, which will hold a pointer to the function.  Then,
	we use <function>queue_task</function> to put that task on a task list called <structname>tq_timer</structname>, which is the
	list of tasks to be executed on the next timer interrupt.  Because we want the function to keep on being executed, we need to
	put it back on <structname>tq_timer</structname> whenever it is called, for the next timer interrupt.</para>

	<indexterm><primary>rmmod</primary></indexterm>
	<indexterm><primary>reference count</primary></indexterm>
	<indexterm><primary>module_cleanup</primary></indexterm>

	<para>There's one more point we need to remember here.  When a module is removed by <command>rmmod</command>, first its
	reference count is checked.  If it is zero, <function>module_cleanup</function> is called.  Then, the module is removed from
	memory with all its functions.  Nobody checks to see if the timer's task list happens to contain a pointer to one of those
	functions, which will no longer be available.  Ages later (from the computer's perspective, from a human perspective it's
	nothing, less than a hundredth of a second), the kernel has a timer interrupt and tries to call the function on the task list.
	Unfortunately, the function is no longer there.  In most cases, the memory page where it sat is unused, and you get an ugly
	error message.  But if some other code is now sitting at the same memory location, things could get <emphasis>very</emphasis>
	ugly.  Unfortunately, we don't have an easy way to unregister a task from a task list.</para>

	<indexterm><primary>sleep_on</primary></indexterm>
	<indexterm><primary>module_sleep_on</primary></indexterm>

	<para>Since <function>cleanup_module</function> can't return with an error code (it's a void function), the solution is to not
	let it return at all.  Instead, it calls <function>sleep_on</function> or
	<function>module_sleep_on</function><footnote><para>They're really the same.</para></footnote> to put the
	<command>rmmod</command> process to sleep.  Before that, it informs the function called on the timer interrupt to stop
	attaching itself by setting a global variable.  Then, on the next timer interrupt, the <command>rmmod</command> process will
	be woken up, when our function is no longer in the queue and it's safe to remove the module.</para>

	<indexterm><primary>source file</primary><secondary>sched.c</secondary></indexterm>

<example><title>sched.c</title><programlisting><inlinegraphic fileref="lkmpg-examples/11-SchedulingTasks/sched.c" format="linespecific"/></inlinegraphic></programlisting></example>
</sect1>


<!--
vim: tw=128
-->
