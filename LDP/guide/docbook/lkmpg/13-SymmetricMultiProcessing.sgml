<sect1><title>Symmetrical Multi-Processing</title>

  <indexterm><primary>SMP</primary></indexterm>
  <indexterm><primary>multi-processing</primary></indexterm>
  <indexterm><primary>symmetrical multi-processing</primary></indexterm>
  <indexterm>
    <primary>processing</primary>
    <secondary>multi</secondary>
  </indexterm>

	<para>Good writing style says we have a paragraph here.</para>

	<sect2><title>Symmetrical Multi-Processing</title>

		<para>
			One of the easiest (read, cheapest) ways to improve hardware performance
			is to put more than one <acronym>CPU</acronym> on the board.
			<indexterm>
				<primary>CPU</primary>
				<secondary>multiple</secondary>
			</indexterm>
			This can be done either making the different <acronym>CPU</acronym>s take
			on different jobs (asymmetrical multi-processing) or by making them all
			run in parallel, doing the same job (symmetrical multi-processing, a.k.a.
			<acronym>SMP</acronym>).  Doing asymmetrical multi-processing effectively
			requires specialized knowledge about the tasks the computer should do,
			which is unavailable in a general purpose operating system such as Linux.
			On the other hand, symmetrical multi-processing is relatively easy to
			implement.
		</para>
 
		<para> 
			By relatively easy, I mean exactly that -- not that it's
			<emphasis>really</emphasis> easy.  In a symmetrical multi-processing
			environment, the <acronym>CPU</acronym>s share the same memory, and as a
			result code running in one <acronym>CPU</acronym> can affect the memory
			used by another.  You can no longer be certain that a variable you've set
			to a certain value in the previous line still has that value -- the other
			<acronym>CPU</acronym> might have played with it while you weren't
			looking.  Obviously, it's impossible to program like this.
		</para>

		<para>
			In the case of process programming this normally isn't an issue, because
			a process will normally only run on one <acronym>CPU</acronym> at a time. 
			<footnote>
				<para>
					The exception is threaded processes, which can run on several
					<acronym>CPU</acronym>s at once.
				</para>
			</footnote>
			The kernel, on the other hand, could be called by different processes
			running on different <acronym>CPU</acronym>s.
		</para>

		<para>
			In version 2.0.x, this isn't a problem because the entire kernel is in
			one big spinlock.  This means that if one <acronym>CPU</acronym> is in
			the kernel and another <acronym>CPU</acronym> wants to get in, for
			example because of a system call, it has to wait until the first
			<acronym>CPU</acronym> is done.  This makes Linux <acronym>SMP</acronym>
			safe,
			<footnote>
				<para>Meaning it is safe to use it with <acronym>SMP</acronym></para>
			</footnote>
			but terriably inefficient. 
		</para>

		<para>
			In version 2.2.x, several <acronym>CPU</acronym>s can be in the kernel at
			the same time.  This is something module writers need to be aware of.  I
			got somebody to give me access to an <acronym>SMP</acronym> box, so
			hopefully the next version of this book will include more information.
		</para>

<!--  Unfortunately, I don't have access to an SMP box to test things, so I
			can't write a chapter about how to do it right. It anybody out there has
			access to one and is willing to help me with this, I'll be grateful. If a
			company will provide me with this access, I'll give them a free one
			paragraph ad at the top of this chapter.
-->
	</sect2>
</sect1>
