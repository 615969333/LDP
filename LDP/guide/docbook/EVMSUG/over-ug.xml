<chapter id="intro"><title>What Is EVMS?</title>

<para>Enterprise Volume Management System (EVMS) brings a new model of volume management to Linux&reg;. EVMS integrates all aspects of volume management, such as disk partitioning, Linux logical volume manager (LVM) and multi-disk (MD) management, and filesystem operations into a single cohesive package. With EVMS, various volume managemet technologies are accessible through one interface, and new technologies can be added as they are developed. </para>

<sect1 id="cando"><title>Why Choose EVMS?</title>
	<para>EVMS allows you to manage your storage  space in a way that is more intuitive and flexible than many other Linux volume management systems. Practical tasks such as migrating disks or adding new disks to your Linux system become more managable with EVMS because of its ability to recognize and read from different volume types and filesystems. EVMS provides additional safety controls by not allowing unsafe commands. These controls help maintain the integrity of the data stored on the system. </para>

<para>You can use EVMS  to create and manage data storage. With EVMS, you can use multiple volume management technologies under one framework. With one framework, you can access many technologies while ensuring your system will still interact correctly with stored data. With EVMS, you are able to use bad block relocation, shrink and expand volumes, create snapshots of your volumes, and set up RAID (redundant array of independent devices) features for your system. You are also able to use many types of filesystems and manipulate these storage pieces in ways that best meet your needs for your particular work environment. </para>

<para></para>

<para>EVMS provides a choice of user interfaces that allow you to manage your storage space. Additionally, if you need to design your own interface for EVMS, the system allows you to create customized interfaces.   </para>
</sect1>

<sect1 id="uis"><title>Why Are There Different User Interfaces?</title>

<para>There are currently three user interfaces available for EVMS: graphical (GUI), text mode (Ncurses), and the Command Line Interpreter (CLI). You can use the EVMS Application Programming Interface to implement your own customized user interface. An example of a customized user interface is the EVMS emulation of the Linux LVM command set that comes standard with the EVMS download.  </para>
<para><xref linkend="userinterf"/> lists details about each of the user interfaces and when each is appropriate.

</para>
<table id="userinterf" frame="all"><title>EVMS User Interfaces</title>
<tgroup cols="4">
<thead><row><entry>User Interface</entry>
<entry>Typical User</entry>
<entry>Types of Use</entry>
<entry>Function</entry></row></thead>
<tbody><row><entry>GUI</entry>
<entry>All</entry>
<entry>All uses except automation</entry>
<entry>Allows you to choose from available options only, instead of having to sort through all the options, including ones that are not available at that point in the process. </entry></row>
<row><entry>Ncurses</entry>
<entry>Users who don't have GTK libraries or X Window Systems on their machines</entry>
<entry>All uses except automation</entry>
<entry>Allows you to choose from available options only, instead of having to sort through all the options, including ones that are not available at that point in the process. </entry></row>
<row><entry>Command Line</entry>
<entry>Expert</entry>
<entry>All uses</entry>
<entry>Allows easy automation of  tasks</entry></row>
<row><entry>LVM Emulation Tools</entry>
<entry>Experienced LVM User</entry>
<entry>LVM manipulation</entry>
<entry>Allows users to keep old scripts and knowledge base with only slight changes. </entry></row></tbody></tgroup>
</table>
</sect1>

<sect1 id="terminology">
<title>What Terms Does EVMS Use for Volume Management?</title>
	<para>To avoid confusion with other terms used to describe volume 
	management, EVMS uses a set of terms specific to EVMS.  The following list 
	defines volume management  terms as they relate  to EVMS. The terms 
	are listed from most fundamental to most comprehensive.
	</para>

		<variablelist>

		<varlistentry><term>Logical Disk</term>
		<listitem><para>Representation of anything EVMS can access as a physical disk. 
		In EVMS, physical disks are logical disks.</para></listitem>
		</varlistentry>

                <varlistentry><term>Sector</term>
		<listitem><para>The lowest level of addressability on a block
		device. This definition is in keeping with the standard
		meaning found in other management systems.</para></listitem>
		</varlistentry>

		<varlistentry><term>Disk Segment</term>
		<listitem><para>An ordered set of physically contiguous
		sectors residing on the same storage object. 
		The general analogy for a segment is to a traditional disk
		partition, such as DOS or OS/2 &reg;</para></listitem>
		</varlistentry>

		<varlistentry><term>Storage Region</term>
		<listitem><para>An ordered set of logically contiguous sectors
		that  are not necessarily physically contiguous. </para></listitem>
		</varlistentry>

		<varlistentry><term>Storage Object</term>
		<listitem><para>Any persistent memory structure in EVMS that can be used to 
		build objects or create a volume. Storage object is a  generic term for disks, segments, regions, and feature objects.</para></listitem>
		</varlistentry>

		<varlistentry><term>Storage Container</term>
		<listitem><para>A collection of storage objects. A storage
		container consumes one set of storage objects and produces new 
		storage objects. One common subset of storage containers is volume groups, 
		such as AIX&reg;  or LVM.</para></listitem>
		</varlistentry>

		<varlistentry><term>Feature Object</term>
		<listitem><para>A storage object that contains an EVMS native feature, such as 
		bad block relocation. </para>
		<para>An <glossterm>EVMS Native Feature</glossterm> is a  function of volume management designed 
		and implemented by 
		EVMS. These features are not intended to be backwards compatible with other 
		volume management technologies. </para></listitem> 
		</varlistentry>

		<varlistentry><term>Logical Volume</term>
		<listitem><para>A volume that consumes a storage object and exports 
		something mountable. There are two varieties of logical volumes: <glossterm>EVMS Volumes</glossterm> 
		and <glossterm>Compatibility Volumes</glossterm>.</para>
		<para> <glossterm>EVMS  Volumes</glossterm> contain EVMS native metadata and can support all 
		EVMS features. <filename>/dev/evms/my_volume</filename> would be an example 
		of an EVMS Volume.</para>
		<para><glossterm>Compatibility Volumes</glossterm> do not contain any EVMS native metadata. 
		Compatibility volumes are backward compatible to their particular scheme, but 
		they cannot support EVMS features. <filename>/dev/evms/md/md0</filename> would 
		be an example of a compatibility  volume. </para></listitem>
		</varlistentry>
		</variablelist>
	</sect1>
<sect1><title>What Makes EVMS So Flexible?</title>

<para>By dividing the labor between the Runtime and the Engine, EVMS reduces the size and kernel resources  the system requires. The Runtime resides in kernel space and handles the actual use of the volumes. The Engine resides in user space and handles the creation, configuration, and management of volumes, segments, and disks.  The EVMS Engine is a programmatic interface to the EVMS system. User interfaces and programs that use EVMS must go through the Engine. </para>

<para>EVMS provides the capacity for plug-in modules that allow EVMS to perform specialized tasks without altering the core code. These plug-in modules  reside in  kernel space and user space. A kernel space plug-in will have a corresponding user space plug-in module that provides the configuration and management tasks that are needed by the plug-in. The use of plug-in modules allow EVMS to be more extensible and customizable than other volume management systems. This design also allows EVMS to use only the resources needed to handle a volume. </para>
	      
		<sect2 id="LAYERDEF">
		<title>Plug-in Layer Definitions</title>
		<para>EVMS defines a layered architecture where plug-ins in each layer
		create abstractions of the layer or layers below. EVMS also allows most plug-ins
		to create abstractions of objects within the same layer. The following
		list defines these layers from the bottom up.</para>
			
		<variablelist termlength="15">
		<varlistentry><term>Device Managers</term>
			<listitem><para>The first layer is the device managers.
			These plug-ins communicate with the hardware device drivers to
			create the first EVMS objects. Currently, all devices are handled by a single plug-in.
			Future releases of EVMS might need additional device managers
			to do network device management, such as for disks on a storage
			area network (SAN).</para></listitem>
		</varlistentry>	
		<varlistentry><term>Segment Managers</term>
			<listitem><para>The second layer is the segment managers. These plug-ins
			 handle the segmenting, or partitioning,
			of disk drives. The Engine components can replace partitioning
			programs, such as <command>fdisk</command> and
			<application>Disk Druid</application>, and the kernel components
			can replace the in-kernel disk partitioning code. Segment
			managers can also be "stacked," meaning that one segment manager
			can take as input output from another segment manager.</para>

			<para> EVMS provides the following segment managers: 
			DOS, GPT, and System/390&reg; (S/390). Other segment manager
			plug-ins can be added to support other 
			partitioning schemes.</para></listitem>
		</varlistentry>	
		<varlistentry><term>Region Managers</term>
			<listitem><para>The third layer is the region managers. This
			layer is intended to provide a place for plug-ins that ensure
			compatibility with existing volume management schemes in Linux
			or other operating systems. Region managers are intended to
			model systems that provide a logical abstraction above disks
			or partitions.</para>

			<para>Like the segment managers, region managers can also be
			stacked. Therefore, the input object(s) to a region manager can
			be disks, segments, or other regions.</para>

			<para>There are currently four region manager plug-ins in EVMS: 
			Linux LVM, AIX, OS/2, and Multi-Disk (MD).
			<variablelist><varlistentry><term>Linux LVM</term>
				<listitem><para>The Linux LVM plug-in provides compatibility with
				the Linux LVM and allows the creation of volume groups 
				(known in EVMS as containers) and logical volumes 
				(known in EVMS as regions). </para></listitem></varlistentry>

				<varlistentry><term>AIX LVM</term>
				<listitem><para>The AIX LVM provides compatibility with AIX and is similar in functionality 
				to the Linux LVM by also using volume groups and logical 
				volumes. </para></listitem></varlistentry>
			
				<varlistentry><term>OS/2 LVM</term>
				<listitem><para>The OS/2 plug-in provides compatibility with 
				volumes created under
				OS/2. Unlike the Linux and AIX LVMs, the OS/2 LVM 
				is based on linear linking of disk partitions, as well as
				bad-block relocation. The OS/2 LVM does not allow for modifications.</para></listitem></varlistentry>
			
				<varlistentry><term>MD LVM</term>
				<listitem><para>The Multi-Disk (MD) plug-in for RAID provides 
				RAID levels linear, 0, 1, 4, and 5 in 
				software. MD is one plug-in that will appear as four region
				managers you will be able to choose from.</para></listitem></varlistentry>
			</variablelist></para></listitem>
		</varlistentry>	
		<varlistentry><term>EVMS Features</term>
			<listitem><para>The next layer is EVMS features. This layer is
			where new EVMS-native functionality is implemented. EVMS
			features can be built on any object in the system, including
			disks, segments, regions, or other feature objects. EVMS
			features all share a common type of metadata, which makes
			discovery of feature objects much more efficient, and recovery
			of broken features objects much more reliable. There are three 
			features currently available in EVMS: Drive Linking, Bad Block Relocation, 
			and Snapshotting. </para>

<variablelist>
<varlistentry><term>Drive Linking</term>
<listitem><para>The Drive Linking feature allows any
			number of objects to be linearly concatenated together into a
			single object. A Drive Linked volume can be expanded by 
			adding another storage object to the end or shrunk by removing the last object.</para></listitem></varlistentry>

<varlistentry><term>Bad Block Relocation</term>
<listitem><para>The Bad Block Relocation (BBR) feature 
			monitors its I/O path and detects write failures (which can be
			caused by a damaged disk). In the event of such a failure, the
			data from that request is stored in a new location. BBR keeps
			track of this remapping. Additional I/Os to that
			location are redirected to the new location.</para></listitem></varlistentry>

<varlistentry><term>Snapshotting</term>
<listitem><para>The Snapshotting feature provides
			a mechanism for creating a "frozen" copy of a volume at a single
			instant in time, without having to take that volume off-line.
			This is useful for performing backups on a live system.
			Snapshots work with any volume (EVMS or compatibility), and can
			use any other available object as a backing store. After a
			snapshot is created and made into an EVMS volume, writes to the "original" volume cause the
			original contents of that location to be copied to the snapshot's
			storage object. Reads to the snapshot volume look like they
			come from the original at the time the snapshot was created.
</para></listitem></varlistentry></variablelist>
			

			</listitem>
		</varlistentry>
		<varlistentry><term>File System Interface Modules</term>
			<listitem><para>File System Interface Modules (FSIMs) are
			the one layer of EVMS that exists only in user space.
			These plug-ins are used to provide coordination with the
			filesystems during certain volume management operations. For
			instance, when expanding or shrinking a volume, the filesystem
			must also be expanded or shrunk to the appropriate size.
			Ordering in this example is also important; a filesystem cannot
			be expanded before the volume, and a volume cannot be shrunk
			before the filesystem. The FSIMs allow EVMS to ensure this
			coordination and ordering.</para>

			<para>FSIMs also perform filesystem
			operations from one of the EVMS user interfaces. For instance,
			a user can make new filesystems and check existing filesystems
			by interacting with the FSIM.</para></listitem>
		</varlistentry>
		</variablelist>
	    </sect2>
</sect1>

</chapter>




