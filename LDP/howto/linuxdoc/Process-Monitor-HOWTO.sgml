<!doctype linuxdoc system>

<!-- 
************************** begin comment *****************************
     The following is the HOW-TO for Monitoring Linux/Unix Processes. 
     This document is in the SGML format. You must use sgml package 
     to process this document
************************* end of comment *****************************
 -->
<!--
************************** SGML USER GUIDE *****************************
	The SGML user guide on linux is located at /usr/doc/sgml-tools
	Read the example.sgml and guide.html documents.
	Usage:
		HTML	  	sgml2html foo  (Do not give extension .sgml here!!)
		Text	 	sgml2txt foo.sgml
		Latex	  	sgml2latex foo.sgml

		Note: Use 2 dashes - before language, error while compiling
		Postscript 	sgml2latex -language=english -o ps foo.sgml
		DVI  		sgml2latex -d foo.sgml
		Lyx			sgml2lyx foo.sgml
		Richtext 	sgml2rtf foo.sgml
		gnuinfo  	sgml2info foo.sgml
		man			sgml2txt -man foo.sgml
		SGML	 	sgmlcheck foo.sgml
************************* end of comment *****************************
-->

<article>

<!-- Title information -->

<title>Process Monitor HOW-TO for Linux
<!-- chapt change
Process Monitor HOW-TO for Linux

-->
<author> Al Dev (Alavoor Vasudevan)
       <htmlurl url="mailto:alavoor@yahoo.com"
		name="alavoor@yahoo.com">
<date>v11.0, 14 June 2001

<abstract>
This document describes how to monitor Linux/Unix processes and to re-start them automatically
if they die without any manual intervention. This document also has URLs for "Unix Processes" FAQs.
</abstract>

<!-- Table of contents -->
<toc>

<!-- Begin the document -->

<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Linux or Unix Processes
-->
<sect> Linux or Unix Processes
<p>
Processes are the "heart" of the Linux/Unix processes. It is very important to monitor the
application processes to ensure 100% availability and reliability of the computer system. 
For example, processes of databases, web-server etc.. need to be up and running 24 hours a 
day and 365 days a year.
Use the tools described in this document to the monitor important application processes.

See also the following related topics on Linux/Unix processes.
<itemize>
<item> Unix Programming FAQ - Chapter 1 Unix Processes <url url="http://www.erlenstar.demon.co.uk/unix/faq_toc.html">
<p>
<item> Other FAQs on Unix are at <url url="http://www.erlenstar.demon.co.uk/unix/">
<p>
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Unix/Linux command - procautostart
-->
<sect> Unix/Linux command - procautostart
<p>
Use the program <bf>procautostart</bf> (say "Prok-Auto-Start" or Process AutoStart) to 
monitor and automatically re-start 
any Unix/Linux process if they die. This tiny program is very powerful and is
comparable to big commercial products which <bf>costs about $80,000US</bf>. 
Procautostart can be used for controlling following applications:
<itemize>
<item> For real-time control of process industries like chemical, manufacturing, power
generation and others. Use <it>nano-seconds</it> in program to get fine control.
<item> For controlling processes of software applications like Web servers, database servers,
mission critical unix processes, etc..
<item> As an alarm system for any general monitoring software system. The program can
fire a pager or call cell phone or flash red lights on the computer screen. For calling a phone
line you may need to use a Telephone card on PCI slot of the computer.
</itemize>

The program listing is given in following sections in this document. 

<bf>procautostart </bf> <bf>-n </bf>  <it>&lt delay_seconds &gt</it> <bf>-c </bf>  "<it>&lt command_line &gt</it>" nohup &amp

This starts the unix process <bf>procautostart</bf> and also <bf>command_line</bf> 
process. The <bf>procautostart</bf> process will re-start <bf>command_line</bf> 
process if it dies. The <it>-n</it> option is the time delay in seconds before <bf>procautostart</bf>
checks the running process started by <bf>command_line</bf>. It is advisable to start the procautostart as 
background process with no-hangup using "nohup &amp".  See 'man nohup'.

The procautostart is written in "C" so that it is very fast and efficient, since the program is called
every <it>n</it> seconds. Amount of resources consumed by procautostart is <bf>very minute</bf>
and is negligible since the program size is small and is highly optimized with -o3 compiler option.

For example -
<code>
	procautostart -n 12 -c "monitor_test -d $HOME  -a dummy_arg " nohup &
</code>
Here <bf>procautostart</bf> will be checking the process monitor_test <bf>every</bf> 12 seconds.

The program will output log files in 'mon' sub-directory which has datetime stamp of when the
processes died and re-started. These files gives info on how often the processes are dying.

You can also use micro-seconds option '-m' or nano-seconds option '-o', edit the source code file
<bf>procautostart.cpp</bf> and uncomment appropriate lines.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> File procautostart.cpp
-->
<sect> File procautostart.cpp
<p>
// From your browser save this file as <bf>text-file</bf> named as 'procautostart.cpp'. 
<code>
// Author: Al Dev alavoor@yahoo.com
//
// Program to monitor the unix processes
// and automatically re-start them if they die
//
//************************************************************************
//  NOTE: This program uses the Al Dev's String class library. Download string 
//        class from  http://linuxdoc.org/HOWTO/C++Programming-HOWTO.html
//************************************************************************


#include <stdio.h>
#include <strings.h> // C strings
#include <unistd.h> // for getopt
#include <alloc.h> // for free

#include <errno.h> // for kill() - error numbers command
extern int errno;

#ifdef Linux
#include <asm/errno.h> // for kill() - error numbers command
#endif

#include <sys/types.h> // for kill() command
#include <signal.h> // for kill() command
#include <sys/wait.h> // for wait()
#include <stdlib.h> // for setenv()
#include <time.h> // for strftime()
#include <libgen.h> // for basename()

//#include <syslog.h> // for logging 

#include "debug.h"
#include "String.h"
#include "StringTokenizer.h"

#define BUFF_HUN	100
#define BUFF_THOU	1024
#define PR_INIT_VAL	-10
#define WAIT_FOR_SYS   	5  // wait for process to start up
#define DEF_SL_SECS   	6  // default sleep time
#define SAFE_MEM   	10  // to avoid any possible memory leaks

#define LOG_NO   	false  // do not output to logfile
#define LOG_YES   	true  // do output to logfile
#define STD_ERR_NO	false  // do not print to std err
#define STD_ERR_YES	true  // do print to std err
#define DATE_NO   	false  // do not print date
#define DATE_YES   	true  // do print date

int start_process(char *commandline, char *args[], char **envp, pid_t proc_pid);
int fork2(pid_t parent_pid, unsigned long tsecs);
inline void error_msg(char *mesg_out, char *lg_file, bool pr_lg, bool std_err, bool pr_dt);

//////////////////////////////////////////////
// To test this program use --
// procautostart -n 5 -c 'monitor_test dummy1 -a dummy2 -b dummy3  ' &
//////////////////////////////////////////////

void usage(char **argv)
{

    printf("%s:\n", argv[0]);
    printf("\ninterval specification:\n");
    printf(" -n # -- seconds\n");
    printf(" -m # -- microseconds\n");
    printf(" -o # -- nanoseconds\n");
    printf("\nprocess specification:\n");
    printf(" -c 'cmdline'\n");
    printf
	(" -p pidfile -- if specified reads process pid from this file\n");
    printf("\n");

	printf("\nUsage : %s -n <seconds> -m <microsecond> -o <nanosecond> -c '<command>'\n", argv[0]);
	printf("\nExample: procautostart -n 5 -c 'monitor_test dummy1 -a dummy2 -b dummy3  ' \n");

    exit(-1);
}

int main(int argc, char **argv, char **envp)
{
	unsigned long 	sleep_sec, sleep_micro, sleep_nano;
	int 	ch;
	pid_t	proc_pid;
	int pr_no = PR_INIT_VAL;
	char mon_log[40];
	char *pr_name = NULL, **cmdargs = NULL;
	String cmdline;
    char *pidfile = NULL;

	// you can turn on debug by editing Makefile and put -DDEBUG_PRT in gcc
	debug_("test debug", "this line"); 
	debug_("argc", argc); 

	// Use getpid() - man 2 getpid()
	proc_pid = getpid(); // get the Process ID of procautostart
	debug_("PID proc_pid", (int) proc_pid);

	// Create directory to hold log, temp files
	system("mkdir mon 1>/dev/null 2>/dev/null");

	sleep_sec = DEF_SL_SECS ; // default sleep time
	sleep_micro = 0; // default micro-sleep time
	sleep_nano = 0; // default nano-sleep time
	optarg = NULL;
	while ((ch = getopt(argc, argv, "n:m:o:h:c:")) != -1) // needs trailing colon :
	{
		switch (ch)
		{
			case 'n':
				debug_("scanned option n ", optarg);
				sleep_sec = atoi(optarg);	
				debug_("sleep_sec", sleep_sec);
				break;
			case 'm':
				debug_("scanned option m ", optarg);
				sleep_micro = atoi(optarg);	
				debug_("sleep_micro", sleep_micro);
				break;
			case 'o':
				debug_("scanned option o ", optarg);
				sleep_nano = atoi(optarg);	
				debug_("sleep_nano", sleep_nano);
				break;
			case 'c':
				debug_("scanned option c ", optarg);
				cmdline = optarg;
				//cmdline = strdup(optarg); // does auto-malloc here
				debug_("cmdline", cmdline.val());
				break;
			case 'h':
				debug_("scanned option h ", optarg);
				usage(argv);
				break;
            case 'p':
                pidfile = strdup(optarg);
                break;

			default:
				debug_("ch", "default");
				usage(argv);
				break;
		}
	}

	if (cmdline.length() == 0) //if (cmdline == NULL)
		usage(argv);

	// detach from the main process
    if (fork())  // 0 returned in child process
		exit(0); // exit parent process - non-zero child PID got here... 

    //openlog(argv[0], LOG_PID, LOG_DAEMON);

	// trim the trailing blanks -- otherwise problem in grep command
	//cmdline.trim(true);
	//cmdline.chopall('&'); // trim trailing ampersand
	debug_("cmdline", cmdline.val());

	// Start the process
	{
		// Find the command line args
		StringTokenizer strtokens(cmdline.val());  // string tokenizer is borrowed from Java
		cmdargs = (char **) calloc(strtokens.countTokens() + SAFE_MEM, sizeof(char *));
		debug_("countTokens()", strtokens.countTokens());
		for (int tmpii = 0; strtokens.hasMoreTokens(); tmpii++)
		{
			cmdargs[tmpii] = strdup(strtokens.nextToken().val());
			debug_("tmpii", tmpii);
			debug_("cmdargs[tmpii]", (char *) cmdargs[tmpii]);
		}

		// In case execve you MUST NOT have trailing ampersand & in the command line!!
		//pr_no = start_process(cmdline, NULL, NULL, proc_pid);  // Using execlp ...
		pr_no = start_process(cmdargs[0], & cmdargs[0], envp, proc_pid); // Using execve ....
		//cmdpid = start_command(cmdargs, envp, pidfile);
		
		// You can also use syslog if you do not like above logging
		//syslog(LOG_NOTICE, "Started process: %s", cmdline.val());

		debug_("The child pid", pr_no);
		if (pr_no < 0)
		{
			fprintf(stderr, "\nFatal Error: Failed to start the process\n");
			exit(-1);
		}
		sleep(WAIT_FOR_SYS); // wait for the process to come up

		// Get process name - only the first word from cmdline
		pr_name = strdup(basename(cmdargs[0])); // process name,  does auto-malloc here
	}

	// generate log file names
	{
		char	aa[21];

		strncpy(aa, pr_name, 20); aa[20] = '\0';
		// Define mon file-names - make it unique with combination of
		// process name and process id
		sprintf(mon_log, "mon/%s%d.log", aa, (int) proc_pid);
	}

	// Print out pid to log file
	if (pr_no > 0)
	{
		char aa[200];
		sprintf(aa, "Process ID of %s is %d", pr_name, pr_no);
		error_msg(aa, mon_log, LOG_YES, STD_ERR_NO, DATE_YES);
	}

	// monitors the process - restarts if process dies...
	char print_log[200];
	while (1)  // infinite loop - monitor every 6 seconds
	{
		//debug_("Monitoring the process now...", ".");
        switch (kill(pr_no, 0))
        {
            case 0:
                break;

            default:
            case ESRCH:    // process died !!
				// ERSRCH means - No process can be found corresponding to pr_no
				// hence process had died !!
				sprintf(print_log, "Error ESRCH: No process or process group can be found for %d", pr_no);
				error_msg(print_log, mon_log, LOG_YES, STD_ERR_YES, DATE_YES);
				// You can also use syslog if you do not like above logging
                //syslog(LOG_NOTICE, "PROCESS DIED: %s", cmdline.val());
				//pr_no = start_process(cmdline, NULL, NULL, proc_pid);  // Using execlp ....
				pr_no = start_process(cmdargs[0], & cmdargs[0], envp, proc_pid); // Using execve ....
				// You can also use syslog if you do not like below logging
                //syslog(LOG_NOTICE, "Started process: %s", cmdline.val());
				sprintf(print_log, "Starting process %s", pr_name);
				error_msg(print_log, mon_log, LOG_YES, STD_ERR_NO, DATE_NO);
				sleep(WAIT_FOR_SYS); // wait for the process to come up
                break;
        }
		sprintf(print_log, "Process ID of %s is %d", pr_name, pr_no);
		error_msg(print_log, mon_log, LOG_YES, STD_ERR_NO, DATE_NO);
		//debug_("Sleeping now ......", ".");
		sleep(sleep_sec);

		// Uncomment these to use micro-seconds
		// For real-time process control use micro-seconds or nana-seconds sleep functions
		// See 'man3 usleep', 'man 2 nanasleep'
		// If you do not have usleep() or nanosleep() on your system, use select() or poll()
		// specifying no file descriptors to test.
		//usleep(sleep_micro);

		// To sleep nano-seconds ...  Uncomment these to use nano-seconds
		//struct timespec *req = new struct timespec;
		//req->tv_sec = 0; // seconds
		//req->tv_nsec = sleep_nano; // nanoseconds
		//nanosleep( (const struct timespec *)req, NULL);

		/* You can use select instead of sleep for portability
        struct timeval interval;
		interval.tv_sec += tmp;
		interval.tv_usec += (long int) 1e3 *tmp;
        select(1, NULL, NULL, NULL, & interval);
		*/
	}
	//closelog(); if using syslog
}

inline void error_msg(char *mesg_out, char *lg_file, bool pr_lg, bool std_err, bool pr_dt)
{
	if (pr_lg) // (pr_lg == true) output to log file
	{
		char tmp_msg[BUFF_THOU];
		if (pr_dt == true) // print date and message to log file 'lg_file'
		{
			sprintf(tmp_msg, "date >> %s; echo '\n%s\n' >> %s\n ", 
				lg_file, mesg_out, lg_file);
			system(tmp_msg);
		}
		else
		{
			sprintf(tmp_msg, "echo '\n%s\n' >> %s\n ", 
				mesg_out, lg_file);
			system(tmp_msg);
		}
	}

	if (std_err) // (std_err == true) output to standard error
		fprintf(stderr, "\n%s\n", mesg_out);
	
	//debug_("mesg_out", mesg_out);
}

// start a process and returns PID or -ve value if error
// The main() function has envp arg as in - main(int argc, char *argv[], char **envp)
int start_process(char *commandline, char *args[], char **envp, pid_t parent_pid)
{
	int ff;
	unsigned long  tsecs;

	tsecs = time(NULL); // time in secs since Epoch 1 Jan 1970
	debug_("Time tsecs", tsecs); 

	// Use fork2() instead of fork to avoid zombie child processes
	switch (ff = fork2(parent_pid, tsecs))  // fork creates 2 process each executing the following lines
	{
	case -1:
		fprintf(stderr, "\nFatal Error: start_process() - Unable to fork process\n");
		_exit(errno);
		break;
	case 0:  // child process
		debug_("\nStarting the start child process\n", " ");
		// For child process to ignore the interrupts (i.e. to put
		// child process in "background" mode.
		// Signals are sent to all processes started from a 
		// particular terminal. Accordingly, when a program is to be run non-interactively
		// (started by &), the shell arranges that the program will ignore interrupts, so
		// it won't be stopped by interrupts intended for foreground processes.
		// Hence if previous value of signal is not IGN than set it to IGN.

		// Note: Signal handlers cannot be set for SIGKILL, SIGSTOP 
		if (signal(SIGINT, SIG_IGN) == SIG_ERR)
			fprintf(stderr, "\nSignal Error: Not able to set signal to SIGINT\n");
		else
		if (signal(SIGINT, SIG_IGN) != SIG_IGN) // program already run in background
			signal(SIGINT, SIG_IGN);  // ignore interrupts

		if (signal(SIGHUP, SIG_IGN) == SIG_ERR)
			fprintf(stderr, "\nSignal Error: Not able to set signal to SIGHUP\n");
		else
		if (signal(SIGHUP, SIG_IGN) != SIG_IGN) // program already run in background
			signal(SIGHUP, SIG_IGN);  // ignore hangups

		if (signal(SIGQUIT, SIG_IGN) == SIG_ERR)
			fprintf(stderr, "\nSignal Error: Not able to set signal to SIGQUIT\n");
		else
		if (signal(SIGQUIT, SIG_IGN) != SIG_IGN) // program already run in background
			signal(SIGQUIT, SIG_IGN);  // ignore Quit

		if (signal(SIGABRT, SIG_IGN) == SIG_ERR)
			fprintf(stderr, "\nSignal Error: Not able to set signal to SIGABRT\n");
		else
		if (signal(SIGABRT, SIG_IGN) != SIG_IGN) // program already run in background
			signal(SIGABRT, SIG_IGN);  // ignore ABRT

		if (signal(SIGTERM, SIG_IGN) == SIG_ERR)
			fprintf(stderr, "\nSignal Error: Not able to set signal to SIGTERM\n");
		else
		if (signal(SIGTERM, SIG_IGN) != SIG_IGN) // program already run in background
			signal(SIGTERM, SIG_IGN);  // ignore TERM

		// sigtstp - Stop typed at tty. Ignore this so that parent process 
		// be put in background with CTRL+Z or with SIGSTOP
		if (signal(SIGTSTP, SIG_IGN) == SIG_ERR)
			fprintf(stderr, "\nSignal Error: Not able to set signal to SIGTSTP\n");
		else
		if (signal(SIGTSTP, SIG_IGN) != SIG_IGN) // program already run in background
			signal(SIGTSTP, SIG_IGN);  // ignore TSTP

		// You can use debug_ generously because they do NOT increase program size!
		debug_("before execve commandline", commandline);
		debug_("before execve args[0]", args[0]);
		debug_("before execve args[1]", args[1]);
		debug_("before execve args[2]", args[2]);
		debug_("before execve args[3]", args[3]);
		debug_("before execve args[4]", args[4]);
		debug_("before execve args[5]", args[5]);
		debug_("before execve args[6]", args[6]);
		debug_("before execve args[7]", args[7]);
		debug_("before execve args[8]", args[8]);
		debug_("before execve args[9]", args[9]);
		execve(commandline, args, envp);

		// execlp, execvp does not provide expansion of metacharacters
		// like <, >, *, quotes, etc., in argument list. Invoke
		// the shell /bin/sh which then does all the work. Construct
		// a string 'commandline' that contains the complete command
		//execlp("/bin/sh", "sh", "-c", commandline, (char *) 0);  // if success than NEVER returns !!

		// If execlp returns than there is some serious error !! And
		// executes the following lines below...
		fprintf(stderr, "\nFatal Error: Unable to start child process\n");
		ff = -2;
		exit(127);
		break;
	default: // parent process
		// child pid is ff;
		if (ff < 0)
			fprintf(stderr, "\nFatal Error: Problem while starting child process\n");

		{
			char	buff[BUFF_HUN];
			FILE	*fp1;
			sprintf(buff, "mon/%d%lu.out", (int) parent_pid, tsecs); // tsecs is unsigned long
			fp1 = fopen(buff, "r");
			if (fp1 != NULL)
			{
				buff[0] = '\0';
				fgets(buff, BUFF_HUN, fp1);
				ff = atoi(buff);
			}
			fclose(fp1);
			debug_("start process(): ff - ", ff);
#ifndef DEBUG_PRT
			sprintf(buff, "rm -f mon/%d%lu.out", (int) parent_pid, tsecs);
			system(buff);
#endif // DEBUG_PRT
		}

		// define wait() to put child process in foreground or else put in background
		//waitpid(ff, & status, WNOHANG || WUNTRACED);
		//waitpid(ff, & status, WUNTRACED);
		//wait(& status); 

		break;
	}
	return ff;
}

/* fork2() -- like fork, but the new process is immediately orphaned
 *            (won't leave a zombie when it exits)
 * Returns 1 to the parent, not any meaningful pid.
 * The parent cannot wait() for the new process (it's unrelated).
 */
/* This version assumes that you *haven't* caught or ignored SIGCHLD. */
/* If you have, then you should just be using fork() instead anyway.  */

int fork2(pid_t parent_pid, unsigned long tsecs)
{
    pid_t mainpid, child_pid = -10;
    int status;
	char	buff[BUFF_HUN];

    if (!(mainpid = fork()))
    {
        switch (child_pid = fork())
        {
          case 0:
		  	//child_pid = getpid();
			//debug_("At case 0 fork2 child_pid : ", child_pid);
		  	return 0;
          case -1:
		  	_exit(errno);    /* assumes all errnos are <256 */
          default: 
			debug_("fork2 child_pid : ", (int) child_pid);
			sprintf(buff, "echo %d > mon/%d%lu.out", (int) child_pid, (int) parent_pid, tsecs);
			system(buff);
		  	_exit(0);
        }
    }

	//debug_("fork2 pid : ", pid);
    if (mainpid < 0 || waitpid(mainpid, & status, 0) < 0)
      return -1;

    if (WIFEXITED(status))
      if (WEXITSTATUS(status) == 0)
        return 1;
      else
        errno = WEXITSTATUS(status);
    else
      errno = EINTR;  /* well, sort of :-) */

    return -1;
}

//
// char respawn[1024];
// strcpy(respawn, cmdline);
// For "C" program use kill(pid_t process, int signal) function. 
// #include <signal.h> // See 'man 2 kill'  
// Returns 0 on success and -1 with errno set.
// 		kill -0 $pid 2>/dev/null || respawn
// To get the exit return status do --
// 		kill -0 $pid 2>/dev/null | echo $?
// Return value 0 is success and others mean failure
// Sending 0 does not do anything to target process, but it tests
// whether the process exists. The kill command will set its exit
// status based on this process.
//
// Alternatively, you can use
//		ps -p $pid >/dev/null 2>&1 || respawn
// To get the exit return status do --
//		ps -p $pid >/dev/null 2>&1 | echo $?
// Return value 0 is success and others mean failure


//***********************************************************************
//  	You can use pidfile to get the process id
//**********************************************************************
/* 
void poll_pidfile(char *pidfile)
{
    struct stat buf;
    struct timeval interval =       
    {
        tv_sec:0, tv_usec:(long int) 1e4
    }; // 10 miliseconds

    while (stat(pidfile, & buf) ? errno == ENOENT : buf.st_size == 0)
    {
        struct timeval i = interval;
        select(1, NULL, NULL, NULL, & i);
    }
}

int start_command(char **args, char **envp, char *pidfile)
{
    pid_t cmdpid;

    if (pidfile != NULL)
    {
        switch (unlink(pidfile))
        {
            case ENOENT:
            case 0:
                break;

            default:
                return -1;
        }
    }

    switch (cmdpid = fork2())
    {
        case 0: // child
            execve(args[0], args, envp);
            exit(-1);

        case -1: // error
            return -1;

        default: // parent
            break;
    }

    if (pidfile != NULL)
    {
        FILE *pf;

        poll_pidfile(pidfile);

        if ((pf = fopen(pidfile, "r")) == NULL)
        {
            syslog(LOG_ERR, "failed to read pidfile, using fork2 pid");
        }
        else
        {
            char textpid[1024];
            pid_t pid;

            fgets(textpid, sizeof(textpid), pf);
            if ((pid = atoi(textpid)) != -1)
            {
                cmdpid = pid;
            } else
            syslog(LOG_ERR,
                    "failed to find pid in pidfile, using fork2 pid");
            fclose(pf);
        }
    }

    return cmdpid;
}
*/
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> File debug.cpp 
-->
<sect> File debug.cpp 
<p>
// From your browser save this file as <bf>text-file</bf> named as 'debug.cpp'.
<p>
<code>
#ifdef DEBUG_PRT

#include "debug.h"
// Variable value[] can be char, string, int, unsigned long, float, etc...

void local_dbg(char name[], char value[], char fname[], int lineno, bool logfile) { 
	printf("\nDebug %s Line: %d %s is = %s\n", fname, lineno, name, value ); }

void local_dbg(char name[], int value, char fname[], int lineno, bool logfile) { 
	printf("\nDebug %s Line: %d %s is = %d\n", fname, lineno, name, value ); }

void local_dbg(char name[], unsigned int value, char fname[], int lineno, bool logfile) { 
	printf("\nDebug %s Line: %d %s is = %d\n", fname, lineno, name, value ); }

void local_dbg(char name[], long value, char fname[], int lineno, bool logfile) {
	printf("\nDebug %s Line: %d %s is = %ld\n", fname, lineno, name, value ); }

void local_dbg(char name[], unsigned long value, char fname[], int lineno, bool logfile) {
	printf("\nDebug %s Line: %d %s is = %ld\n", fname, lineno, name, value ); }

void local_dbg(char name[], short value, char fname[], int lineno, bool logfile) {
	printf("\nDebug %s Line: %d %s is = %d\n", fname, lineno, name, value ); }

void local_dbg(char name[], unsigned short value, char fname[], int lineno, bool logfile) {
	printf("\nDebug %s Line: %d %s is = %d\n", fname, lineno, name, value ); }

void local_dbg(char name[], float value, char fname[], int lineno, bool logfile) { 
	printf("\nDebug %s Line: %d %s is = %f\n", fname, lineno, name, value ); }

void local_dbg(char name[], double value, char fname[], int lineno, bool logfile) { 
	printf("\nDebug %s Line: %d %s is = %f\n", fname, lineno, name, value ); }

// You add many more here - value can be a class, ENUM, datetime, etc...

#endif // DEBUG_PRT
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> File debug.h
-->
<sect> File debug.h
<p>
// From your browser save this file as <bf>text-file</bf> named as 'debug.h'.
<p>
<code>
#ifdef DEBUG_PRT

#include <stdio.h>
//#include <strings.h>
//#include <assert.h>  // assert() macro which is also used for debugging

// Debugging code 
// Use debug2_ to output result to a log file
#define debug_(NM, VL) (void) ( local_dbg(NM, VL, __FILE__, __LINE__) )
#define debug2_(NM, VL, LOG_FILE) (void) ( local_dbg(NM, VL, __FILE__, __LINE__, LOG_FILE) )
void local_dbg(char name[], char value[], char fname[], int lineno, bool logfile= false);
void local_dbg(char name[], int value, char fname[], int lineno, bool logfile= false);
void local_dbg(char name[], unsigned long value, char fname[], int lineno, bool logfile= false);
void local_dbg(char name[], float value, char fname[], int lineno, bool logfile= false);

#else

#define debug_(NM, VL) ((void) 0)
#define debug2_(NM, VL, LOG_FILE) ((void) 0)

#endif // DEBUG_PRT
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Makefile
-->
<sect> Makefile
<p>
# From your browser save this file as <bf>text-file</bf> named as 'Makefile'.
<p>
<code>
#//*****************************************************************
#// Copyright policy is GNU/GPL and it is requested that
#// you include author's name and email on all copies
#// Author : Al Dev Email: alavoor@yahoo.com
#//*****************************************************************

.SUFFIXES: .pc .cpp .c .o

HOSTFLAG=-DLinux
#HOSTFLAG=-DSunOS

CC=gcc
CXX=g++

MAKEMAKE=mm
#LIBRARY=libString.a
DEST=/home/myname/lib

# Note: You should set only ONE value of MYCFLAGS below, that is only
# one line is uncommented and others are commented.
# Use options -Wall (all warning msgs) -O3 (optimization)
MYCFLAGS=-DDEBUG_PRT -g3 -Wall
#MYCFLAGS=-O3 -Wall

#PURIFY=purify -best-effort

SRCS=procautostart.cpp debug.cpp 
#HDR=my_malloc.h  String.h StringTokenizer.h File.h debug.h string_multi.h
#LIBOBJS=my_malloc.o String.o StringTokenizer.o File.o debug.o
OBJS=procautostart.o  debug.o
EXE=procautostart

# For generating makefile dependencies..
SHELL=/bin/sh

CPPFLAGS=$(MYCFLAGS) $(OS_DEFINES)
CFLAGS=$(MYCFLAGS) $(OS_DEFINES)

#
# If the libString.a is in the current 
# directory then use -L. (dash L dot)
MYLIBDIR=-L$(MY_DIR)/libmy -L.

ALLLDFLAGS= $(LDFLAGS)  $(MYLIBDIR)

COMMONLIBS=-lstdc++ -lm
MYLIBS=-lString
LIBS=$(COMMONLIBS)  $(MYLIBS)

all: $(LIBRARY) $(EXE)

$(MAKEMAKE):
	@rm -f $(MAKEMAKE)
	$(PURIFY) $(CXX) -M  $(INCLUDE) $(CPPFLAGS) *.cpp > $(MAKEMAKE)

$(EXE): $(OBJS) $(LIBRARY)
	@echo "Creating a executable "
	$(PURIFY) $(CC) -o $(EXE) $(OBJS) $(ALLLDFLAGS) $(LIBS)

#$(LIBRARY): $(LIBOBJS)
#	@echo "\n***********************************************"
#	@echo "   Loading $(LIBRARY) ... to $(DEST)"
#	@echo "***********************************************"
#	@ar cru $(LIBRARY) $(LIBOBJS)
#	@echo "\n "

.cpp.o: $(SRCS) $(HDR)
#	@echo "Creating a object files from " $*.cpp " files "
	$(PURIFY) $(CXX) -c  $(INCLUDE) $(HOSTFLAG) $(CPPFLAGS) $*.cpp

.c.o: $(SRCS) $(HDR)
#	@echo "Creating a object files from " $*.c " files "
	$(PURIFY) $(CC) -c $(INCLUDE) $(HOSTFLAG) $(CFLAGS) $*.c

clean:
	rm -f *.o *.log *~ *.log.old *.pid core err a.out lib*.a afiedt.buf  *.class tags
	rm -f $(EXE)
	rm -f $(MAKEMAKE)
	ln -s ../cpphowto/libString.a .

#%.d: %.c
#	@echo "Generating the dependency file *.d from *.c"
#	$(SHELL) -ec '$(CC) -M $(CPPFLAGS) $< | sed '\''s/$*.o/& $@/g'\'' > $@'
#%.d: %.cpp
#	@echo "Generating the dependency file *.d from *.cpp"
#	$(SHELL) -ec '$(CC) -M $(CPPFLAGS) $< | sed '\''s/$*.o/& $@/g'\'' > $@'

# Must include all the c flags for -M option
#$(MAKEMAKE):
#	@echo "Generating the dependency file *.d from *.cpp"
#	$(CXX) -M  $(INCLUDE) $(CPPFLAGS) *.cpp > $(MAKEMAKE)

include $(MAKEMAKE)
#include $(SRCS:.cpp=.d)
#include $(SRCS:.c=.d)

</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Testing the program - monitor_test
-->
<sect> Testing the program - monitor_test
<p>
From your browser save this file as <bf>text-file</bf> named as 'monitor_test'.

Use this program for testing the 'procautostart' program.  For example -
<code>
	procautostart -n 12 -c "monitor_test -d $HOME  -a dummy_arg " nohup &
</code>
Here <bf>procautostart</bf> will be checking the process monitor_test <bf>every</bf> 12 seconds.
<p>
<code>
#!/bin/ksh

# Program to test the procautostart

echo "Started the monitor_test ...."
date > monitor_test.log
while :
do
	date >> monitor_test.log
	sleep 2
done
</code>
Then do a tail command to monitor the output. And simulate the failures of monitor_test
programs.
<code>
	bash$ tail -f monitor_test.log
	bash$ ps -ef | grep monitor_test
See the PID of monitor_test and kill it..
	bash$ kill -9 &lt PID of monitor_test >
</code>
Once you kill the process, you will notice that it immediately comes alive 
due to procautostart !
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Other Monitoring Tools
-->
<sect> Other Monitoring Tools
<p>
<sect1> Unix init command
<p>
The <bf>init</bf> command is a cool tool to do simple process monitoring.
Add :respawn: entry to your /etc/inittab, if you need procees
to be respawned. 
See the online manual page by typing 'man init' at bash prompt.
<!--
	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> OpenSource Monitoring Tools
<p>
On linux systems you can find the following packages. If it is not in the main 
cdrom than you must check in the contrib cdrom :
<itemize>
<item> On contrib cdrom <bf>daemontools*.rpm</bf>
<p>
<item> 'top' command <bf>procps*.rpm</bf>
<p>
<item> 'top' command graphic mode <bf>procps-X11*.rpm</bf>
<p>
<item> 'ktop' graphic mode <bf>ktop*.rpm</bf>
<p>
<item> 'gtop' graphic mode <bf>gtop*.rpm</bf>
<p>
<item> 'WMMon' CPU load <bf>wmmon*.rpm</bf>
<p>
<item> 'wmsysmon' monitor <bf>wmsysmon*.rpm</bf>
<p>
<item> 'procmeter' System activity meter <bf>procmeter*.rpm</bf>
<p>
</itemize>
To use top commands type at unix prompt -
<code>
	$ top
	$ ktop
	$ gtop
</code>
<!--
	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Monitoring Tool - "daemontools"
<p>
Visit the web site of daemontools at <url url="http://www.pobox.com/~djb/daemontools.html">
<p>
To install the daemontools RPM, do -
<code>
	# rpm -i /mnt/cdrom/daemontools*.html
	# man supervise
</code>

<bf>supervise</bf> monitors a service. It starts the service and restarts the
service if it dies. The companion svc program stops, pauses, or restarts
the service on sysadmin request. The svstat program prints a one-line
status report. See man page by 'man supervise'

<bf>svc</bf> - control a supervised service.
<p>
svc  changes  the status of a supervise-monitored service.
dir is the same directory used for supervise.
You can list several dirs.  svc will change the status  of
each service in turn.

<bf>svstat</bf> - print the status of a supervised service.
<p>
svstat prints the status of a supervise-monitored service.
dir is the same directory used for supervise.
You can list several dirs.  svstat will print  the  status
of each service in turn.

<bf>cyclog</bf> writes a log to disk. It automatically synchronizes the log every
100KB (by default) to guarantee data integrity after a crash. It
automatically rotates the log to keep it below 1MB (by default). If the
disk fills up, cyclog pauses and then tries again, without losing any
data. See man page by 'man cyclog'

<bf>accustamp</bf> puts a precise timestamp on each line of input. The timestamp
is a numeric TAI timestamp with microsecond precision. The companion
tailocal program converts TAI timestamps to local time. See 'man accustamp'

<bf>usually</bf> watches a log for lines that do not match specified patterns,
copying those lines to stderr. The companion errorsto program redirects
stderr to a file. See 'man usually'

<bf>setuser</bf> runs a program under a user's uid and gid. Unlike su, setuser
does not gain privileges; it does not check passwords, and it cannot be
run except by root. See 'man setuser'
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect1> Commercial Monitoring Tools
<p>
There are commercial monitoring tools available. Check out -
<itemize>
<item> BMC Patrol for Unix/Databases <url url="http://www.bmc.com">
<p>
<item> TIBCO corp's  Hawk for Unix monitoring <url url="http://www.tibco.com">
<p>
<item> LandMark corporation
<p>
<item> Platinum corporation
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt change> Related URLs
-->
<sect> Related URLs
<p>
Linux goodies main site is at <url url="http://www.aldev.8m.com"> 
Mirror sites are at -
<url url="http://aldev0.webjump.com">,
<url name="angelfire" url="http://www.angelfire.com/country/aldev0">,
<url name="geocities" url="http://www.geocities.com/alavoor/index.html">,
<url name="virtualave" url="http://aldev0.virtualave.net">,
<url name="50megs" url="http://aldev0.50megs.com">,
<url name="theglobe" url="http://members.theglobe.com/aldev1/index.html">,
<url name="NBCi" url="http://members.nbci.com/alavoor">,
<url name="Terrashare" url="http://aldev.terrashare.com">,
<url name="Fortunecity" url="http://members.fortunecity.com/aldev">,
<url name="Freewebsites" url="http://aldev.freewebsites.com">,
<url name="Tripod" url="http://members.tripod.lycos.com/aldev">,
<url name="Spree" url="http://members.spree.com/technology/aldev">,
<url name="Escalix" url="http://www.escalix.com/freepage/aldev">,
<url name="Httpcity" url="http://www.httpcity.com/aldev/index.html">,
<url name="Freeservers" url="http://aldev.freeservers.com">.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt change> Other Formats of this Document
-->
<sect> Other Formats of this Document
<p>
This document is published in 14 different formats namely - DVI, Postscript, 
Latex, Adobe Acrobat PDF,
LyX, GNU-info, HTML, RTF(Rich Text Format), Plain-text, Unix man pages, single 
HTML file, SGML (Linuxdoc format), SGML (Docbook format), MS WinHelp format.

This howto document is located at -
<itemize>
<item> <url url="http://www.linuxdoc.org"> and click on HOWTOs and search 
for howto document name using CTRL+f or ALT+f within the web-browser.
</itemize>

You can also find this document at the following mirrors sites -
<itemize>
<item> <url url="http://www.caldera.com/LDP/HOWTO">
<item> <url url="http://www.linux.ucla.edu/LDP">
<item> <url url="http://www.cc.gatech.edu/linux/LDP">
<item> <url url="http://www.redhat.com/mirrors/LDP">

<item> Other mirror sites near you (network-address-wise) can be found at
<url url="http://www.linuxdoc.org/mirrors.html">
select a site and go to directory /LDP/HOWTO/xxxxx-HOWTO.html
</itemize>


<itemize>
<item>
You can get this HOWTO document as a single file tar ball in HTML, DVI, 
Postscript or SGML formats from -
<url url="ftp://www.linuxdoc.org/pub/Linux/docs/HOWTO/other-formats/">
and <url url="http://www.linuxdoc.org/docs.html#howto">
<p>
<item>Plain text format is in: <url url="ftp://www.linuxdoc.org/pub/Linux/docs/HOWTO">
and <url url="http://www.linuxdoc.org/docs.html#howto">
<p>
<item>Single HTML file format is in: 
<url url="http://www.linuxdoc.org/docs.html#howto">
<p> Single HTML file can be created with command (see man sgml2html) - 
sgml2html -split 0   xxxxhowto.sgml
<p>
<item>Translations to other languages like French, German, Spanish, 
Chinese, Japanese are in
<url url="ftp://www.linuxdoc.org/pub/Linux/docs/HOWTO">
and <url url="http://www.linuxdoc.org/docs.html#howto">
Any help from you to translate to other languages is welcome.
</itemize>
The document is written using a tool called "SGML-Tools" which can be got from - 
<url url="http://www.sgmltools.org">
Compiling the source you will get the following commands like
<itemize>
<item>sgml2html xxxxhowto.sgml     (to generate html file)
<item>sgml2html -split 0   xxxxhowto.sgml (to generate a single page html file)
<item>sgml2rtf  xxxxhowto.sgml     (to generate RTF file)
<item>sgml2latex xxxxhowto.sgml    (to generate latex file)
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Acrobat PDF format <label id="acrobatpdf">
<p>
PDF file can be generated from postscript file using 
either acrobat <bf>distill</bf> or <bf>Ghostscript</bf>.
And postscript file is generated
from DVI which in turn is generated from LaTex file.
You can download distill software from <url url="http://www.adobe.com">. Given below 
is a sample session:
<code>
bash$ man sgml2latex
bash$ sgml2latex filename.sgml
bash$ man dvips
bash$ dvips -o filename.ps filename.dvi
bash$ distill filename.ps
bash$ man ghostscript
bash$ man ps2pdf
bash$ ps2pdf input.ps output.pdf
bash$ acroread output.pdf &
</code>
Or you can use Ghostscript command <bf>ps2pdf</bf>.
ps2pdf is a work-alike for nearly all the functionality of 
Adobe's Acrobat Distiller product: it
converts PostScript files to Portable Document Format (PDF) files. 
<bf>ps2pdf</bf> is implemented as a very small command script 
(batch file) that invokes Ghostscript, selecting a special "output device"
called <bf>pdfwrite</bf>. In order to use ps2pdf, the pdfwrite 
device must be included in the makefile when Ghostscript was compiled;
see the documentation on building Ghostscript for details.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Convert Linuxdoc to Docbook format <label id="linuxdoc2docbook">
<p>
This document is written in linuxdoc SGML format. The Docbook SGML format
supercedes the linuxdoc format and has lot more features than linuxdoc.
The linuxdoc is very simple and is easy to use. To convert linuxdoc SGML 
file to Docbook SGML use the program <bf>ld2db.sh</bf> and some perl scripts.
The ld2db output is not 100% clean and you need to use the <bf>clean_ld2db.pl</bf>
perl script. You may need to manually correct few lines in the document.
<itemize>
<item> Download ld2db program from <url url="http://www.dcs.gla.ac.uk/~rrt/docbook.html">
or from <url name="Al Dev site" url="http://www.aldev.8m.com/cppsrc.html">
<item> Download the cleanup_ld2db.pl perl script from
from <url name="Al Dev site" url="http://www.aldev.8m.com/cppsrc.html">
</itemize>
The ld2db.sh is not 100% clean, you will get lots of errors when you run
<code>
	bash$ ld2db.sh file-linuxdoc.sgml db.sgml
	bash$ cleanup.pl db.sgml > db_clean.sgml
	bash$ gvim db_clean.sgml 
	bash$ docbook2html db.sgml
</code>
And you may have to manually edit some of the minor errors after 
running the perl script. For e.g. you may need to put closing tag <
/Para> for each <
Listitem>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Convert to MS WinHelp format <label id="mswinhelp">
<p>
You can convert the SGML howto document to Microsoft Windows Help file, 
first convert the sgml to html using:
<code>
	bash$ sgml2html xxxxhowto.sgml     (to generate html file)
	bash$ sgml2html -split 0   xxxxhowto.sgml (to generate a single page html file)
</code>
Then use the tool <url name="HtmlToHlp" url="http://javadocs.planetmirror.com/htmltohlpe.html">.
You can also use sgml2rtf and then use the RTF files for generating winhelp files.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Reading various formats <label id="readformats">
<p>
In order to view the document in dvi format, use the xdvi program. The xdvi
program is located in tetex-xdvi*.rpm package in Redhat Linux which can be
located through ControlPanel | Applications | Publishing | TeX menu buttons.
	To read dvi document give the command -
<tscreen><verb>
	xdvi -geometry 80x90 howto.dvi
	man xdvi
</verb></tscreen>
	And resize the window with mouse.
	To navigate use Arrow keys, Page Up, Page Down keys, also
	you can use 'f', 'd', 'u', 'c', 'l', 'r', 'p', 'n' letter
	keys to move up, down, center, next page, previous page etc.
	To turn off expert menu press 'x'.

You can read postscript file using the program 'gv' (ghostview) or 
'ghostscript'.
The ghostscript program is in ghostscript*.rpm package and gv 
program is in gv*.rpm package in Redhat Linux
which can be located through ControlPanel | Applications | Graphics menu 
buttons. The gv program is much more user friendly than ghostscript.
Also ghostscript and gv are available on other platforms like OS/2,
Windows 95 and NT, you view this document even on those platforms.
 
<itemize>
<item>Get ghostscript for Windows 95, OS/2, and for 
all OSes from <url url="http://www.cs.wisc.edu/~ghost">
</itemize>

To read postscript document give the command -
<tscreen><verb>
		gv howto.ps
		ghostscript howto.ps
</verb></tscreen>

You can read HTML format document using Netscape Navigator, Microsoft Internet
explorer, Redhat Baron Web browser or any of the 10 other web browsers.

You can read the latex, LyX output using LyX a X-Windows front end to latex.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt change> Copyright Notice
-->
<sect> Copyright Notice
<p>
Copyright policy is GNU/GPL as per LDP (Linux Documentation project).
LDP is a GNU/GPL project.
Additional restrictions are - you must retain the author's name, email address
and this copyright notice on all the copies. If you make any changes 
or additions to this document than you should 
intimate all the authors of this document.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
</article>
