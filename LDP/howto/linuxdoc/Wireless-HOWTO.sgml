<!doctype linuxdoc system>

<!-- LyX 1.1 created this file. For more info see http://www.lyx.org/ -->
<article>
<title>
Wireless Howto
</title>
<author>
Roberto Arcomano berto@fatamorgana.com
</author>
<date>
v1.4, 17 Dicembre 2001
</date>
<abstract>
Wireless HOWTO per Systemi Linux Roberto Arcomano, berto@fatamorgana.com.
 
</abstract>
<abstract>
Wireless è una nuova tecnologia nelle schede di rete ad alta velocità (fino
 a 11 Mbps). Questo documento illustra come configurare Wireless in Linux, problemi
 di compatibilità, requisiti sulla visibilità tra le antenne e altro ancora.
 L'ultima versione di questo documento puo' essere trovata su <url url="http://www.fatamorgana.com/bertolinux" name="http://www.fatamorgana.com/bertolinux">
</abstract>
<toc>
<sect>
Introduzione 
<sect1>
Introduzione 
<p>
Questo documento illustra le reti Wireless, loro configurazione e relative
 problematiche. Diversamente da come accade per le reti classiche, le reti Wireless
 richiedono particolari accorgimenti per funzionare. E' necessario avere un
 minimo di esperienza sulle antenne, sul loro puntamento e così via. Ogni critica
 (costruttiva) è la benvenuta. Un'ottima fonte é anche questa: <htmlurl url="http://www.hpl.hp.com/personal/Jean_Tourrilhes/Linux" name="Jean Tourrilhes Wireless Howto">
</p>
<p>
Per qualunque suggerimento o critica scrivetemi su questo<url url="mailto:berto@fatamorgana.com" name="indirizzo email">
</p>
<sect1>
Copyright 
<p>
Copyright (C) 2000,2001 Roberto Arcomano.
</p>
<p>
This document is free; you can redistribute it and/or modify it under the
 terms of the GNU General Public License as published by the Free Software Foundation;
 either version 2 of the License, or (at your option) any later version. 
</p>
<p>
This document is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 You can get a copy of the GNU GPL <url url="http://www.gnu.org/copyleft/gpl.html" name="here">
</p>
<sect1>
Traduzioni
<p>
Sei libero di tradurre questo documento, devi soltanto rispettare 2 regole:
 
</p>
<p>
<enum>
 <item>
Controllare che non esista gia' un'altra versione del documento nel tuo
 LDP locale
 <item>
Mantenere la sezione 'Introduzione' (che include i paragrafi 'Introduzione',
 'Copyright', 'Traduzioni', 'Ringraziamenti').
</enum>
</p><p>
Grazie per la traduzione.
</p>
<sect1>
Ringraziamenti
<p>
Ringraziamenti a <url url="http://www.fatamorgana.com" name="Fatamorgana Computers"> per l'equipaggiamento hardware e per la sperimentazione.
</p>
<p>
Grazie anche al <url url="http://www.pluto.linux.it" name="Progetto Pluto"> per la pubblicazione.
</p>
<sect>
Conoscenze di base
<sect1>
Cos'é il Wireless?
<p>
Il Wireless é una nuova tecnologia che può aiutare nella comunicazione
 tra computers distanti. Si basa su schede Wireless con un TX/RX che opera sui
 2.4 GHz, mentre l'interfaccia dal lato software é di tipo Ethernet, con un
 indirizzo fisico diverso per ogni scheda nel mondo. Potenze di trasmissione
 tipiche sono 10-20 mW fino a 100mW (vedi standard IEEE 802.11 e FCC/CEPT licenze).
</p>
<sect1>
Qual'é la massima distanza tra le schede radio? 
<p>
Il requisito più importante, nelle comunicazioni Wireless, é la visibilità
 senza ostacoli delle antenne: e' necessario "vedere" l'altra antenna (a occhio
 nudo o con un binocolo) o al massimo é concesso un piccolo albero come ostacolo.
 
</p>
<p>
La distanza dipende dall'antenna (eventualmente amplificata): 2-300 metri
 con una omnidirezionale; 1 km con direttiva; 2-3 km con omnidirezionale amplificata
 (200mW); alcuni km con parabola. 50-60 km con parabola o direttiva ampificata
 (alcuni Watts). 
</p>
<p>
Attenzione che non é sempre legale amplificare schede Wireless, in quanto
 potresti violare le specifiche dell' FCC (America) o del CEPT (Europa) o quelle
 del proprio stato.
</p>
<sect1>
Qual'e' la differenza tra schede classiche e schede Wireless? 
<p>
Le schede classiche sono molto semplici da configurare (almeno a livello
 fisico). La configurazione delle reti Wireless risulta invece molto complessa
 come anche la loro gestione e relativo debugging... I tipici problemi di installazione
 hardware, software, debug e cosi' via diventano critici in ambiente Wireless:
 
</p>
<p>
<enum>
 <item>
Devi scegliere la giusta scheda Wireless: ce ne sono si svariati tipi,
 di svariati rivenditori e con diversi requisiti. Se vuoi creare una piccola
 rete LAN/WAN devi comprare schede Wireless compatibili IEEE 802.11 con un Access
 Point. 
 <item>
Molte schede hanno un plug PCMCIA, quindi necessitano, come prima cosa,
 l'installazione dei sorgenti pcmcia per Linux. 
 <item>
E' necessario testare le schede con 2 sistemi funzionanti e opportunamente
 configurati, all'inizio vicini, poi via via sempre piu' lontani. 
 <item>
Dovresti testare la configurazione in ogni condizione climatica (tipicamente
 pioggia). 
 <item>
Se tutto funziona puoi essere soddisfatto e rilassarti!
</enum>
</p><p>
Se installi un ripetitore (macchina Linux con diverse schede Wireless e
 Wired) potresti avere dei problemi editando la sua configurazione a distanza.
</p>
<sect1>
Cosa devo sapere per configurare una rete Wireless?
<p>
Ci sono un certo numero di requisiti da soddisfare.
</p>
<p>
<verb>
requisiti software: 
</verb>
<p>
<enum>
 <item>
Conoscenze generice di reti classiche: indirizzi IP, netmask, routing...
 tutto descritto dal generico NET3-4-HOWTO;  
 <item>
Conoscenze specifiche di reti classiche: proxy arp, bridging, file system
 proc, descritte nei documenti Proxy-ARP-Subnet, Bridge Mini-Howto e nei sorgenti
 di Linux (2.2.x or 2.4.x) sotto Documentation/networking/ ip-sysctl.txt)
 <item>
Conoscenze di base delle reti Wireless: concetti di modalita' di accesso
 (ADHOC, INFRASTRUCTURE and ACCESS POINT), di canale, terminologia outdoor and
 indoor e cosi' via: puoi trovare tutto cio' in ogni documento che tratta di
 Wireless: IEEE standard 802.11, CEPT, ecc.
</enum>
<p>
<verb>
requistiti non software: 
</verb>
<p>
<enum>
 <item>
Esperienza minima di antenne, loro montaggio e puntamento
 <item>
Esperienza in installazione di schede su Pc con particolare attenzione
 nell'evitare le interferenze elettromagnetiche tra 2 differenti schede Wireless
 (nel caso sia richiesta l'installazione di più schede). 
</enum>
</p><p>
Infine una grande fortuna!
</p>
<sect1>
Perché mettermi a configurare una rete Wireless e che cosa mi aspetto?
<p>
Perché? Perché non sei soddisfatto delle reti classiche! 
</p>
<p>
Con le schede Wireless puoi attraversare giardini, parchi, case (l'importante
 é poter "vedere" l'altra estremità)
</p>
<p>
I protocolli di alto livello sono gli stessi delle schede classiche: TCP/IP
 over Wireless Ethernet-like ma fai molta attenzione alla condivisione risorse
 di Windows, perché se usi Linux per instradare i pacchetti, non potrai vedere
 gli altri computer su "Risorse di Rete", in quanto un router (ip forwarder) non
 fa passare i pacchetti di broacast (vedi protocollo NetBIOS): in tal caso potresti
 servirti di un server WINS (vedi documentazione di Samba). 
</p>
<p>
Il sistema Wireless ti permette di creare una piccola LAN/WAN con un punto
 di accesso (magari con accesso ad Internet) e dando connettività a chiunque
 via etere! 
</p>
<p>
Immagina un paese tutto cablato via radio.
</p>
<p>
Immagina una rete che può interconnettere tutte gli abitanti di un paese,
 far loro condividere files, suoni, video ad altissima velocità (comparabile
 con quella delle reti classiche fino a 11Mbps).
</p>
<p>
Tutto ciò può essere fatto (ed è già una realtà in alcune città) usando
 schede Wireless con relativi AccessPoint e macchine Linux che fungono da ripetitori
 allorché la distanza sia troppo elevata per essere coperta con un solo collegamento
 (a livello IP come ad esempio un router oppure, se vuoi, a livello data-link,
 con il supporto bridging per Linux , vedi <htmlurl url="http://openrock.net/bridge" name="http link"> o <htmlurl url="ftp://openrock.net/bridge" name="ftp link">)
</p>
<sect1>
Quali schede Wireless vediamo in questo Howto? 
<p>
In questo Howto iniziamo con una configurazione generica (per introdurre
 le reti Wireless), in seguito descrivo un esempio per ogni scheda di cui ho
 esperienza diretta, con piccoli trucchi per migliorare le performance ed evitare
 conflitti.
</p>
<p>
<verb>
Lista schede Wireless: 
</verb>
<p>
<enum>
 <item>
Proxim Symphony -<htmlurl url="http://www.proxim.com" name="http://www.proxim.com">
 <item>
Webgear AviatorPRO 2.4 (supporto pcmcia richiesto) - <htmlurl url="http://www.webgear.com" name="http://www.webgear.com">
 <item>
Lucent Wavelan I, II, Orinoco - <htmlurl url="http://www.lucent.com" name="http://www.lucent.com"> and <url url="http://www.orinocowireless.com" name="http://www.orinocowireless.com">
 <item>
Cabletron - <htmlurl url="http://www.cabletron.com" name="http://www.cabletron.com">
 <item>
YDI am930_isa - <htmlurl url="http://www.ydi.com" name="http://www.ydi.com">
 <item>
Siemens Radio Modem (Dect) - <htmlurl url="http://www.siemens.com" name="http://www.siemens.com">
</enum>
</p><p>
Per una lista più completa vedi <htmlurl url="http://www.hpl.hp.com/personal/Jean_Tourrilhes/Linux" name="Jean Tourrilhes Wireless Howto">. 
</p>
<p>
I Siemens Radio Modem non sono propriamente delle schede Wireless IEEE
 802.11, ma sono dei modems da collegare sulla seriale (frequenza operativa
 1800 MHz, tecnologia DECT). Vedi Appendice B. 
</p>
<sect1>
Quanto costano?
<p>
Le suddette schede hanno un costo relativamente basso: partono da poche
 centinaia di migliaia di lire fino ad arrivare ad alcuni milioni per gli Access
 Point predisposti per schede 2 Wireless (Lucent, ad esempio) funzionanti come
 bridge. 
</p>
<sect>
Informazioni tecniche sul Wireless 
<p>
Qui di seguito riporto alcune informazioni di base necessarie per comprendere
 la tecnologia Wireless
</p>
<sect1>
Livello fisico
<p>
A livello fisico ISO/OSI possiamo avere 3 tipi di specifiche:
</p>
<p>
<enum>
 <item>
FHSS, Frequency Hopping Spread Spectrum 
 <item>
DSSS, Direct Sequence Spread Spectrum 
 <item>
Infrarossi, che qui non vediamo. Vedi relativo Howto Linux-IR-HOWTO
</enum>
</p><sect1>
Configurazioni
<p>
2 tipi di configurazioni: 
</p>
<p>
<enum>
 <item>
AdHoc mode (anche noto come Independent mode), dove si hanno reti indipendenti
 ognuna con un BSS (Basic Service Set) . Ogni stazione della rete utilizza lo
 stesso BSS. 
 <item>
Infrastructure mode, dove un certo numero di reti (ognuna con un proprio
 BSS) può comunicare con le altre tramite il proprio Access Point (uno per ogni
 BSS) per creare un ESS (Extended Service Set). Vi sono anche delle funzionalità
 di roaming che permettono ad una stazione di scegliere l'Access Point più vicino
 cui allacciarsi.
</enum>
</p><p>
Adhoc mode é il metodo più semplice (ed anche il meno scalabile!) e permette
 a diversi hosts di comunicare direttamente uno con l'altro. Il requisito (un
 po' restrittivo) é che ogni macchina debba vedere tutte le altre perché le
 cose funzionino (questo in teoria, perché in pratica questo problema può essere
 risolto a livello IP! Vedi Par 5.4).
</p>
<p>
<verb>
                                 Adhoc mode 

                               A - - - - - C
                                 &bsol;       /
                               |   &bsol;   /   |
                                     /&bsol;
                               |   /    &bsol;  |
                                 /       &bsol;
                               B - - - - - D
</verb>
</p><p>
In Infrastructure mode vengono utilizzati gli Access Point attraverso cui
 tutte le stazioni devono connettersi per comunicare con gli altri. 
</p>
<p>
<verb>
Infrastructure mode 
                                    ESS
 
          A - - - | - Access Point - -  Access Point - | - - - D
 
          B - - - |   BSS1                   BSS2      | - - - E
 
          C - - - |                                    | - - - F
</verb>
</p><p>
A, B e C non possono vedere D,E and F, direttamente, ma possono comunicare
 con loro usando lo stesso ESS. Nota: A,B and C potrebbero anche non vedersi
 tra di loro, ma grazie all'Access Point comunicano lo stesso. 
</p>
<p>
Vengono inoltre utilizzati temini come indoor e outdoor per distinguere
 le reti a corto raggio da quelle a lungo raggio o più propriamente per interni
 e per esterni.
</p>
<sect1>
Compatibilità
<p>
Bisogna tenere conto che esistono un gran numero di schede Wireless nel
 mondo e non tutte possono comunicare tra di loro. 
</p>
<p>
Per dialogare e' necessario che utilizzino:
</p>
<p>
<enum>
 <item>
la stessa modalità di accesso: Adhoc o Infrastructure 
 <item>
lo stesso livello fisico: DSSS o FHSS 
 <item>
lo stesso protocollo (ad esempio Proxim utilizza il suo protocollo proprietario
 OpenAir e, benché il livello fisico sia FHSS, non può comunicare con le altre
 schede di tipo FHSS). 
</enum>
</p><sect1>
Devo usare Adhoc o Infrastructure? 
<p>
E' noto che gli Access Point sono molto utili e evitano molte problematiche,
 ma hanno lo svantaggio di costare non poco. In teoria, per una rete molto concentrata
 conviene usare Infrastructure mode, mentre per pochi si può tranquillamente
 optare per Adhoc: in effetti perché spendere soldi inutilmente per poche macchine?
 
</p>
<p>
Vale comunque sempre la regola: mangi come spendi!
</p>
<sect1>
Una macchina Linux può fungere da AccessPoint? 
<p>
Ottima domanda! Sfortunatamente non sono a conoscenza di nessun driver
 che permetta questa funzionalità, per nessuna scheda, quindi dobbiamo arrangiarci
 con l'Adhoc mode oppure comprare AccessPoint.
</p>
<p>
Nota: se sei un esperto nel reverse engineering puoi scaricare il firmware
 dell'Access Point, usare un processore compatibile, estrapolare i comandi da
 dare alla scheda e riscriverti un driver Access Point per Linux. Buona fortuna!
</p>
<sect>
Gli strumenti
<sect1>
Hardware 
<p>
Hai bisogno di un Linux Box (486 o, meglio, un Pentium 100+ con 16MB+ ram),
 della scheda Wireless, di un antenna per i 2.4GHz (vedi Par 2.2). Ovviamente
 hai bisogno di tutto ciò anche nell'altra estremità (con Win9x o WinNT se preferisci...)
 in quanto dobbiamo simulare una comunicazione.
</p>
<sect1>
Software
<p>
Hai bisogno di: 
</p>
<p>
<enum>
 <item>
Sorgenti recenti del kernel di Linux (2.2.x). Vedi dopo
 <item>
Sorgenti recenti del pacchetto pcmcia (pcmcia-cs), nel caso tu abbia comprato
 una scheda pcmcia. Vedi dopo
 <item>
Driver della scheda Wireless: se non ce l'hai puoi scaricarlo dal sito
 dove hai preso la scheda o dal sito del costruttore. Se proprio non lo trovi
 puoi provare a cercare all'indirizzo <htmlurl url="http://www.hpl.hp.com/personal/Jean_Tourrilhes/Linux" name="Jean Tourrilhes Wireless Howto">. 
</enum>
</p><p>
Se non lo trovi neache qui devi convertire un driver di Windows per farlo
 girare sotto Linux!! (buona fortuna!)
</p>
<p>
Dopodiché devi ricompilare il kernel, ricompilare i sorgenti pcmcia (se
 richiesto) e finalmente compilare il driver Wireless. Tieni conto che questa
 é un situazione del tutto generale, in molti casi ti basterà seguire il passo
 3 oppure i passi 1 e 3, dipende dal driver che hai. 
</p>
<sect>
Generalità sulla configurazione di una rete Wireless.
<sect1>
Passi fondamentali
<p>
Una volta che hai recuperato il materiale e hai ricompilato tutto il necessario
 sei pronto per seguire i 3 passi per la configurazione di una rete Wireless.
</p>
<p>
<enum>
 <item>
Configurazione di basso livello: é necessario far riconoscere al kernel
 la nostra scheda Wireless (cose del tipo ioport, interrupts, dma...): devi
 cercare un qualche tipo di messaggio, sui file di log, che ti confermi l'avvenuto
 riconoscimento e la relativa configurazione. 
 <item>
Configurazione a livello Data-link: per ogni particolare scheda Wireless
 esiste un'utility in grado di settare i tipici valori Wireless data-link. Ad
 esempio Proxim Symphony utilizza &quot;rl2cfg&quot; mentre nelle schede pcmcia
 i settaggi sono presenti nei files di configurazione del supporto pcmcia. Devi
 settare tutte le tue schede Wireless in modo coerente, altrimenti non potranno
 dialogare. 
 <item>
Settaggi IP. A questo dovresti essere in grado di utilizzare i comandi
 ifconfig e route per cambiare i settaggi IP. 
 <item>
Trucchetti per migliorare le performance ed evitare conflitti. Adesso la
 tua rete fondamentalmente funziona: puoi aggiustare alcuni settaggi riguardanti
 proxy arp, icmp echo redirect, bridging, cambio dei canali e così via per ottimizzare
 la configurazione ed evitare conflitti uccidi-banda! 
</enum>
</p><p>
N.B.: passi 1, 2 e 3 corrispondono ai livelli 1, 2 and 3 dello standard
 ISO/OSI, mentre il passo 4 é un addendum per risolvere alcune problematiche,
 tra cui quelle generate dall'adozione della maschera 255.255.255.255. Infatti
 la maschera 32 bit viola lo standard TCP/IP forzando una rete ad usare lo stesso
 indirizzo per il broadcast e per l'host, mentre l'indirizzo di rete non esiste.
</p>
<p>
Qualcuno potrebbe criticare questo punto di vista, ma se seguissimo alla
 lettera lo standard inizieremmo a perdere una marea di indirizzi IP (sempre
 più preziosi); per ogni sottorete 2 indirizzi sono riservati (network and broadcast)
 e comunque, seguendo lo standard, non si avrebbe certamente la necessaria flessibilità
 sull'assegnazione di indirizzi IP alle interfacce richiesta dai sistemi Wireless
 (allocazione di tipo geografica!). Per maggiori informazioni vedi Appendix
 A.
</p>
<p>
Si può infine notare come il passo 2 non sia presente nelle schede Wired,
 in quanto non vi sono particolari settaggi da operare.
</p>
<sect1>
Configurazione di basso livello 
<p>
E' il classico problema dell'amministratore del sistema: far riconoscere
 al PC il proprio hardware.
</p>
<p>
Le schede Wireless sono più complesse sotto questo punto di vista, perché
 molte hanno il plug Pcmcia e quindi prima di tutto é necessario "far vedere"
 al kernel il proprio adattare Pcmcia, in seguito sarà possibile provare ad
 installare il driver specifico per la scheda Wireless Pcmcia.
</p>
<p>
<verb>
Quindi nelle configurazioni Pcmcia é necessario: 
</verb>
<p>
<enum>
 <item>
installare i sorgenti del kernel, scaricandoli da <htmlurl url="http://www.kernel.org" name="http://www.kernel.org"> e scompattandoli su
 /usr/src/linux (vedi comandi tar and gzip) 
 <item>
installare i sorgenti per il supporto pcmcia, da <htmlurl url="ftp://projects.sourceforge.net/pub/pcmcia-cs" name="ftp://projects.sourceforge.net/pub/pcmcia-cs"> e scompattarli su /usr/src/pcmcia
 (vedi sempre utilities tar and gzip)
 <item>
configurare e ricompilare il kernel: leggi attentamente il README presente
 nella directory del Kernel (/usr/src/linux)
 <item>
configurare e ricompilare i sorgenti pcmcia: sotto /usr/src/pcmcia usare
 configure eppoi make. Assicurati che ci sia il driver che ti interessa, altrimenti
 dovrai installarlo seguendo le relative istruzioni (di solito basta scompattare
 con "tar zxvf driver.tgz" il driver pcmcia direttamente sotto la directory pcmcia).
 Dopodiché digita &quot;make all&quot; per compilare. Alla fine digita &quot;make
 install&quot;. 
 <item>
Dopo aver installato correttamente i drivers pcmcia potrai trovare i relativi
 file di configurazione sotto la directory /etc/pcmcia .
</enum>
<p>
<verb>
mentre per la configurazione senza Pcmcia: 
</verb>
<p>
<enum>
 <item>
Se il driver della tua scheda non é presente (in effetti non lo é mai!)
 nel Kernel, dovrai scaricarlo, installarlo e ricompilarlo in una nuova directory.
 
</enum>
</p><p>
Una volta che conosci il nome del driver é il momento di caricarlo: nel
 caso di Pcmcia ci penserà il demone relativo (attivabile tramite /etc/rc.d/init.d/pcmcia
 start per le distribuzioni RedHat), mentre per le altre schede basterà dare
 &quot;modprobe module_name options&quot;. Tra le opzioni vi sono ioport, irq
 e i settaggi data-link relativi al driver Wireless (vedi Par 5.3). Ad ogni
 modo ci sono una serie di strumenti molto comodi per controllare il riconoscimento
 a basso livello del driver: 
</p>
<p>
<enum>
 <item>
&quot;tail /var/log/messages&quot; che mostra le ultime informazioni scritte
 sul log di sistema (syslog)
 <item>
&quot;dmesg&quot; for ulteriori info sul log
 <item>
/proc directory: files ioports, devices, irq e sottodirectories specifiche
 per il driver.
</enum>
</p><sect1>
Configurazione a livello Data-link
<p>
<verb>
Cosa significa?
</verb>
</p><p>
Le reti classiche hanno bisogno solo di essere fisicamente connesse le
 une con le altre e di avere i giusti settaggi TCP/IP. Al contrario le reti
 Wireless networks richiedono settaggi Data-link che indicanti:
</p>
<p>
<enum>
 <item>
A che tipo di rete Wireless appartengo? (Adhoc o Infrastructure) 
 <item>
Che canale devo usare?
 <item>
A che sottorete (BSSID) appartengo e qual'é il mio ESSID? 
 <item>
La mia comunicazione é protetta da qualche algoritmo crittografico? Qual'è
 la chiave? 
</enum>
</p><p>
Ci sono quindi una serie di settaggi da configurare, la ragione di ciò
 deriva dall'architettura Wireless: potrebbe esserci qualcuno, nel raggio di
 copertura Wireless, che potrebbe intercettare dei pacchetti e usare servizi
 relativi ad un altra rete wireless solamente puntanto la propria antenna nella
 giusta direzione e settando gli opportuni parametri TCP/IP.
</p>
<p>
Inoltre più reti Wireless (magari ognuna relativa ad un piano di un edificio)
 potrebbero interferire una con l'altra.
</p>
<p>
Ecco allora:
</p>
<p>
<enum>
 <item>
Opzioni a load-time module: &quot;modprobe ray_cs essid='LINUX'&quot; per
 esempio o
 <item>
Utilities a run-time driver: &quot;rl2cfg eth1 master&quot;. 
</enum>
</p><sect1>
Settaggi IP + trucchetti 
<p>
Questo é il terzo problema che dobbiamo affrontare. Qui i problemi arrivano
 quando ci si evolve verso una rete più grossa.
</p>
<p>
<verb>
Ricordati che la rete Wireless non ti stressa se non sei tu a stressarla! 
</verb>
</p><sect2>
Una configurazione semplice
<p>
<verb>
                      Tutti gli hosts si "vedono"
 
                               A - - - - - C
                                 &bsol;       /
                               |   &bsol;   /   |
                                     /&bsol;
                               |   /    &bsol;  |
                                 /       &bsol;
                               B - - - - - D

</verb>
</p><p>
Una configurazione come questa é molto semplice e non richiede particolari
 attenzioni (almeno a livello IP): hai soltanto bisogno di assegnare un indirizzo
 IP ad ogni host e una maschera generale coerente con tutte le altre macchine.
</p>
<sect2>
Una configurazione più complessa
<p>
<verb>

                       A non vede B direttamente
 
                                A &lt;- - - -
                              NO&bsol;        |
                            TALK&bsol;        C
                                &bsol;        |
                                B &lt;- - - -
 
</verb>
</p><p>
In questo caso A e B possono comunicare tra loro soltanto tramite C. 
</p>
<p>
Se la rete é in infrastructure mode e C é l'Access Point allora tutto ok.
 In Adhoc mode é invece designare un host per essere un &quot;master&quot; (so
 che il termine non é molto formale, ma l'importante é capirsi!), un host che
 sia cioé in grado di creare un BSS e a cui gli altri possano collegarsi specificando
 il relativo BSSID.
</p>
<p>
In questo caso la connettività globale viene raggiunta a livello IP: A
 e B usando la stessa interfaccia di C, quindi se provi anche solo a fare ping
 da A verso B riceverai una marea di pacchetti ICMP REDIRECT da C, con cui C
 t'informa che la destinazione é già sulla rete da cui proviene la richiesta.
 
</p>
<p>
Soluzione: digita &quot;echo 0 &gt; /proc/sys/net/ipv4/conf/ethx/send_redirects&quot;
 (dove ethx é l'interfaccia su C verso A e B) per annullare il problema. 
</p>
<p>
Un altro problema: che maschera assegnare ad A, B e C? Se si da una maschera
 ad A che includa B non funziona nulla, perché A non utilizzerà C come gateway
 ma farà la richiesta ARP con indirizzo MAC destinazione sconosciuto. 
</p>
<p>
Potresti dire: uso il proxy arp! Peccato che il proxy arp serva per rispondere
 al sorgente solamente nel caso in cui il destinatario appartenga ad una diversa
 interfaccia rispetto al sorgente e questo non é il caso.
</p>
<p>
Conviene quindi settare la più piccola maschera possibile (Win9x permette
 255.255.255.254, WinNT invece 255.255.255.248), e devi essere sicuro che A
 and B non appartengano alla stessa sottorete. 
</p>
<p>
<verb>
Esempi: 
</verb>
<p>
<enum>
 <item>
IP(A) = x.y.z.2/31, IP(B) = x.y.z.3/31. Così non va perché A chiede B nella
 sua sottorete (ARP request) e C non può rispondere perché, per lui, A e B appartengono
 alla stessa interfaccia (quindi niente proxy arp). 
 <item>
IP(A) = x.y.z.1/31, IP(B)= x.y.z.2/31. Adesso si, perché A chiede a C (A
 manda i suoi pacchetti a B usando l'indirizzo MAC di C) per arrivare a B. 
</enum>
</p><p>
In generale, con una maschera 255.255.255.254, il giochetto funziona tra
 2 IP che NON differiscono soltanto per l'ultimo bit.
</p>
<p>
Mi rendo conto che tutto ciò é una forzatura del TCP/IP, ma é l'unico metodo
 per ottenere un elevato livello di flessibilità.
</p>
<p>
Nota: Usando un Access Point (rete in Infrastructure mode) non esiste più
 il problema dei pacchetti ICMP REDIRECT perché il problema viene già risolto
 a livello data-link (praticamente tutti gli Access Point sono dei bridge...).
 Ma gli Access Points sono costosi (qualche milione o più) ed é più economico
 usare un P133, 32MB Ram per forwardare i pacchetti, anche con 2 o più schede
 di rete.
</p>
<sect2>
Accesso ad Internet
<p>
<verb>
                               A - - - - - C - - Internet
                                 &bsol;       /
                               |   &bsol;   /   |
                                     /&bsol;
                               |   /    &bsol;  |
                                 /       &bsol;
                               B - - - - - D
Ci sono una serie di possibilità: 
</verb>
<p>
<enum>
 <item>
C'é un unico indirizzo IP pubblico. Devi soltanto settare indirizzi IP
 privati (192.168.x.y per esempio) sulla rete Wireless e abilitare, su C, il
 forwarding e il masquering (NAT). A, B e D utilizzeranno C come default Gateway.
 <item>
Possiedi una maschera pubblica (classe) visibile da Internet e C é il tuo
 default GW verso Internet per la tua rete. Hai bisogno, come prima, di abilitare
 il forwarding su C e di settare default GW su A, B ed D facendolo puntare su
 C. 
 <item>
Possiedi una maschera pubblica (classe) visibile da Internet e C NON é
 il tuo default GW verso Internet, Hai 2 possibili soluzioni: modificare il
 tuo default GW facendolo puntare a C per la tua rete. Simmetricamente C punterà
 sul tuo default GW per andare su Internet. Altrimenti potresti abilitare il
 proxy arp su C (echo 1 &gt; /proc/sys/net/ipv4/conf/ethx/proxy_arp dove ethx
 é l'interfaccia verso il default GW)e settare default GW su C per puntare sul
 default GW per andare su Internet. Il Proxy arp é una forzatura TCP/IP ma lavora
 bene.
</enum>
</p><sect2>
Reti miste: Wired e Wireless 
<p>
<verb>
                                Internet         
                                       &bsol;      
                                        &bsol;        E
                                         &bsol;     /
                                          &bsol;  /       Wireless
                               A - - - - - C - - F
                                 &bsol;       /   &bsol;
                               |   &bsol;   /   |   &bsol;
                        Wired        /&bsol;          G
                               |   /    &bsol;  |
                                 /       &bsol;
                               B - - - - - D
 
</verb>
</p><p>
Adesso C unisce 2 reti: a destra Wireless e a sinistra Wired.
</p>
<p>
In aggiunta puoi avere l'accesso ad Internet ed in totale hai bisogno di
 3 schede di rete su C.
</p>
<p>
Che indirizzi devi assegnare alle macchine? 2 soluzioni possibili: 
</p>
<p>
<enum>
 <item>
Dividere la rete in 2 sottoreti: ad esempio 192.168.1.0/24 e 192.168.2.0/24.
 Questa soluzione é molto veloce ma non é assolutamente scalabile né flessibile
 (almeno in ambito Wireless), perché se utilizzi indirizzi Internet pubblici
 rischi di perderne una marea.
 <item>
Abilitare il proxy arp su C per tutte e 2 le interfacce. I parametri di
 rete sono, in questo caso, gli stessi (net address and netmask) per Wireless
 e Wired, ma con il proxy-arp abilitato é possbile scegliere quali indirizzi
 IP sono su Wired e quali su Wireless. 
</enum>
<p>
<verb>
Esaminiamo ora la soluzione 2
</verb>
</p><p>
Ad esempio considera di avere una sottorete pubblica su Internet del tipo
 x.y.z.0/24.
</p>
<p>
<verb>
Le interfacce sono:
</verb>
<p>
<enum>
 <item>
ifconfig eth0 x.y.z.C netmask 255.255.255.255 (Wired) 
 <item>
ifconfig eth1 x.y.z.C netmask 255.255.255.255 (Wireless) 
 <item>
ifconfig eth2 x.y.z.C netmask 255.255.255.255 (to Internet) 
</enum>
<p>
<verb>
Le routes statiche su eth2:
</verb>
<p>
<enum>
 <item>
route add IPGW dev eth2 
 <item>
route add default gw IPGW 
</enum>
</p><p>
Queste route servono per indirizzare tutto Internet verso il nostra Default
 GW: come puoi notare é necessario prima dire a Linux che il router é sull'interfaccia
 eth2, poi mandare la default route verso di esso.
</p>
<p>
<verb>
Routes statiche su eth0:
</verb>
<p>
<enum>
 <item>
route add x.y.z.A dev eth0 
 <item>
route add x.y.z.B dev eth0 
 <item>
route add x.y.z.D dev eth0 
</enum>
</p><p>
Hosts A,B e D sulla rete Wired
</p>
<p>
<verb>
Routes statiche su eth1:
</verb>
<p>
<enum>
 <item>
route add x.y.z.E dev eth1 
 <item>
route add x.y.z.F dev eth1 
 <item>
route add x.y.z.G dev eth1 
</enum>
</p><p>
Hosts E,F e G sulla rete Wireless.
</p>
<p>
Nota che la flessibilità é molto elevata, però devi settare manualmente
 ogni hosts (al limite puoi destinare un micro-classe su un'interfaccia).
</p>
<sect>
Setup 
<p>
Qui riporto alcuni esempi (spero utili!) per configurare le schede Wireless
 più diffuse.
</p>
<sect1>
Informazioni generali sul Setup
<p>
Le schede Wireless hanno un interfaccia molto simile alle schede Wired,
 quindi dovrei aggiungere, come al solito delle entries nel file /etc/conf.modules
 contenenti:
</p>
<p>
<enum>
 <item>
&quot;alias ethx module&quot;, dove ethx é l'intefaccia che vuoi attribuire
 alla scheda Wirelss e module é il nome del modulo del kernel.
 <item>
&quot;options module io=0xAAA irq=I ...&quot;, dove 0xAAA é l'indirizzo
 io di base da assegnare alla scheda, I é l'IRQ e così via per gli altri parametri.
</enum>
</p><p>
Dopo questo potrai direttamente usare i comandi ifconfig route per configurare
 i settaggi IP della tua scheda.
</p>
<sect1>
Proxim Symphony 
<p>
Tipo di rete: FHSS,solo Adhoc e con protocollo proprietario OpenAir. 
</p>
<p>
Web site:<htmlurl url="http://www.proxim.com" name="http://www.proxim.com"> dove devi scaricare la documentazione e il driver per Linux e
 Win9x. 
</p>
<p>
Una volta scaricato il driver:
</p>
<p>
<enum>
 <item>
usa tar per scompattare su una directory vuota
 <item>
usa make come aiuto
 <item>
usa make modules; make modules_install per installare il driver rlmod.o
 e la relativa utility rl2cfg.  
 <item>
Per lanciare il driver (after modified /etc/conf.modules: see Par.6.1.)
 basta usare il comando ifconfig 
</enum>
</p><p>
Utility rl2cfg (per l'aiuto digita man rl2cfg dopo il passo 3) ti permette
 di cambiare i settaggi data-link level: 
</p>
<p>
<enum>
 <item>
&quot;rl2cfg dev ethx sta&quot; per settare la scheda come station (Slave)
 
 <item>
&quot;rl2cfg dev ethx msta&quot; per settare la sceda come master station
 (Master) 
 <item>
&quot;rl2cfg dev ethx alt&quot; per settare la scheda in modo automatico
</enum>
</p><p>
Questo é tutto ciò di cui hai bisogno per settare la scheda.
</p>
<sect1>
Webgear Aviator 2.4 and AviatorPro 
<p>
Tipo di rete: FHSS, solo Adhoc per Aviator 2.4 e anche Infrastructure per
 AviatorPro.
</p>
<p>
Queste schede richiedono più lavoro perché devi compilare il supporto Pcmcia.
</p>
<p>
Web site: <htmlurl url="http://www.webgear.com" name="http://www.webgear.com">. 
</p>
<p>
Per configurare:
</p>
<p>
<enum>
 <item>
Scarica i sorgenti pcmcia e scompattali su /usr/src/pcmcia (vedi Par 5.2)
 
 <item>
Scarica il driver da <htmlurl url="http://www.webgear.com" name="http://www.webgear.com"> and digita &quot;tar zxvf driver.tgz&quot; sulla
 directory /usr/src/pcmcia.
 <item>
riconfigura il supporto pcmcia (vedi Par 5.2) 
 <item>
Seguendo le istruzioni del driver devi aggiungere in fondo al file /etc/pcmcia/config.opts
 questa entry: &quot;source ./ray_cs.opts&quot;.  
 <item>
Nota che nel file /etc/pcmcia/ray_cs.opts c'é una linea tipo: &quot;module
 &quot;ray_cs&quot; opts &quot;...&quot;. Devi modificare i settaggi a livello
 data-link presenti nel campo "opts" .
</enum>
<p>
<verb>
Argomenti: 
</verb>
<p>
<itemize>
 <item>
pc_debug=x , dove x é il livello di log.
 <item>
net_type=x, x=0 per AdHoc, x=1 per Infrastructure. 
 <item>
essid=x, x é l'ESSID
</itemize>
</p><p>
Finalmente, per verificare la configurazione (con pc_debug&gt;0), vedrai
 dei messaggi sulla console tipo questi: &quot;network started&quot; nel caso
 in cui stai creando una nuova rete Wireless network created e &quot;network
 joined&quot; se ti stai collegando ad una già esistente.
</p>
<p>
Puoi controllare il file /proc/ray_cs per aiutarti: il campo BSSID ti dice
 a quale sotto rete appartieni, se é nullo c'é qualcosa che non va!
</p>
<sect1>
Lucent Wavelan I, II, Orinoco products and Cabletron 
<p>
Tipo di rete: DSSS, Adhoc e Infrastructure. 
</p>
<p>
I prodotti Lucent sono molto professionali. 
</p>
<p>
Web site: <htmlurl url="http://www.lucent.com" name="http://www.lucent.com"> e <htmlurl url="http://www.orinoco.com" name="http://www.orinoco.com">. 
</p>
<p>
Il Setup é analogo a quello delle WebGear: i passi 1,2,3 sono simili.
</p>
<p>
Devi poi aggiungere al file /etc/pcmcia/config.opts l'entry: "module &quot;wavelan_cs&quot;
 opts &quot; ...&quot;" per i modelli Lucent Wavelan I e "module and &quot;wavelan2_cs&quot;
 opts &quot; ...&quot;" per i modelli Lucent Wavelan II e Orinoco. 
</p>
<p>
Sotto la voce opts dovreai specificare: 
</p>
<p>
<enum>
 <item>
port_type=x, dove x indica Adhoc(3) o Infrastructure(1) 
 <item>
channel=x, x=canale, opzione rilevanto solo in AdHoc mode. 
 <item>
transmit_rate=x, per impostare la velocità: attenzione a questo settaggio
 per la compatibiltà con le schede Cabletron. 
</enum>
</p><p>
Note: In teoria é possibile installare 2 schede Lucent su una macchina
 Linux, una in Adhoc mode e l'altra in Infrastructure mode. Il problema é che
 soltanto una funziona in quanto, durante il lancio dei servizi pcmcia, tutte
 e 2 le schedeverranno settate con gli stessi parametri data-link (quindi entrambe
 in Adhoc o in Infrastructure mode). Quello che si può fare é creare un modulo
 (o un programma user) che permetta di cambiare i settaggi data_link relativi
 all'access mode e al canale a run-time .
</p>
<p>
La funzione del parametro canale serve ad evitare interferenze con altre
 schede Wireless. 
</p>
<p>
I driver Lucent possono anche essere usati per le schede Cabletron<htmlurl url="http://www.cabletron.com" name="http://www.cabletron.com">
</p>
<sect1>
YDI 
<p>
Tipo di Rete: DSSS, Adhoc e Infrastructure. 
</p>
<p>
YDI vende schede molto professionali insieme a relative antenne, amplificatori
 e altro ancora.
</p>
<p>
Web site: <htmlurl url="http://www.ydi.com" name="http://www.ydi.com"> 
</p>
<p>
<verb>
Per installare: 
</verb>
<p>
<enum>
 <item>
usa tar per scompattare il driver in una directory vuota.
 <item>
digita make per compilare.
 <item>
usa make install per installare il driver am930_isa e la relativa utility
 wlanctl
</enum>
</p><p>
Una volta fatto puoi scegliere se digitare i comandi a mano con "wlanctl"
 o lanciare uno degli scripts "scripts/wlan" or "scripts/rc.wlan" per configurare
 automaticamente la tua scheda.
</p>
<p>
Nella configurazione a mano i principali settaggi sono:
</p>
<p>
<enum>
 <item>
&quot;wlanctl scan ...&quot; per cercare un BSS già presente.
 <item>
&quot;wlanctl netlist&quot; per mostrare i BSSs trovati con il comando
 &quot;wlanctl scan ...&quot;. 
 <item>
&quot;wlanctl bsscreate ... ssid&quot; per creare una buona rete con il
 parametro ssid.
 <item>
&quot;wlanctl bssjoin bssid&quot; per "raggiungere" la rete specificata dal
 relativo bssid.
 <item>
&quot;wlanctl authen&quot; e &quot;wlanctl assoc&quot; a scopo di autenticazione.
</enum>
</p><sect>
FAQ - Frequently asked questions 
<p>
D1: Qual'é la differenze tra il BSSID e l'ESSID e quando devo esare l'ESSID?
 
</p>
<p>
R1: Il BSSID é un numero da 48 bit usato per identificare l'area ristretta
 cui ci si trova corrispondente al BSS, dove tutti gli hosts dialogano direttamente
 tra di loro (eventualmente con un Access Point), mentre l'ESSID é una stringa
 a lunghezza variabile che permette a differenti reti BSS di dialogare fra loro
 impostando un identificativo comune noto come, appuntom ESSID. ESS stà per
 Extended Service Set (ESS). Esiste un solo Access Point per ogni BSS e tutti
 gli AccessPoint (relativi a sottoreti diverse) dialogeranno tra loro soltanto
 se avranno lo stesso ESSID. Quindi hai bisogno dell'ESSID se hai una rete già
 di un certo tipo, con almeno 2 Access Points.
</p>
<p>
D2: Quale Access Point devo comprare? 
</p>
<p>
R2: Quello che costa meno (a parità di prestazioni!): ciò che é importante
 é che l'AccessPoint e le schede che stai usando utilizzino protocolli compatibili:
 vedi Par 3.3 Compatibilità.
</p>
<p>
D3: A che serve il settaggio del canale? 
</p>
<p>
R3: Quando hai diversi BSS (e magari di diversi standard) potresti aver
 dei problemi di interferenza: cambiando il canale opportunamente sull'AccessPoint
 o sulla scheda (in caso di AdHoc mode) puoi attenuare tali disturbi.
</p>
<p>
D4: Perché non riesco ad impostare il canale su un host che funziona in
 Infrastructure mode? 
</p>
<p>
R4: Perché in Infrastructure mode il canale viene sempre deciso dall'Access
 Point. 
</p>
<sect>
Links
<sect1>
Software Free
<p>
<itemize>
 <item>
<url url="http://www.linux-wlan.org/" name="progetto Linux-wlan">
 <item>
<url url="http://www.hpl.hp.com/personal/Jean_Tourrilhes/Linux" name="Jean Tourrilhes Wireless Howto">
</itemize>
</p><sect1>
Links Commerciali
<p>
<itemize>
 <item>
<url url="http://www.fatamorgana.com" name="Fatamorgana Computers">
 <item>
<url url="http://www.lucent.com" name="sito web Lucent">
 <item>
<url url="http://www.ydi.com" name="sito web YDI">
 <item>
<url url="http://www.siemens.com" name="sito web Siemens">
</itemize>
</p><sect>
Appendix A - Netmask 255.255.255.255, proxy arp and bridging 
<p>
Qui vediamo alcuni vantaggi nell'utilizzare Linux per le reti Wireless.
 
</p>
<p>
Linux permette di specificare la netmask 255.255.255.255 per un'interfaccia:
 questo può aiutare in ambito Wireless perché permette, successivamente, di
 assegnare un indirizzo IP verso un'interfaccia piuttosto che un'altra. Ad esempio
 puoi specificare la macchina A sull'interfaccia eth0, la macchina B sull'interfaccia
 eth1 e così via.
</p>
<p>
Tutto ciò non ha particolary effetti collaterali.
</p>
<p>
Inoltre puoi utilizzare le funzionalità di proxy arp tramite il file "/proc/sys/net/ipv4/conf/ethx/proxy_arp"
 dove ethx é l'interfaccia desiderata.
</p>
<p>
Se per esempio esegui il comando &quot;echo 1 &gt; proxy_arp/proc/sys/net/ipv4/conf/ethx/proxy_arp&quot;
 abiliterai il proxy arp per l'interfaccia ethx, mentre con &quot;echo 0 &gt;
 proxy_arp/proc/sys/net/ipv4/conf/ethx/proxy_arp&quot; lo disabiliterai.
</p>
<p>
Cos'é il proxy_arp? In maniera sintetica possiamo dire che il proxy arp
 é una funzionalità che ti aiuta quandi vuoi che un router linux risponda ad
 una richiesta ARP (che "vede passare" su un'interfaccia) nel caso in il destinatario
 é su un'altra interfaccia del router linux.
</p>
<p>
Esempio:
</p>
<p>
<verb>
192.168.1.1 ---- 192.168.1.2 Linux router 192.168.2.2 ----192.168.2.1 

</verb>
</p><p>
Per far funzionare questa rete bisogna:
</p>
<p>
<verb>
Senza proxy-arp 
</verb>
<p>
<enum>
 <item>
Settare su 192.168.1.1 192.168.1.2 come gateway 
 <item>
Settare su 192.168.2.1 192.168.2.2 come gateway
 <item>
pingare da una estremità all'altra con successo.
</enum>
<p>
<verb>
Con proxy-arp 
</verb>
<p>
<enum>
 <item>
Su 192.168.1.1 settare 192.168.1.2 come gateway
 <item>
NON settare il gateway su 192.168.2.1 ma abilitare il proxy_arp sull'interfaccia
 verso destra
 <item>
pingare da una estremità all'altra con successo. 
</enum>
</p><p>
Il proxy arp permette al router linux di rispondere quando si vede arrivare
 un'ARP request dall'host 192.168.2.1: il router dice di "avere" lui stesso l'indirizzo
 di destinazione 192.168.1.1. Dopodiché quando 192.168.2.1 comincia a mandare
 i pacchetti ICMP (come qualunque altro pacchetto), il nostro router LInux sa
 che deve mandarli all'host 192.168.1.1.
</p>
<p>
Nelle reti Wireless il proxy arp può quindi aiutarti quando hai tanti router
 Linux e non vuoi perdere il tuoi tempo a settare per ogni host le routes statiche;
 permette cioé un certo grado di trasparenza.
</p>
<p>
Infine puoi sperimentare il bridging sotto Linux:
</p>
<p>
<enum>
 <item>
Installando un kernel recente
 <item>
scaricando le ottime utilities per il bridging da <htmlurl url="http://openrock.net/bridge" name="http link"> o <htmlurl url="ftp://openrock.net/bridge" name="ftp link"> 
</enum>
</p><p>
Bridging dovrebbe essere ancora più comodo del proxy arp.
</p>
<sect>
Appendix B - Siemens DECT Radio Modem 
<p>
Cosa sono? Questi 2 componenti non sono delle vere schede per PC ma sono
 semplicamente dei modems che si attaccano alla seriale come dei normali devices
 esterni.
</p>
<p>
<verb>
Host1-seriale - RadioModem1 - - - - - RadioModem2 - seriale-Host2 
</verb>
</p><p>
Come li connetto? 
</p>
<p>
Possiamo modellare i 2 radiomodems com un cavo Null Modem: 
</p>
<p>
<verb>
Host1-seriale - - CAVO NULL MODEM - - seriale-Host2 
</verb>
</p><p>
In questo modo ci sono 2 modi possibili per sfruttarne le potenzialità:
</p>
<p>
<enum>
 <item>
Linux con Windows, Linux utilizza un demone che ascolta le chiamate ppp,
 mentre Windows utilizza una connessione di Accesso Remoto per chiamare Linux.
 
 <item>
Linux con Linux, dove vengono simultaneamente lanciati 2 scripts che eseguono
 una connessione ppp. 
</enum>
</p><p>
Per la modalità 1 puoi usare questo script per Linux: 
</p>
<p>
&quot;/usr/sbin/pppd -detach lock idle 300 crtscts connect &quot;/usr/sbin/chat
 -v TIMEOUT 5 AT OK AT OK AT OK AT OK&quot; IPLINUX:IPWINDOWS /dev/ttySx 115200
 disconnect &quot;/usr/sbin/chat -v AT OK&quot; ms-dns IPDNS&quot; 
</p>
<p>
dove: 
</p>
<p>
<itemize>
 <item>
/dev/ttySx é la porta seriale, 
 <item>
IPDNS é l'indirizzo IP del tuo Server DNS, 
 <item>
IPLINUX é l'indirizzo IP di Linuxe IPWINDOWS quello di Windows.
</itemize>
</p><p>
Tale scripts é necessario per "far credere" a Windows che sulla seriale sia
 collegato un modem reale!!
</p>
<p>
Su Windows devi creare una connessione in Accesso Remoto con crtscts abilitato,
 velocità a 115200 e con uno stupido numero da chiamarel (richiesto da Accesso
 Remoto ma assolutamente non usato). 
</p>
<p>
Con 2 macchine Linux devi soltante lanciare, per ogni macchina uno script
 come questo:
</p>
<p>
&quot;/usr/sbin/pppd passive local crtscts IPLINUX1:IPLINUX2 /dev/ttySx
 115200 noauth persist&quot; 
</p>
<p>
dove dovrai invertire IPLINUX1 con IPLINUX2 sull'altra macchina.
</p>
<p>
Nota che puoi anche abilitare l'autenticazione, sia con la modalità Linux-Windows
 che con quella Linux-Linux.
</p>


</article>
