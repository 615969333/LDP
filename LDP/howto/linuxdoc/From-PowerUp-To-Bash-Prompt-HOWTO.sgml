<!doctype linuxdoc system>

<ARTICLE>


<TITLE>From Power Up To Bash Prompt
<AUTHOR>Greg O'Keefe, <tt>gcokeefe@postoffice.utas.edu.au</tt>
<DATE>v0.6, February 2000

<ABSTRACT>
This is a brief description of what happens in a Linux system, from the time
that you turn on the power, to the time that you log in and get a bash prompt.
It is organised by package to make it easier for people who want to build a
system from source code. Understanding this will be helpful when you need to
solve problems or configure your system.
</ABSTRACT>


<TOC>



<SECT>Introduction
<P>
I find it frustrating that many things happen inside my Linux machine that I do
not understand. If, like me, you want to really understand your system rather
than just knowing how to use it, this document should be a good place to start.
This kind of background knowledge is also needed if you want to be a top notch
Linux problem solver.

<P>
I assume that you have a working Linux box, and understand some basic things
about Unix and PC hardware. If not, an excellent place to start learning is
Eric S. Raymond's 
<URL
URL="http://mirror.aarnet.edu.au/linux/LDP/HOWTO/Unix-Internet-Fundamentals-HOWTO.html"
NAME ="The Unix and Internet Fundamentals HOWTO" >
It is short, very readable and covers all the basics.

<P>
The main thread in this document is how Linux starts itself up. 
But it also tries to be a more comprehensive learning resource.
I have included exercises in each section. If you actually do some of these,
you will learn much more than you could by just reading.
There are also links to source code downloads. The reason for this is that
I hope some readers will undertake the best Linux learning exercise that I
know of, which is building a system from source code, or ``rolling your own''.
Giambattista Vico, an Italian philosopher (1668-1744) said 
``verum ipsum factum'', understanding arises through making.
Thanks to Alex (see <REF ID="acknowledge">) for this quote.

<P>
Packages are presented in the order in which they appear in the system
startup process. This means that if you install the packages in this order
you can reboot after each installation, and see the system get a little closer
to giving you a bash prompt each time. There is a reassuring sense of
progress in this.

<P>
There are choices to make when putting together a Linux system. These are the
same choices that the likes of Red Hat and Debian must make when creating a
distribution. There are often several free packages available to do the same
job. What I describe here are the components that are part of the major Linux
distributions. I choose GNU software if it is available because it is better
documented, and causes less headaches. It would be possible to get a bash
prompt without installing everything I mention here. However I want to 
describe a base system that can be built on easily, without nasty kludges.
For example, one of the init scripts uses awk. (Don't worry if you don't
know what awk is) Rather than hack this out of the script, I just install awk.  

<P>
I recommend that you first read the main text of each section, skipping the
exercises and references. Then decide how deep an understanding you want to
develop, and how much effort you are prepared to put in. Then start at the 
beginning again, doing the exercises and additional reading as you go.



<SECT>Hardware

<P>
When you first turn on your computer it tests itself to make sure everything is
in working order. This is called the ``Power on self test''. Then a program
called the bootstrap loader, located in the ROM BIOS, looks for
a boot sector. A boot sector is the first sector of a disk and has a small 
program that can load an operating system. Boot sectors are marked with a magic 
number 0xAA55 = 43603 at byte 0x1FE = 500. This is how the hardware can tell
whether the sector is a boot sector or not. 

<P>
The bootstrap loader has a list of places to look for a boot sector. My old 
machine looks in the primary floppy drive, then the primary hard drive. 
More modern machines can also look for a boot sector on a CD-ROM.
If it finds a boot sector, it loads it into memory and passes control to the
program that loads the operating system.
On a typical Linux system, this program will be LILO's first stage
boot loader. There are many different ways of setting your system up to boot
though. See the <EM>LILO User's Guide</EM> for details. See section 
<REF ID="lilo-links" NAME="LILO"> for a URL.

<P>
Obviously there is a lot more to say about what PC hardware does. But this is
not the place to say it. See one of the many good books about PC hardware.

<SECT1>Configuration
<P>
The machine stores some information about itself in its CMOS. This
includes what disks and RAM are in the system. The machine's BIOS contains a
program to let you modify these settings. Check the messages on your screen as
the machine is turned on to see how to access it. On my machine, you press the
delete key before it begins loading its operating system.

<SECT1>Exercises
<LABEL ID="hardware-ex">
<P>
A good way to learn about PC hardware is to build a machine out of second hand
parts. Get at least a 386 so you can easily run Linux on it. It won't cost much.
Ask around, someone might give you some of the parts you need. 

<P>
Check out, download compile and make a boot disk for 
<URL URL="http://www.unios.org" NAME=Unios>.
This is just a bootable "Hello World!" program, consisting of just over 100 
lines of assembler code. It would be good to see it converted to a format
that the GNU assembler <TT>as</TT> can understand.

<P>
Check out the source code for LILO's boot loader.

<SECT1>More Information
<P>
<ITEMIZE>
<ITEM><EM>The Unix and Internet Fundamentals HOWTO</EM>, by Eric S. Raymond,
<URL URL="http://mirror.aarnet.edu.au/linux/LDP/HOWTO/Unix-Internet-Fundamentals-HOWTO.html">
especially section 3, <EM>What happens when you switch on a computer?</EM>

<ITEM>The first chapter of <EM>The LILO User's Guide</EM> gives an excellent
explanation of PC disk partitions and booting.
See <REF ID="lilo-links" NAME="LILO"> for a URL.

<ITEM><EM>The NEW Peter Norton Programmer's Guide to the IBM PC & PS/2</EM>, 
by Peter Norton and Richard Wilton, Microsoft Press 1988 
There is a newer Norton book, which looks good, but I can't afford it right now!

<ITEM>One of the many books available on upgrading PC's
</ITEMIZE>



<SECT>Lilo
<P>
When the computer loads a boot sector on a normal Linux system, what it loads is actually a part of lilo, called the ``first stage boot loader''. This is a tiny program who's only job in life is to load and run the ``second stage boot loader''.

<P>
The second stage loader gives you a prompt (if it was installed that way) and loads the operating system you choose. 

<P>
When your system is up and running, and you run <TT>lilo</TT>, what you are actually running is the ``map installer''. This reads the configuration file <TT>/etc/lilo.conf</TT> and writes the boot loaders, and information about the operating systems it can load, to the hard disk.

<P>
There are lots of different ways to set your system up to boot. What I have just explained is the most obvious and ``normal'' way, at least for a system who's main operating system is Linux. The Lilo Users' Guide explains several examples of ``boot concepts''. It is worth reading these, and trying some of them out. 

<SECT1>Configuration
<P>
The configuration file for lilo is <TT>/etc/lilo.conf</TT>. There is a manual
page for it: type <TT>man lilo.conf</TT> into a shell to see it. The main thing
in lilo.conf is one entry for each thing that lilo is set up to boot. For a
Linux entry, this includes where the kernel is, and what disk partition to
mount as the root filesystem. For other operating systems, the main piece of
information is which partition to boot from.

<SECT1>Exercises
<P>
<EM>DANGER:</EM> take care with these exercises. It is easy enough to get
something wrong and screw up your master boot record and make your system
unuseable. Make sure you have a working rescue disk, and know how to use it to
fix things up again. See below for a link to tomsrtbt, the rescue disk I use
and recommend. The best precaution is to use a machine that doesn't matter. 

<P>
Set up lilo on a floppy disk. It doesn't matter if there is nothing other than
a kernel on the floppy - you will get a ``kernel panic'' when the kernel is
ready to load init, but at least you will know that lilo is working. 

<P>
If you like you can press on and see how much of a system you can get going on
the floppy. This is probably the second best Linux learning activity around.
See the Bootdisk HOWTO (url below), and tomsrtbt (url below) for clues.

<P>
Get lilo to boot unios (see section <REF ID="hardware-ex" NAME="hardware
exercises"> for a URL). As an extra challenge, see if you can do this on a
floppy disk.

<P>
Make a boot-loop. Get lilo in the master boot record to boot lilo in one of the
primary partition boot sectors, and have that boot lilo in the master boot
record... Or perhaps use the master boot record and all four primary partitions
to make a five point loop. Fun!

<SECT1>More Information
<P>
<LABEL ID="lilo-links">
<ITEMIZE>
<ITEM>The lilo man page. 
<ITEM>Lilo <URL URL="ftp://lrcftp.epfl.ch/pub/linux/local/lilo/" 
	NAME="download">,
	Australian <URL URL="ftp://mirror.aarnet.edu.au/pub/linux/metalab/system/boot/lilo/"
	NAME="mirror">.
	These directories also contain the ``LILO User's Guide'' 
	<TT>lilo-u-21.ps.gz</TT> (or a later version).
	You may already have this document though. 
	Check <TT>/usr/doc/lilo</TT> or there abouts. 
	The postscript version is better than the plain text, 
	since it contains diagrams and tables.
<ITEM><URL URL="http://www.toms.net/rb" NAME="tomsrtbt"> the coolest single
	floppy linux. Makes a great rescue disk.
<ITEM><URL URL="http://mirror.aarnet.edu.au/linux/LDP/HOWTO/Bootdisk-HOWTO.html"
	 NAME="The Bootdisk HOWTO"> 
</ITEMIZE>



<SECT>The Linux Kernel
<P>

The kernel does quite a lot really. I think a fair way of summing it up is that it makes the hardware do what the programs want, fairly and efficiently.

<P>
The processor can only execute one instruction at a time, but Linux systems
appear to be running lots of things simultaneously. The kernel acheives this by
switching from task to task really quickly. It makes the best use of the processor
by keeping track of which processes are ready to go, and which ones are waiting
for something like a record from a hard disk file, or some keyboard input.
This kernel task is called scheduling.

<P>
If a program isn't doing anything, then it doesn't need to be in RAM. Even a
program that is doing something, might have parts that aren't doing anything.
The address space of each process is divided into pages. The Kernel keeps track of
which pages of which processes are being used the most. The pages that aren't
used so much can be moved out to the swap partition. When they are needed again,
another unused page can be paged out to make way for it. This is virtual memory
management. 

<P>
If you have ever compiled your own Kernel, you will have noticed that there are
many many options for specific devices. The kernel contains a lot of specific
code to talk to diverse kinds of hardware, and present it all in a nice uniform
way to the application programs.

<P>
The Kernel also manages the filesystem, interprocess communication, and a lot
of networking stuff.

<P>
Once the kernel is loaded, the first thing it does is look for an <TT>init</TT> program to run.

<SECT1>Configuration
<P>
Most of the configuration of the kernel is done when you build it, using
<TT>make menuconfig</TT>, or <TT>make xconfig</TT> in <TT>/usr/src/linux/</TT>
(or wherever your Linux kernel source is). You can reset the default video
mode, root filesystem, swap device and RAM disk size using <TT>rdev</TT>. These
parameters and more can also be passed to the kernel from lilo. You can give lilo
parameters to pass to the kernel either in lilo.conf, or at the lilo prompt.
For example if you wanted to use hda3 as your root file system instead of hda2,
you might type

<VERB>
	LILO: linux root=/dev/hda3
</VERB>

<P>
If you are building a system from source, you can make life a lot simpler by
creating a ``monolithic'' kernel. That is one with no modules. Then you don't
have to copy kernel modules to the target system.

<P>
NOTE: The <TT>System.map</TT> file is used by the kernel logger to determine
the module names generating messages. The program <TT>top</TT> also uses this
information. When you copy the kernel to the target system, copy
<TT>System.map</TT> too.

<SECT1>Exercises
<P>Think about this: <TT>/dev/hda3</TT> is a special type of file that
describes a hard disk partition. But it lives on a file system just like all
other files. The kernel wants to know which partition to mount as the root
filesystem - it doesn't have a file system yet. So how can it read /dev/hda3 to
find out which partition to mount? 

<P>
If you haven't already: build your own kernel. Read all the help information
for each option.

<P>
See how small a kernel you can make that still works. You can learn a lot by leaving the wrong things out! 

<P>
Read ``The Linux Kernel'' (URL below) and as you do, find the parts of the source code that it refers to. The book (as I write) refers to kernel version 2.0.33, which is pretty out of date. It might be easier to follow if you download this old version and read the source there.  Its amazing to find bits of C code called ``process'' and ``page''.

<P>
Hack! See if you can make it spit out some extra messages or something.


<SECT1>More Information
<LABEL ID="Kernel">
<P>
<ITEMIZE>
<ITEM><TT>/usr/src/linux/README</TT> and the contents of 
	<TT>/usr/src/linux/Documentation/</TT> 
	(These may be in some other place on your system)
<ITEM> <URL URL="http://mirror.aarnet.edu.au/linux/LDP/HOWTO/Kernel-HOWTO.html"
	 NAME="The Kernel HOWTO"> 
<ITEM>The help available when you configure a kernel using 
	<TT>make menuconfig</TT> or <TT>make xconfig</TT> 
<ITEM> <URL URL="http://mirror.aarnet.edu.au/linux/LDP/LDP/" 
	NAME="The Linux Kernel (and other LDP Guides)">
<ITEM> Kernel source download - Australian
	<URL URL="http://kernel.mirror.aarnet.edu.au/pub/linux/kernel/" 
	NAME="mirror"> 
<ITEM>The Linux Kernel 
	<URL URL="http://www.kernel.org" NAME="home page">
	<URL URL="ftp://ftp.kernel.org/pub/linux/kernel" NAME="download">
	Use one of the mirrors listed at <TT>kernel.org</TT>, because they
	are always overloaded.
</ITEMIZE>


<SECT>The GNU C Library
<P>
The next thing that happens as your computer starts up is that init is loaded
and run. However, init, like almost all programs, uses functions from libraries.  

<P>
You may have seen an example C program like this:

<P>
<VERB>
	main() {
        	printf("Hello World!\n");
	}
</VERB>

The program contains no definition of <TT>printf</TT>, so where does it come from?
It comes from the standard C libraries, on a GNU/Linux system, glibc.
If you compile it under Visual C++, then it comes from a Microsoft
implementation of the same standard functions. There are zillions of
these standard functions, for math, string, dates/times memory allocation
and so on. Everything in Unix (including Linux) is either written in C
or has to try hard to pretend it is, so everything uses these functions.

<P>	
If you look in <TT>/lib</TT> on your linux system you will see lots of files called
<TT>libsomething.so</TT> or <TT>libsomething.a</TT> etc. They are libraries of these functions.
Glibc is just the GNU implementation of these functions.

<P>
There are two ways programs can use these library functions. If you <EM>statically</EM>
link a program, these library functions are copied into the executable that gets
created. This is what the <TT>libsomething.a</TT> libraries are for. If you 
<EM>dynamically</EM> link a program (and this is the default), then when the program
is running and needs the library code, it is called from the <TT>libsomething.so</TT>
file.

<P>
The command <TT>ldd</TT> is your friend when you want to work out which
libraries are needed by a particular program.  For example, here are the
libraries that <TT>bash</TT> uses:

<P>
<VERB>
	[greg@Curry power2bash]$ ldd /bin/bash
        	libtermcap.so.2 => /lib/libtermcap.so.2 (0x40019000)
        	libc.so.6 => /lib/libc.so.6 (0x4001d000)
        	/lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</VERB>

<SECT1>Configuration
<P>
Some of the functions in the libraries depend on where you are. For example, in Australia we write dates as dd/mm/yy, but Americans write mm/dd/yy. There is a program that comes with the <TT>glibc</TT> distribution called <TT>localedef</TT> which enables you to set this up.

<SECT1>Exercises
<P>
Use <TT>ldd</TT> to find out what libraries your favourite applications use.

<P>
Use <TT>ldd</TT> to find out what libraries <TT>init</TT> uses.

<P>
Make a toy library, with just one or two functions in it. The program
<TT>ar</TT> is used to create them, the man page for <TT>ar</TT> might be a
good place to start investigating how this is done. Write, compile and link
a program that uses this library.


<SECT1>More Information
<P>
<ITEMIZE>
<ITEM>Australian GNU libc 
	<URL URL="http://mirror.aarnet.edu.au/pub/gnu/glibc"
	NAME="mirror">. You will also need the linuxthreads and libcrypt addons.
	If libcrypt is not there it is because of some US export laws. There
	will be a README or some such saying where you can get it from.
<ITEM>Australian GNU ncurses
	<URL URL="http://mirror.aarnet.edu.au/pub/gnu/ncurses"
	NAME="mirror">. Ncurses is a library that provides a lot of text screen 
	capabilities. It includes the terminfo database, which replaces the 
	termcap file. You can (and probably should) compile ncurses as a glibc
	addon.
	
</ITEMIZE>



<SECT>Init
<P>
I will only talk about the ``System V'' style of init that Linux systems mostly
use. There are alternatives. Infact, you can put any program you like in
<TT>/sbin/init</TT>, and the kernel will run it when it has finished loading.

<P>
It is inits job to get everthing running the way it should be. It checks that
the file systems are ok and mounts them. It starts up ``daemons'' to log system
messages, do networking, serve web pages, listen to your mouse and so on. It
also starts the getty processes that put the login prompts on your virtual
terminals. 

<P>
There is a whole complicated story about switching ``run-levels'', but I'm
going to mostly skip that, and just talk about system start up.

<P>
Init reads the file <TT>/etc/inittab</TT>, which tells it what to do.
Typically, the first thing it is told to do is to run an initialisation script.
The program that executes (or interprets) this script is <TT>bash</TT>,
the same program that gives you a command prompt. 
In Debian systems, the initialisation script is <TT>/etc/init.d/rcS</TT>, on Red Hat,
<TT>/etc/rc.d/rc.sysinit</TT>. This is where the filesystems get checked and
mounted, the clock set, swap space enabled, hostname gets set etc. 

<P>
Next, another script is called to take us into the default run-level. This just
means a set of subsystems to start up. There is a set of directories
<TT>/etc/rc.d/rc0.d</TT>, 
<TT>/etc/rc.d/rc1.d</TT>, ..., <TT>/etc/rc.d/rc6.d</TT> in Red Hat, or
<TT>/etc/rc0.d</TT>,
<TT>/etc/rc1.d</TT>, ..., <TT>/etc/rc6.d</TT> in Debian, which correspond to the
run-levels. If we are going into runlevel 3 on a Debian system, then the script
runs all the scripts in <TT>/etc/rc3.d</TT> that start with `S' (for start).
These scripts are really just links to scripts in another directory usually
called <TT>init.d</TT>. 

<P>
So our run-level script was called by init, and it is looking in a directory for scripts starting with `S'. It might find <TT>S10syslog</TT> first. The numbers tell the run-level script which order to run them in. So in this case <TT>S10syslog</TT> gets run first, since there were no scripts starting with S00 ... S09. But <TT>S10syslog</TT> is really a link to <TT>/etc/init.d/syslog</TT> which is a script to start and stop the system logger. Because the link starts with an `S', the run-level script knows to execute the <TT>syslog</TT> script with a ``start'' parameter. There are corresponding links starting with `K', which specify what to shut down and in what order when leaving the run-level.

<P>
To change what subsystems start up by default, you must set up these links in
the <TT>rcN.d</TT> directory, where N is the default runlevel set in your
<TT>inittab</TT>.

<P>
The last important thing that init does is to start some <TT>getty</TT>'s.
These are ``respawned'' which means that if they stop, <TT>init</TT> just
starts them again. Most distributions come with six virtual terminals. You may
want less than this to save memory, or more so you can leave things running and
quickly flick to them as you need them. You may also want to run a getty for a
text terminal or a dial in modem. In this case you will need to edit the
<TT>inittab</TT> file.


<SECT1>Configuration
<P>
<TT>/etc/inittab</TT> is the top level configuration file for init.

<P>
The <TT>rcN.d</TT> directories, where N = 0, 1, ..., 6 determine what
subsystems are started.

<P>
Somewhere in one of the scripts invoked by init, the <TT>mount -a</TT> command
will be issued. This means mount all the file systems that are supposed to be
mounted. The file <TT>/etc/fstab</TT> defines what is supposed to be mounted.
If you want to change what gets mounted where when your system starts up, this 
is the file you will need to edit. There is a man page for <TT>fstab</TT>.

<SECT1>Exercises
<P>
Find the <TT>rcN.d</TT> directory for the default run-level of your system and do a <TT>ls -l</TT> to see what the files are links to.

<P>
Change the number of gettys that run on your system.

<P>
Remove any subsystems that you don't need from your default run-level.

<P>
See how little you can get away with starting.

<P>
Set up a floppy disk with lilo, a kernel and a statically linked "hello world" program called <TT>/sbin/init</TT> and watch it boot up and say hello.

<P>
Watch carefully as your system starts up, and take notes about what it tells you is happening. Or print a section of your system log <TT>/var/log/messages</TT> from start up time. Then starting at <TT>inittab</TT>, walk through all the scripts and see what code does what. You can also put extra start up messages in, such as

<VERB>
	echo "Hello, I am rc.sysinit"
</VERB>

This is a good exercise in learning Bash shell scripting too, some of the scripts are quite complicated. Have a good Bash reference handy.

<SECT1>More Information
<P>
<ITEMIZE>
<ITEM>Australian Sys V init 
	<URL URL="http://mirror.aarnet.edu.au/pub/linux/metalab/system/daemons/init"
 	 NAME="mirror"> 
<ITEM>Sys V init 
	<URL URL="http://sunsite.unc.edu/pub/Linux/system/daemons/init"
 	 NAME="download"> 
<ITEM>There are man pages for the <TT>inittab</TT> and <TT>fstab</TT> files. 
	Type (eg) <TT>man inittab</TT> into a shell to see it.
<ITEM>The Linux System Administrators Guide has a good 
	<URL URL="http://mirror.aarnet.edu.au/linux/LDP/LDP/" 
	NAME="section"> on init.
</ITEMIZE>


<SECT>The Filesystem
<P>
In this section, I will be using the word ``filesystem'' in two different ways.
There are filesystems on disk partitions and other devices, 
and there is the filesystem as it is
presented to you by a running Linux system. In Linux, you ``mount'' a disk
filesystem onto the system's filesystem.

<P>
In the previous section I mentioned that init scripts check and mount the
filesystems. The commands that do this are <TT>fsck</TT> and <TT>mount</TT>
respectively.

<P>
A hard disk is just a big space that you can write ones and zeros on. A
filesystem imposes some structure on this, and makes it look like files within
directories within directories... Each file is represented by an inode, which
says who's file it is, when it was created and where to find its contents.
Directories are also represented by inodes, but these say where to find the
inodes of the files that are in the directory. If the system wants to read
<TT>/home/greg/bigboobs.jpeg</TT>, it first finds the inode for the root
directory <TT>/</TT> in the ``superblock'', then finds the inode for the
directory <TT>home</TT> in the contents of <TT>/</TT>, then finds the inode for
the directory <TT>greg</TT>, then the inode for <TT>bigboobs.jpeg</TT> which
will tell it which disk blocks to read.


<P>
If we add some data to the end of a file, it could happen that the data is
written before the inode is updated to say that the new blocks belong to the
file, or vice versa. If the power cuts out at this point, the filesystem will
be broken. It is this kind of thing that <TT>fsck</TT> attempts to detect and
repair.

<P>
The mount command takes a filesystem on a device, and adds it to the heirarchy
that you see when you use your system. Usually, the kernel mounts its root file
system read-only. The mount command is used to remount it read-write after
<TT>fsck</TT> has checked that it is ok.

<P>
Linux supports other kinds of filesystem too: msdos, vfat, minix and so on. The
details of the specific kind of filesystem are abstracted away by the virtual
file system (VFS). I won't go into any detail on this though. There is a
discussion of it in ``The Linux Kernel'' (see <REF ID="Kernel" NAME="The Linux
Kernel"> for a url)

<SECT1>Configuration
<P>
There are parameters to the command <TT>mke2fs</TT> which creates ext2
filesystems. These control the size of blocks, the number of inodes and so on.
Check the <TT>mke2fs</TT> man page for details.

<P>
What gets mounted where on your filesystem is controlled by the <TT>/etc/fstab</TT>
file. It also has a man page. 

<SECT1>Exercises
<P>
Make a very small filesystem, and view it with a hex viewer. Identify inodes,
superblocks and file contents.

<P>
I believe there are tools that give you a graphical view of a filesystem.
Find one, try it out, and email me the url and a review!

<P>
Check out the ext2 filesystem code in the Kernel.

<SECT1>More Information
<P>
<ITEMIZE>
<ITEM>Chapter 9 of the LDP book ``The Linux Kernel'' is an excellent description
	of filesystems. You can find it at the Australian LDP
	<URL URL="http://mirror.aarnet.edu.au/linux/LDP/LDP/" 
	NAME="mirror">
<ITEM>The <TT>mount</TT> command is part of the util-linux package, there is a link 
	to it in <REF ID="util-linux" NAME="Login and Getty">.
<ITEM>man pages for <TT>mount</TT>, <TT>fstab</TT>, <TT>fsck</TT> and <TT>mke2fs</TT>
<ITEM>EXT2 File System Utilities
	<URL URL="http://web.mit.edu/tytso/www/linux/e2fsprogs.html"
	NAME="ext2fsprogs"> home page
	<URL URL="ftp://mirror.aarnet.edu.au/pub/linux/metalab/system/filesystems/ext2/"
	NAME="ext2fsprogs"> Australian mirror. There is also a Ext2fs-overview
	document here, although it is out of date, and not as readable as chapter 9
	of ``The Linux Kernel''
<ITEM> <URL URL="ftp://mirror.aarnet.edu.au/pub/linux/metalab/system/admin/"
	NAME="MAKEDEV"> This is a script to make all the device files in 
	<TT>/dev</TT>
<ITEM> <LABEL ID="FHS">
	<URL URL="ftp://tsx-11.mit.edu/pub/linux/docs/linux-standards/fsstnd/" 
	NAME="Unix File System Standard"> This describes what should go where
	in a Unix file system, and why. It also has minimum requirements for
	the contents of <TT>/bin</TT>, <TT>/sbin</TT> and so on. This is a 
	good reference if your goal is to make a minimal yet complete system.
</ITEMIZE>



<SECT>Kernel Daemons
<P>
Unfortunately, this section contains more conjectures and questions than facts.
Perhaps you can help?

<P>
If you issue the <TT>ps aux</TT> command, you will see something like the following:

<P>
<VERB>
USER       PID %CPU %MEM  SIZE   RSS TTY STAT START   TIME COMMAND
root         1  0.1  8.0  1284   536   ? S    07:37   0:04 init [2] 
root         2  0.0  0.0     0     0   ? SW   07:37   0:00 (kflushd)
root         3  0.0  0.0     0     0   ? SW   07:37   0:00 (kupdate)
root         4  0.0  0.0     0     0   ? SW   07:37   0:00 (kpiod)
root         5  0.0  0.0     0     0   ? SW   07:37   0:00 (kswapd)
root        52  0.0 10.7  1552   716   ? S    07:38   0:01 syslogd -m 0 
root        54  0.0  7.1  1276   480   ? S    07:38   0:00 klogd 
root        56  0.3 17.3  2232  1156   1 S    07:38   0:13 -bash 
root        57  0.0  7.1  1272   480   2 S    07:38   0:01 /sbin/agetty 38400 tt
root        64  0.1  7.2  1272   484  S1 S    08:16   0:01 /sbin/agetty -L ttyS1
root        70  0.0 10.6  1472   708   1 R   Sep 11   0:01 ps aux 
</VERB>

<P>
This is a list of the processes running on the system. Note that <TT>init</TT>
is process number one. Processes 2, 3, 4 and 5 are kflushd, kupdate, kpiod and
kswapd. There is something strange here though: notice that in both the virtual
storage size (SIZE) and the Real Storage Size (RSS) columns, these processes
have zeroes. How can a process use no memory? These processes are really part
of the kernel. The kernel does not show up on process lists at all, and you can
only work out what memory it is using by subtracting the memory available from
the amount on your system. The brackets around the command name could signify
that these are kernel processes(?)

<P>
<TT>kswapd</TT> moves parts of programs that are not currently being used
from real storage (ie RAM) to the swap space (ie hard disk). <TT>kflushd</TT>
writes data from buffers to disk. This allows things to run faster. What
programs write can be kept in memory, in a buffer, then written to disk in
larger more efficient chunks. I don't know what <TT>kupdate</TT> and
<TT>kpiod</TT> are for. 

<P>
This is where my knowledge ends. What do these last two daemons do? Why do 
kernel daemons get explicit process numbers rather than just being anonymous
bits of kernel code? Does init actually start them, or are they already running
when init arrives on the scene?

<P>
I put a script to mount <TT>/proc</TT> and do a <TT>ps aux</TT> in <TT>/sbin/init</TT>. Process 1 was the script itself, and processess 2, 3, 4 and 5 were the kernel daemons just as under the real init. The kernel must put these processes there, because my script certainly didn't!

<SECT1>Configuration
<P>
I don't know of any configuration for these kernel daemons.

<SECT1>Exercises
<P>
Find out what these processes are for, how they work, and write a new ``Kernel Daemons'' section for this document and send it to me!

<SECT1>More Information
<P>
The Linux Documentation Project's ``The Linux Kernel'' (see <REF ID="Kernel" NAME="The Linux Kernel"> for url), and the kernel source code are all I can think of.



<SECT>System Logger
<P>
Init starts the <TT>syslogd</TT> and <TT>klogd</TT> daemons. They write
messages to logs. The kernel's messages are handled by <TT>klogd</TT>, while
<TT>syslogd</TT> handles log messages from other processes. The main log is
<TT>/var/log/messages</TT>. This is a good place to look if something is going
wrong with your system. Often there will be a valuable clue in there.


<SECT1>Configuration
<P>
The file <TT>/etc/syslog.conf</TT> tells the loggers what messages to put where. Messages are identified by which service they come from, and what priority level they are. This configuration file consists of lines that say messages from service x with priority y go to z, where z is a file, tty, printer, remote host or whatever.

<P>
NOTE: Syslog requires the <TT>/etc/services</TT> file to be present. The services file allocates ports. I am not sure whether syslog needs a port allocated so that it can do remote logging, or whether even local logging is done through a port.

<SECT1>Exercises
<P>
Have a look at your system log. Find a message you don't understand, and find out what it means.

<P>
Send all your log messages to a tty. (set it back to normal once done)


<SECT1>More Information
<P>Australian sysklogd <URL URL="http://mirror.aarnet.edu.au/pub/linux/metalab/system/daemons/"
	NAME="Mirror">



<SECT>Getty and Login
<P>
Getty is the program that enables you to log in through a serial device such as a virtual terminal, a text terminal, or a modem. It displays the login prompt. Once you enter your username, getty hands this over to <TT>login</TT> which asks for a password, checks it out and gives you a shell.


<P>
There are many getty's available, but the util-linux package, which includes
<TT>login</TT> has one called <TT>agetty</TT>, which works fine. This package also
contains <TT>clock</TT>, <TT>fdformat</TT>, <TT>mkswap</TT>, <TT>fdisk</TT>,
<TT>passwd</TT>, <TT>kill</TT>, <TT>setterm</TT>, <TT>mount</TT>,
<TT>swapon</TT>, <TT>rdev</TT>, <TT>renice</TT>, <TT>hexdump</TT>,
<TT>more</TT> (the program) and more (ie more programs).
To keep things simple by minimising the number of packages you have to install,
I recommend using <TT>agetty</TT>.

<SECT1>Configuration
<P>
The message that comes on the top of your screen with your login prompt comes
from <TT>/etc/issue</TT>. Gettys are usually started in <TT>/etc/inittab</TT>.
Login checks user details in <TT>/etc/passwd</TT>, and if you have password
shadowing, <TT>/etc/shadow</TT>.

<SECT1>Exercises
<P>
Create a <TT>/etc/passwd</TT> by hand. Passwords can be set to null, and
changed with the program <TT>passwd</TT> once you log on. See the man page for
this file Use <TT>man 5 passwd</TT> to get the man page for the file rather
than the man page for the program.



<SECT1>More Information
<LABEL ID="util-linux">
<P>The 	<URL URL="ftp://mirror.aarnet.edu.au/pub/linux/metalab/system/misc"
	NAME="util-linux">
	package contains login and agetty, and lots of other stuff that you will need.
<P>There are lots of other getty's at
	<URL URL="ftp://mirror.aarnet.edu.au/pub/linux/metalab/system/serial/getty"
	NAME="Many getty's!">. getty_ps is the most general one, mingetty is for
	virtual terminals only. However, the util-linux package which you need
	for <TT>logon</TT> also contains <TT>agetty</TT>, which works fine.


<SECT>Bash
<P>
If you give <TT>login</TT> a valid username and password combination, it will
check in <TT>/etc/passwd</TT> to see which shell to give you. In most cases on
a Linux system this will be <TT>bash</TT>. It is <TT>bash</TT>'s job to read
your commands and see that they are acted on. It is simultaneously a user
interface, and a programming language interpreter.  

<P>
As a user interface it reads your commands, and executes them itself if they
are ``internal'' commands like <TT>cd</TT>, or finds and executes a program if
they are ``external'' commands like <TT>cp</TT> or <TT>startx</TT>. It also
does groovy stuff like keeping a command history, and completing filenames.

<P>
We have already seen <TT>bash</TT> in action as a programming language
interpreter. The scripts that <TT>init</TT> runs to start the system up are
usually shell scripts, and are executed by <TT>bash</TT>. Having a proper
programming language, along with the usual system utilities available at the
command line makes a very powerful combination, if you know what you are doing.
For example (smug mode on) I needed to apply a whole stack of ``patches'' to a
directory of source code the other day. I was able to do this with the
following single command:

<VERB>
for f in /home/greg/sh-utils-1.16*.patch; do patch -p0 < $f; done;
</VERB>

<P>
This looks at all the files in my home directory whose names start with
<TT>sh-utils-1.16</TT> and end with <TT>.patch</TT>. It then takes each of
these in turn, and sets the variable <TT>f</TT> to itand executes the commands
between <TT>do</TT> and <TT>done</TT>. In this case there were 11 patch files,
but there could just as easily have been 3000.

<SECT1>Configuration
<P>
The file <TT>/etc/profile</TT> controls the system-wide behaviour of bash. What
you put in here will affect everybody who uses bash on your system. It will do
things like add directories to the <TT>PATH</TT>, set your <TT>MAIL</TT>
directory variable.

<P>
The default behaviour of the keyboard often leaves a lot to be desired. It is
actually readline that handles this. Readline is a separate package that
handles command line interfaces, providing the command history and filename
completion, as well as some advanced line editing features. It is compiled into
bash. By default, readline is configured using the file <TT>.inputrc</TT> in
your home directory. The bash variable INPUTRC can be used to override this for
bash. For example in Red Hat 6, <TT>INPUTRC</TT> is set to
<TT>/etc/inputrc</TT> in <TT>/etc/profile</TT>. This means that backspace,
delete, home and end keys work nicely for everyone. 

<P>
Once bash has read the system-wide configuration file, it looks for your
personal configuration file. It checks in your home directory for
<TT>.bash_profile</TT>, <TT>.bash_login</TT> and <TT>.profile</TT>. It runs the
first one of these it finds. If you want to change the way bash behaves for
you, without changing the way it works for others, do it here. For example,
many applications use environment variables to control how they work. I have
the variable <TT>EDITOR</TT> set to <TT>vi</TT> so that I can use vi in
Midnight Commander (an excellent console based file manager) instead of its
editor. 


<SECT1>Exercises
<P>
The basics of bash are easy to learn. But don't stop there: there is an
incredible depth to it. get into the habit of looking for better ways to do
things. 

<P>
Read shell scripts, look up stuff you don't understand.

<SECT1>More Information
<P>
<ITEMIZE>
<ITEM> Australian Bash <URL URL="http://mirror.aarnet.edu.au/pub/gnu/bash"
	NAME="mirror"> 
<ITEM>There is a ``Bash Reference Manual'' with this, which is comprehensive, but heavy going. 
<ITEM> Australian readline <URL URL="http://mirror.aarnet.edu.au/pub/gnu/readline"
	NAME="mirror"> You need to download readline separately ((is it an addon type thingy?))
<ITEM>((bash tutorials? - if there isn't one around, make one!))
<ITEM>There is an O'Rielly book on Bash, not sure if it's good.
</ITEMIZE>


<SECT>Basic Commands
<P>
You do most things in bash by issuing commands. Most of these commands are
small programs.  I won't say too much about these. I have just listed the
packages that I found I needed.  I fear that I may have lost track slightly of
what was really necessary and what wasn't. I will fix this when I rebuild
my system to test this document. There isn't too much baggage in the list.
Most of it is needed for a fully functional Linux system anyway. 

<P>
Ideally, this list should include all commands specified in
The Unix <REF ID="FHS" NAME="File Heirarchy Standard"> 
and everthing needed to run the basic initscripts
that come with the sysvinit dist.  

<P>
<ITEMIZE>
<ITEM>GNU fileutils
	<URL URL="http://mirror.aarnet.edu.au/pub/gnu/fileutils/"
	NAME="fileutils"> commands such as cp, dd, ls, ln, mkdir and so on.
<ITEM>GNU findutils
	<URL URL="http://mirror.aarnet.edu.au/pub/gnu/findutils/"
	NAME="findutils"> find and locate commands. Find is needed in an
	init script ((check your notes on this)).
<ITEM>textutils? was that needed?? it contains <TT>cat</TT>, which is nice to have
	so you can look a files. its GNU
<ITEM>Gawk
	<URL URL="http://mirror.aarnet.edu.au/pub/gnu/gawk/"
	NAME="gawk"> GNU's implementation of the awk language. Awk
	is good for processing records in text files like the system log. 
	It is needed in an init script ((check your notes on this)).
<ITEM>grep
	<URL URL="http://mirror.aarnet.edu.au/pub/gnu/grep/"
	NAME="grep">
	It is needed in an init script ((check your notes on this)).
<ITEM>sed?? was that needed?? it's a GNU package
<ITEM><TT>sh-utils</TT> contains <TT>hostname</TT>, <TT>stty</TT>, <TT>true</TT>,
	<TT>false</TT>, <TT>yes</TT>, <TT>who</TT>, <TT>sleep</TT>
<ITEM>Net Tools: is probably not completely necessary, since <TT>hostname</TT>
	is in <TT>sh-utils</TT>
	<URL URL="ftp://mirror.aarnet.edu.au/pub/linux/metalab/?????????????????"
	NAME="net-tools">. The only thing you *really* need from this package,
	to get a really basic system up is hostname. But the other stuff in here
	such as, ifconfig, netstat and route will be needed when you want to
	connect your system to anything else.
<ITEM>Process Monitoring 
	<URL URL="ftp://mirror.aarnet.edu.au/pub/linux/metalab/system/status/ps/"
	NAME="procps">. The main commands in here are ps and top. They enable 
	you to see what is running on your system. This is useful for a learning
	exercise.
</ITEMIZE>



<SECT>Building Software From Source
<P>
So far I have focussed on what the packages do. Here I will offer what clues
I can about making a minimal Linux system from source. 

<SECT1>How I Built My System
<P>
There is more than one way to go about building a system.  But the
way I did it seems to have worked out ok, so this account may be helpful to you.

<P>
I used a dedicated
machine - an old Wang 386sx of almost zero dollar value. I did a minimal
install of Red Hat 6.0 to be the ``source'' system, and allocated a ``target''
partition where I built the system. In the old Wang, I have a 3G hard disk
partitioned as follows:

<VERB>
	hda1     480M   where I built the system (``target'')
	hda2      20M   boot partition for the Red Hat system
	hda3      50M   swap
	hda4    2500M   extended partition containing hda5
	hda5    2500M   Red Hat 6.0 root file system (``source'')
</VERB>	

<P>
There is no real point in having the logical partition hda5 inside an extended
partition, hda4. That's just what Red Hat's Disk Druid did when I installed.
You only need the base Red Hat system, plus development tools and libraries.
It used about 250M of disk space. You could do this exercise with a 1G disk,
or a pair of 500M disks. 

<P>
Older PC hardware, mostly 486's and earlier, have an annoying limitation
in their bios. They can not read from a hard disk past the first 512M.
This is not too much of a problem for Linux, because once it is up, it
does its own disk io. But for Linux to get loaded by these old machines, 
it has be reside somewhere below 512M. This is why I have both the whole
target partition, and the small boot partition for the source system 
below the 512M mark.

<P>
You may wish to actually use the target system, rather than simply build it for
a learning exercise. In this case, you would need to go a bit beyond what is
described in this document. You would need to install <TT>gcc</TT> and other
development tools so that the system could build itself. Once this was done,
you could wipe the ``source'' system and use its space on the target. Perhaps
you could move the <TT>/usr</TT> directory to it.

<P>
The Wang only has 8M of RAM in it. I think this is
the main reason that the compile of <TT>glibc</TT> took 90 hours (and spanned
millenia). It ``only'' took 6 hours on my 486 with 32M. My guess is that if
I had 16M in the Wang, it would have taken 24 to 48 hours. Kernel compiles
take about 8 hours.

<P>
I made an ext2 file system on the target partition using <TT>mke2fs</TT>, and
created directories by hand using <TT>mkdir</TT>. I didn't have it at the time,
but the <REF ID="FHS" NAME="Filesystem Heirarchy Standard"> would have been a 
good thing to follow.

<P>
In the <TT>fstab</TT> of the source system, I set up the target partition to 
be mounted at <TT>/mnt/target</TT>. Most of the packages have a configuration
option for where they are to be installed. By default, the ``base'' directory
for a package installation is <TT>/</TT>, ie you want to install it on the
system where it is being built. I used these options to set the base install
directory to <TT>/mnt/target</TT>. For example, to install a GNU package to
<TT>/mnt/target</TT>, you configure as follows

<VERB>
	./configure --prefix=/mnt/target
</VERB>

<P>
There is a problem with this approach if some of the packages of the target 
system are more recent than their equivalents on the source system. For
example, I installed ncurses 5 on the target system, but the source had 4.
When compiling, by default the headers and libraries of the source system
are used. To fix this you need to set variables or configuration parameters
to tell it where the headers and libraries that you want it to use are.
Sometimes all you can do is hack the <TT>Makefile</TT>. If you look at the
output that is produced while a program is being compiled, the <TT>-I</TT>
flags tell it where to look for headers, and the <TT>-L</TT> flags tell it
where to look for libraries.  Look for a variable called <TT>LDFLAGS</TT>. 
This is probably where you can slip a couple extra of these flags in, and
make it look where you want. For example in the <TT>Makefile</TT> for the
<TT>procps</TT> package, I got it to use the right libraries by adding

<VERB>
	-L /mnt/target/lib
</VERB>

<P>
LILO is installed in the master boot record by Red Hat. I installed LILO for
the target system in the boot sector of the target partition. I then added
the following to <TT>/etc/lilo.conf</TT> in the source system

<VERB>
other=/dev/hda1
	label=target
</VERB>

and reran <TT>lilo</TT>. This has the effect that when you first boot, 
one of the options LILO gives you is ``target''. If you choose this, you 
get a second instance of LILO which boots the target system. This might
seem crazy, but it allows the separation of the system you are building
from the system you are using to build it with.

<SECT1>Random Tips

<P>
If you have a command called <TT>thingy</TT> on a Linux system with RPM, and
want a clue about where to get the source from, you can use the command:

<VERB>
	rpm -qif `which thingy`
</VERB>

And if you have a Red Hat source CD, you can install the source code using

<VERB>
	rpm -i /mnt/cdrom/SRPMS/what.it.just.said-1.2.srpm
</VERB>


<P>
Once you have a bash prompt, the next stage is to get your system able to 
self replicate. I have not done this yet, but the following are some of
the things you will need to install to do this.

<ITEMIZE>
<ITEM>GNU make
<ITEM>GNU egcs
<ITEM>gdb
<ITEM>binutils - assembler, linker, etc; bin86 - intel specific versions
<ITEM>tar, gzip, bzip2
<ITEM>diff comes from diffutils, patch comes from patch, hehe
</ITEMIZE>

<SECT1>More Information
<P>
<ITEMIZE>
<ITEM> There is a mini-howto on building software from source, the
	<URL URL="http://mirror.aarnet.edu.au/linux/LDP/HOWTO/mini/Software-Building.html"
	NAME="Software Building mini-HOWTO">.
<ITEM> There is also a HOWTO on building a Linux system from scratch. 
	It focuses much more on getting the system built so it can be used, 
	rather than just doing it as a learning exercise.
	<URL URL="http://mirror.aarnet.edu.au/pub/linux/LDP/HOWTO/Linux-From-Scratch-HOWTO.html"
	NAME="The Linux From Scratch HOWTO">
</ITEMIZE>

<SECT>Conclusion
<P>
One of the best things about Linux, in my humble opinion, is that you can get
inside it and really find out how it all works. I hope that you enjoy this as
much as I do. And I hope that this little note has helped you do it.

<SECT>Administrivia
<SECT1>Copyright
<P>
This document is copyright (c) 1999, 2000 Greg O'Keefe. You are welcome
to use, copy, distribute or modify it, without charge, under the terms of the 
<URL URL="http://www.gnu.org/copyleft/gpl.html" 
	NAME="GNU General Public Licence">.
Please acknowledge me if you use part of this in another document.

<SECT1>Homepage
<P>
The lastest version of this document lives at 
<URL URL="http://learning.taslug.org.au/power2bash" 
	NAME="From Powerup To Bash Prompt"> 


	
<SECT1>Feedback
<P>
I would like to hear any comments, criticisms and suggestions for improvement
that you have. Please send them to me  
<URL URL="mailto:gcokeefe@postoffice.utas.edu.au" NAME="Greg O'Keefe">


<SECT1>Acknowledgements
<LABEL ID="acknowledge">
<P>
Product names are trademarks of the respective holders, and are hereby
considered properly acknowledged.

<P>
There are some people I want to say thanks to, for helping to make this happen.

<P>
<DESCRIP>
<TAG>Everyone on the learning@TasLUG mailing list</TAG>
Thanks for reading all my mails and asking interesting questions.
You can join this list by sending a message to 
<URL URL="mailto:majordomo@taslug.org.au" NAME="majordomo"> with
<VERB>
	subscribe learning
</VERB>
in the message body.

	
<TAG>Michael Emery</TAG>
For reminding me about Unios.
<TAG>Tim Little</TAG>
For some good clues about <TT>/etc/passwd</TT>
<TAG>sPaKr on #linux in efnet</TAG>
Who sussed out that syslogd needs <TT>/etc/services</TT>, 
and introduced me to the phrase "rolling your own" to 
describe building a system from source code.
<TAG>Alex Aitkin</TAG>
For bringing Vico and his ``verum ipsum factum'' 
(understanding arises through making) to my attention.
</DESCRIP>

<SECT1>Change History
<SECT2>0.5 -> 0.6
<P>
<ITEMIZE>
<ITEM>added change history
<ITEM>added some todos
</ITEMIZE>

<SECT1>TODO
<P>
<ITEMIZE>
<ITEM>add links to home sites, not just the aarnet mirror
<ITEM>add more exercises
<ITEM>wipe the target system on the Wang, and rebuild, closely following these notes as a test
<ITEM>check that all packages specified as kernel requirements (state version) are included
</ITEMIZE>

</ARTICLE>
