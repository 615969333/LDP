<!DOCTYPE article PUBLIC '-//OASIS//DTD DocBook V4.2//EN'>
<Article>
  <ArticleInfo>
    <Title>
      The Linux Kernel HOWTO 
    </Title>
    <AUTHOR>
      <FirstName>
        Al Dev (Alavoor Vasudevan) 
      </FirstName>
      <AuthorBlurb>
        <Para>
          <ULink URL="mailto:       alavoor[AT]yahoo.com    ">
            alavoor[AT]yahoo.com 
          </ULink>
        </Para>
      </AuthorBlurb>
      <affiliation>
        <address>
          <email>
            alavoor[AT]yahoo.com 
          </email>
        </address>
      </affiliation>
    </AUTHOR>
    <PubDate>
      v5.5, 22 April 2003 
    </PubDate>
    <Abstract>
      <Para>
        This is a detailed guide to kernel configuration, compilation, 
        upgrades, and troubleshooting for ix86-based systems. Can be useful 
        for other architectures as well. This document is kept small &#38; 
        simple, so that even non-technical "home computer users" will be able 
        to compile and run the Linux Kernel. 
      </Para>
    </Abstract>
  </ArticleInfo>
  <Sect1>
    <Title>
      Introduction 
    </Title>
    <Para>
      You compile Linux kernel for one of following reasons: 
      <ItemizedList>
        <ListItem>
          <Para>
            You are doing kernel development 
          </PARA>
        </ListItem>
        <ListItem>
          <Para>
            You are adding a new hardware to machine 
          </PARA>
        </ListItem>
        <ListItem>
          <Para>
            You want to customize the kernel and do not want the default 
            kernel shipped out to you. 
          </PARA>
        </ListItem>
        <ListItem>
          <Para>
            For 
            <Emphasis remap="bf">
              Defence Industries 
            </Emphasis>
            or 
            <Emphasis remap="bf">
              Military applications 
            </Emphasis>
            , you must read the kernel source code and compile with your own 
            hands. No exceptions!! (U.S Dept of Defence compiles the Linux 
            kernel before distributing the computers). 
          </PARA>
        </ListItem>
        <ListItem>
          <Para>
            Every country and every Government in the world compiles the 
            kernel on site for security and integrity. Every 
            Government/Corporation audits and verifies each and every line of 
            the OS kernel source code before using the computer. 
          </PARA>
        </ListItem>
        <ListItem>
          <Para>
            Military Intelligence agencies around the world reads and compiles 
            the Linux kernel source code. They know what each and every line 
            of Linux kernel source code is doing!! 
          </PARA>
        </ListItem>
        <ListItem>
          <Para>
            If you compile the Linux kernel with your own hands, then it is 
            <Emphasis remap="bf">
              as good as reading and verifying 
            </Emphasis>
            all the kernel source code! 
          </PARA>
        </ListItem>
        <ListItem>
          <Para>
            Each and every University in the world compiles the OS kernel 
            before using any computer! 
          </PARA>
        </ListItem>
        <ListItem>
          <Para>
            For your education and knowledge of Linux kernel and ofcourse, 
            just for fun! 
          </PARA>
        </ListItem>
        <ListItem>
          <Para>
            For very advanced scientific applications - you may need to do 
            kernel compile 
          </PARA>
        </ListItem>
        <ListItem>
          <Para>
            It is an International Law (the U.N. laws) - "You cannot use a 
            computer WITHOUT compiling the OS kernel with your own hands". If 
            you disobey this law you will be "punished" with lot of computer 
            problems!! You must compile the kernel with your own hands and not 
            rely on someone else to do it for you!! 
          </PARA>
        </ListItem>
        <ListItem>
          <Para>
            It is Illegal, Unlawful, Felony and Fraud to use a computer 
            without compiling the OS Kernel with your VERY OWN hands! 
          </PARA>
        </ListItem>
        <ListItem>
          <Para>
            In USA, all the corporations mandate compilation of OS kernel 
            before using the computer and hence there is Linux, Linux &#38; 
            Linux everywhere in United States! 
          </PARA>
        </ListItem>
        <ListItem>
          <Para>
            And for many hundreds of reasons - too numerous to list! 
          </Para>
        </ListItem>
      </ItemizedList>
    </Para>
    <Para>
      Note: This document is kept small &#38; simple, so that even 
      non-technical "home computer users" will be able to compile and run the 
      Linux Kernel! 
    </Para>
  </Sect1>
  <Sect1>
    <Title>
      Quick Steps - Kernel Compile 
    </Title>
    <Para>
      This section is written by 
      <ULink URL="mailto:alavoor[AT]yahoo.com">
        Al Dev (alavoor[AT]yahoo.com) 
      </ULink>
      (The 
      <Emphasis remap="bf">
        latest version 
      </Emphasis>
      of this document is at 
      <ULink URL="http://www.milkywaygalaxy.freeservers.com">
        "http://www.milkywaygalaxy.freeservers.com" 
      </ULink>
      . You may want to check there for changes). Mirror sites are at - 
      <ULink URL="http://www.angelfire.com/country/aldev0">
        angelfire 
      </ULink>
      , 
      <ULink URL="http://www.geocities.com/alavoor/index.html">
        geocities 
      </ULink>
      . These sites have lot of linux goodies and tips. 
    </Para>
    <Para>
      Kernel re-compile is required in order to make the kernel very lean and 
      which will result in FASTER operating system . It is also required to 
      support any new devices. 
    </Para>
    <Sect2 id="precautions">
      <Title>
        Precautionary Preparations 
      </Title>
      <Para>
        Before you build kernel, it is a good idea to do a backup of the 
        system. If you had not backed up your system recently then you can do 
        it now. You can use commercial backup tools like 
        <ULink URL="http://24.221.230.253">
          BRS Backup-Recovery-Software 
        </ULink>
        (also in this page you can find open-source/freeware backup tools 
        listed under 'Backup and Restore Utility'). Backup is just a 
        suggestion and it is not mandatory to do backup before building the 
        Linux kernel. 
      </Para>
    </Sect2>
    <Sect2 id="upgrading">
      <Title>
        Minor Upgrading of Kernel 
      </Title>
      <Para>
        If you had already built the kernel and you want to upgrade to next 
        patch release, then you can simply copy the existing config file and 
        reuse it. (For example you have built kernel 2.4.19 and want to 
        upgrade to 2.4.20). 
      </Para>
      <Para>
        <Emphasis remap="bf">
          For minor upgrades : 
        </Emphasis>
        This step may save you time, if you want to reuse the old settings. 
        Whenever you install the kernel, generally you put the config file in 
        /boot. So, you can use the existing version of config file: 
        <ProgramListing>
	bash# mv /usr/src/linux/.config  /usr/src/linux/.config.save
	bash# cp /boot/config-2.4.18-19.8.0  /usr/src/linux/.config
        </ProgramListing>
        Or another method is - you can copy the .config file from your old 
        linux kernel source tree to new kernel tree. 
        <ProgramListing>
	bash# ls -l /usr/src/lin*  # You can see that /usr/src/linux is a soft link
	bash# cd /usr/src/linux 
	bash# cp ../linux-old-tree/.config .  # Example cp ../linux-2.4.19/.config .
        </ProgramListing>
      </Para>
      <Para>
        or one other method is - you can use "make oldconfig" which default 
        all questions based on the contents of your existing ./.config file. 
      </Para>
      <Para>
        NOTE: If you do not have lot of disk space in /usr/src then you can 
        unpack the kernel source package on any partition where you have free 
        disk space (like /home). Because kernel compile needs lot of disk 
        space for object files like *.o. For this reason the /usr/src/linux 
        MUST be a soft link pointing to your source directory. 
      </Para>
      <Para>
        After this, look in the next section to do make and install. 
      </Para>
    </Sect2>
    <Sect2 id="impatient">
      <Title>
        For the Impatient 
      </Title>
      <Para>
        <OrderedList>
          <ListItem>
            <Para>
              Unpack the sources 
            </Para>
          </ListItem>
          <ListItem>
            <Para>
              Optional - Copy config file : You can copy the config file from 
              your old linux kernel source tree to new kernel tree (may save 
              time, if you want to reuse the old settings). 
            </Para>
          </ListItem>
          <ListItem>
            <Para>
              make clean; make mrproper 
            </Para>
          </ListItem>
          <ListItem>
            <Para>
              make xconfig 
            </Para>
          </ListItem>
          <ListItem>
            <Para>
              make dep 
            </Para>
          </ListItem>
          <ListItem>
            <Para>
              Give a unique name to your new Kernel - Edit 
              /usr/src/linux/Makefile and change EXTRAVERSION 
            </Para>
          </ListItem>
          <ListItem>
            <Para>
              nohup make bzImage 
            </Para>
          </ListItem>
          <ListItem>
            <Para>
              'make modules' and 'make modules&lowbar;install' 
            </Para>
          </ListItem>
          <ListItem>
            <Para>
              And you can go to lunch or go to bed (have nice Linux dreams in 
              sleep) and when you come back the system is ready! And see the 
              log with 'less nohup.out'. 
            </Para>
          </ListItem>
          <ListItem>
            <Para>
              make install &num; But NOT recommended - use cp 
              /usr/src/linux/arch/i386/boot/bzImage /boot/bzImage.myker 
            </Para>
          </ListItem>
          <ListItem>
            <Para>
              Configure GRUB or LILO. 
            </Para>
          </ListItem>
          <ListItem>
            <Para>
              Reboot and check new kernel is booting 
            </Para>
          </ListItem>
          <ListItem>
            <Para>
              Create emergency boot disk - bzdisk or mkbootdisk 
            </Para>
          </ListItem>
          <ListItem>
            <Para>
              Optional - make rpm &num; To build rpm packages 
            </Para>
          </ListItem>
          <ListItem>
            <Para>
              Optional - make clean (If you want to free up disk space) 
            </Para>
          </ListItem>
        </OrderedList>
      </Para>
      <Para>
        See details of above steps in the following sections.... 
      </Para>
    </Sect2>
    <Sect2 id="steps">
      <Title>
        Building New Kernel - Explanation of Steps 
      </Title>
      <Para>
        <Emphasis remap="bf">
          Details of the steps mentioned in the previous section: 
        </Emphasis>
      </Para>
      <Para>
        <Emphasis remap="bf">
          Note: 
        </Emphasis>
        Below 'bash&num;' denotes the bash prompt, you should type the 
        commands that appear after the 'bash&num;' prompt. Below are commands 
        tested on Redhat Linux Kernel 2.4.7-10, but it should work for other 
        distributions with very minor changes. It should also work for older 
        kernel versions like 2.2, 2.0 and 1.3. It should also work for future 
        or newer versions of kernel (with little changes - let me know). 
      </Para>
      <Para>
        <ItemizedList>
          <ListItem>
            <Para>
              <Emphasis remap="bf">
                Note: 
              </Emphasis>
              You can have many kernel images on your system. By following the 
              steps below you do not overwrite or damage your existing kernel. 
              These steps are 
              <Emphasis remap="bf">
                very safe 
              </Emphasis>
              and your current kernel will be intact and will not be touched. 
            </Para>
          </ListItem>
        </ItemizedList>
      </Para>
      <Para>
        <OrderedList>
          <ListItem>
            <Para>
              <Emphasis remap="bf">
                Unpack the sources: 
              </Emphasis>
              Login in as 'root' throughout all these steps. Mount Redhat 
              linux cdrom and install the linux kernel source rpm 
              <ProgramListing>
	bash$ su - root
	bash# cd /mnt/cdrom/RedHat/RPMS 
	bash# rpm -i kernel-headers*.rpm 
	bash# rpm -i kernel-source*.rpm 
	bash# rpm -i dev86*.rpm   
	bash# rpm -i bin86*.rpm   
              </ProgramListing>
              (The bin86*.rpm and 'as86' is required only for 
              <Emphasis remap="bf">
                OLDER Linux 
              </Emphasis>
              systems like Redhat 5.x. Get Intel assembler 'as86' command from 
              dev86*.rpm on cdrom or from 
              <ULink URL="http://rpmfind.net/linux/RPM/mandrake/7.1/Mandrake/RPMS/bin86-0.4-12mdk.i586.html">
                bin86-mandrake 
              </ULink>
              , 
              <ULink URL="http://rpmfind.net/linux/RPM/kondara/jirai/i586/bin86-0.4-8k.i586.html">
                bin86-kondara 
              </ULink>
              ). Also make sure that /usr/src/linux is soft link pointing to 
              proper unpacked source. 
              <ProgramListing>
	bash# cd /usr/src
	bash# ls -l    # You should see that /usr/src/linux is soft link pointing to source
	lrwxrwxrwx    1 root     root           19 Jan 26 11:01 linux -&#62; linux-2.4.18-19.8.0
	drwxr-xr-x   17 root     root         4096 Jan 25 21:08 linux-2.4.18-14
	drwxr-xr-x   17 root     root         4096 Mar 26 12:50 linux-2.4.18-19.8.0
	drwxr-xr-x    7 root     root         4096 Jan 14 16:32 redhat
              </ProgramListing>
              If it is not a soft link then do rename /usr/src/linux to 
              /usr/src/linux-2.4.yy and create a soft link. 
            </PARA>
              <Para>
                NOTE: If you do not have lot of disk space in /usr/src then 
                you can unpack the kernel source package on any partition 
                where you have free disk space (like /home). Because kernel 
                compile needs lot of disk space for object files like *.o. For 
                this reason the /usr/src/linux MUST be a soft link pointing to 
                your source directory. 
              </Para>
			  

          </ListItem>
          <ListItem>
            <Para>
              <Emphasis remap="bf">
                Optional - Copy config file : 
              </Emphasis>
              This step may save you time, if you want to reuse the old 
              settings. Whenever you install the kernel, generally you put the 
              config file in /boot. So, you can use the existing version of 
              config file: 
              <ProgramListing>
	bash# mv /usr/src/linux/.config  /usr/src/linux/.config.save
	bash# cp /boot/config-2.4.18-19.8.0  /usr/src/linux/.config
              </ProgramListing>
              Or another method is - you can copy the .config file from your 
              old linux kernel source tree to new kernel tree 
              <ProgramListing>
	bash# ls -l /usr/src/lin*  # You can see that /usr/src/linux is a soft link
	bash# cd /usr/src/linux 
	bash# cp ../linux-old-tree/.config .  # Example cp ../linux-2.4.19/.config .
              </ProgramListing>
              or one other method is - you can use "make oldconfig" which 
              default all questions based on the contents of your existing 
              ./.config file. 
			  

            </PARA>
          </ListItem>
          <ListItem>
            <Para>
              <Emphasis remap="bf">
                Clean : 
              </Emphasis>
              Before doing mrproper below, you may want to backup the .config 
              file. 
              <ProgramListing>
	bash# cd /usr/src/linux 
	bash# cp .config .config.save
	bash# make clean
	bash# make mrproper  # Must do this if want to start clean slate or if you face lot of problems
              </ProgramListing>
            </PARA>
          </ListItem>
          <ListItem>
            <Para>
              <Emphasis remap="bf">
                Configure: 
              </Emphasis>

              <ItemizedList>
                <ListItem>
                  <Para>
                    Start X-windows with 'startx'. If you are not able to 
                    start X-window then see next step below. 
                    <ProgramListing>
	bash# man startx
	bash# startx
	bash# cd /usr/src/linux 
	bash# make xconfig 
                    </ProgramListing>
                  </Para>
                </ListItem>
                <ListItem>
                  <Para>
                    If you are not able to start X-window above then try - 
                    <ProgramListing>
		bash# export TERM=xterm
		bash# make menuconfig
	If you find scrambled display, then use different terminal emulators like vt100,
	vt102, vt220 or ansi. The display will be scrambled and will have garbage 
	characters in cases where you use telnet to login to remote linux. In such 
	cases you should use the terminal emulators like vt100, vt220. 
	For example:
		bash# export TERM=vt220
		bash# export TERM=ansi
	At a lower level of VT, use: 
		bash# export TERM=vt100
		bash# make menuconfig
	If the menuconfig command fails then try -
		bash# make config
                    </ProgramListing>
                  </Para>
                </ListItem>
              </ItemizedList>
<para>
              The 
              <Emphasis remap="bf">
                "make xconfig" or "make menuconfig" 
              </Emphasis>
              brings up a user friendly GUI interface. And 
              <Emphasis remap="bf">
                "make config" 
              </Emphasis>
              brings up command-line console mode interface. You can load the 
              configuration file from 
              <Emphasis remap="it">
                /usr/src/linux/.config 
              </Emphasis>
              (dot config file. Note the dot before config). Click on button 
              "Load Configuration from File". 
</para>
              <Para>
                Within 'make xconfig' you must do these (to avoid problems) - 
                <ItemizedList>
                  <ListItem>
                    <Para>
                      <Emphasis remap="bf">
                        VERY IMPORTANT !!! : 
                      </Emphasis>
                      Select proper CPU type - Pentium 3, AMD K6, Cyrix, 
                      Pentium 4, Intel 386, DEC Alpha, PowerPC otherwise 
                      kernel compile will fail and even if it compiles, it 
                      will not boot!! 
                    </Para>
                  </ListItem>
                  <ListItem>
                    <Para>
                      Select SMP support - whether single CPU or multiple CPUs 
                    </Para>
                  </ListItem>
                  <ListItem>
                    <Para>
                      Filesystems - Select Windows95 Vfat, MSDOS, NTFS as part 
                      of kernel and not as loadable modules. (My personal 
                      preference, but you are free to pick your own option). 
                    </Para>
                  </ListItem>
                  <ListItem>
                    <Para>
                      Enable the Loadable kernel modules support! With this 
                      option you can load/unload the device drivers 
                      dynamically on running linux system on the fly. See the 
                      Modules chapter at 
                      <XRef LinkEnd="loadablemodules">
                      . 
                    </Para>
                  </ListItem>
                </ItemizedList>
              </Para>
              <Para>
                Save and Exit "make xconfig". All the options which you 
                selected is now saved into configuration file at 
                <Emphasis remap="it">
                  /usr/src/linux/.config 
                </Emphasis>
                (dot config file). 
              </Para>
<!--
            </Para>
end of comment -->
          </ListItem>
          <ListItem>
            <Para>
              <Emphasis remap="bf">
                Dep : 
              </Emphasis>
              And now, do - 
              <ProgramListing>
	bash# make dep
              </ProgramListing>
            </PARA>
          </ListItem>
          <ListItem>
            <Para>
              <Emphasis remap="bf">
                Give a unique name to your new Kernel: 
              </Emphasis>
              You can give a name to your kernel, so that it is unique and 
              does not interfere with others. 
              <ProgramListing>
	bash# cd /usr/src/linux
	bash# vi Makefile
              </ProgramListing>
              Here look for EXTRAVERSION = -19.8.0Blah&lowbar;Blah&lowbar;Blah 
              and change to something like EXTRAVERSION = 
              -19.8.0MyKernel.26Jan2003 
            </PARA>
          </ListItem>
          <ListItem>
            <Para>
              <Emphasis remap="bf">
                Do make: 
              </Emphasis>
              Read the following file (to gain some knowledge about kernel 
              building. Tip: Use the color editor 
              <ULink URL="http://www.linuxdoc.org/HOWTO/Vim-HOWTO.html">
                gvim 
              </ULink>
              for better readability. 
              <ProgramListing>
	bash# gvim -R   /usr/src/linux/arch/i386/config.in 
	bash# man less 
	bash# less   /usr/src/linux/arch/i386/config.in 
	Type 'h' for help and to navigate press i, j, k, l, h or arrow, page up/down keys. 
              </ProgramListing>
              <Para>
                Now, give the make command - 
                <ProgramListing>
		bash# cd /usr/src/linux
		bash# man nohup
		bash# nohup make bzImage &#38;  
		bash# man tail
		bash# tail -f nohup.out     (.... to monitor the progress) 
	This will put the kernel in /usr/src/linux/arch/i386/boot/bzImage 
                </ProgramListing>
              </Para>

          </ListItem>
          <ListItem>
            <Para>
              <Emphasis remap="bf">
                LOADABLE MODULES: 
              </Emphasis>
              Now, while the 'make' is cranking along in the previous step "Do 
              make", you should bring up another new xterm shell window and 
              follow these steps: This step is required 
              <Emphasis remap="bf">
                ONLY if 
              </Emphasis>
              you had enabled Loadable module support in step "Configure Step" 
              above. Loadable module are located in /lib/modules. You MUST do 
              this step if you enabled or disabled any modules, otherwise you 
              will get 'unresolved symbols' errors during or after kernel 
              boot. 
              <ProgramListing>
	# Bring up a new Xterm shell window and ...
	bash# cd /usr/src/linux
	# Redirect outputs such that you do not overwrite the nohup.out which is still running...
	bash# nohup make modules 1&#62; modules.out 2&#62; modules.err  &#38;
	bash# make modules_install   # Do this, only after the above make command is successful
              </ProgramListing>
              This will copy the modules to /lib/modules directory. See the 
              Modules chapter at 
              <XRef LinkEnd="loadablemodules">
              . 
            </PARA>
          </ListItem>
          <ListItem>
            <Para>
              <Emphasis remap="bf">
                Now go to Lunch or Bed : 
              </Emphasis>
              Since both the make windows are cranking along, and now, you can 
              go to lunch (chitchat, have nap) or go to bed (have nice Linux 
              dreams in sleep) and when you wake up and come back the system 
              is ready! You can check with command 'less nohup.out' to see the 
              log of output. 
              <ProgramListing>
	bash# cd /usr/src/linux
	bash# less nohup.out
	bash# less modules.err
	bash# less modules.out
	If no errors then do:
	bash# make modules_install  
              </ProgramListing>
            </Para>
          </ListItem>
          <ListItem>
            <Para>
              <Emphasis remap="bf">
                bzImage: 
              </Emphasis>
              After bzImage is successful, copy the kernel image to /boot 
              directory. You must copy the new kernel image to /boot 
              directory, otherwise the new kernel 
              <Emphasis remap="bf">
                MAY NOT 
              </Emphasis>
              boot. You must also copy the config file to /boot area to 
              reflect the kernel image, for documentation purpose. 
              <ProgramListing>
	bash# cp /usr/src/linux/arch/i386/boot/bzImage     /boot/bzImage.myker.26mar2001

	# You MUST copy the config file to reflect the corresponding kernel image, 
	# for documentation purpose.
	bash# cp /usr/src/linux/.config /boot/config-&#60;your_kernelversion_date&#62;

	# Example: cp /usr/src/linux/.config /boot/config-2.4.18-19.8.0-26mar2001
              </ProgramListing>
              <Emphasis remap="bf">
                NOTE : 
              </Emphasis>
              If you are planning to use the initrd in LILO or GRUB then you 
              may want to build initrd and place it in /boot/initrd*.img. See 
              the Appendix A at 
              <XRef LinkEnd="createinitrd">
              . 
              <Para>
              </Para>

          </ListItem>
          <ListItem>
            <Para>
              <Emphasis remap="bf">
                Configure GRUB or LILO : 
              </Emphasis>
              There are two options for boot loading under Redhat Linux - GRUB 
              and LILO. 
              <Para>
                <Emphasis remap="bf">
                  Configure GRUB: 
                </Emphasis>
                GRUB is recent and much better tool than LILO and it is my 
                first preference to use GRUB. LILO is an older technology. 
                GRUB differs from bootloaders such as LILO in that 
                <Emphasis remap="it">
                  "it can lie to MS Windows and make MS Windows believe that 
                  it's installed on the first partition even if it's not!!" 
                </Emphasis>
                . So you can keep your current Linux system where it is and 
                install Windows on the side. See the 
                <XRef LinkEnd="grubconf">
                file. 
              </Para>
              <Para>
                <Emphasis remap="bf">
                  Configure LILO: 
                </Emphasis>
                LILO is older tool and see the 
                <XRef LinkEnd="liloconf">
                to configure LILO. (see also 
                <ULink URL="http://www.linuxdoc.org/HOWTO/LILO-crash-rescue-HOWTO.html">
                  "http://www.linuxdoc.org/HOWTO/LILO-crash-rescue-HOWTO.html" 
                </ULink>
                ) 
              </Para>

          </ListItem>
          <ListItem>
            <Para>
              Reboot the machine and at lilo press tab key and type 'myker' If 
              it boots then you did a good job! Otherwise at lilo select your 
              old kernel, boot and re-try all over again. Your old kernel 
              <Emphasis remap="bf">
                is still INTACT and SAFE 
              </Emphasis>
              at say 
              <Emphasis remap="it">
                /boot/vmlinuz-2.0.34-0.6 
              </Emphasis>
            </PARA>
          </ListItem>
          <ListItem>
            <Para>
              If your new kernel 'myker' boots and works properly, you can 
              create the boot disk. Insert a blank floppy into floppy drive 
              and - 
              <ProgramListing>
	bash# cd /usr/src/linux
	bash# make bzdisk
	See also mkbootdisk -
	bash# rpm -i mkbootdisk*.rpm
	bash# man mkbootdisk
              </ProgramListing>
            </PARA>
          </ListItem>
          <ListItem>
            <Para>
              Build RPMs 
              <Para>
                Optional - You can also build RPM packages of kernel, in case 
                you want to install the new image on several machines. 
                <ProgramListing>
	make rpm   # To build rpm packages
                </ProgramListing>
              </Para>

          </ListItem>
          <ListItem>
            <Para>
              <Emphasis remap="bf">
                Clean: 
              </Emphasis>
              Optional - make clean (If you want to free up disk space) 
            </PARA>
          </ListItem>
        </OrderedList>
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        Troubleshooting 
      </Title>
      <Para>
        Having any problems? See the 
        <XRef LinkEnd="troubleshoot">
        . 
      </Para>
    </Sect2>
    <Sect2 id="postkernel">
      <Title>
        Post Kernel Building 
      </Title>
      <Para>
        See the 
        <XRef LinkEnd="postkerneld">
        . 
      </Para>
    </Sect2>
  </Sect1>
  <Sect1 id="loadablemodules">
    <Title>
      Loadable Modules 
    </Title>
    <Para>
      Loadable kernel modules can save memory and ease configuration. The 
      scope of modules has grown to include filesystems, ethernet card 
      drivers, tape drivers, printer drivers, and more. 
    </Para>
    <Para>
      Loadable modules are pieces of kernel code which are not linked 
      (included) directly in the kernel. One compiles them separately, and can 
      insert and remove them into the running kernel at almost any time. Due 
      to its flexibility, this is now the preferred way to code certain kernel 
      features. Many popular device drivers, such as the PCMCIA drivers and 
      the QIC-80/40 tape driver, are loadable modules. 
    </Para>
    <Para>
      See the Module-HOWTO at 
      <ULink URL="http://www.tldp.org/HOWTO/Module-HOWTO">
        "http://www.tldp.org/HOWTO/Module-HOWTO" 
      </ULink>
      . 
    </Para>
    <Para>
      And see these man pages 
      <ProgramListing>
	bash# rpm -i /mnt/cdrom/Redhat/RPMS/modutils*.rpm
	bash# man lsmod
	bash# man insmod
	bash# man rmmod
	bash# man depmod
	bash# man modprobe
      </ProgramListing>
      For example to load the module 
      <Literal remap="tt">
        /lib/modules/2.4.2-2/kernel/drivers/block/loop.o 
      </Literal>
      , you would do : 
      <ProgramListing>
	bash# man insmod
	bash# modprobe loop
	bash# insmod loop
	bash# lsmod 
      </ProgramListing>
      You can set the PATH which the insmod searches in /etc/modules.conf. 
    </Para>
    <Sect2>
      <Title>
        Installing the module utilities 
      </Title>
      <Para>
        You can install the Module Utilities RPM with: 
        <ProgramListing>
	bash# rpm -i /mnt/cdrom/Redhat/RPMS/modutils*.rpm
        </ProgramListing>
      </Para>
      <Para>
        <Literal remap="tt">
          insmod 
        </Literal>
        inserts a module into the running kernel. Modules usually have a 
        <Literal remap="tt">
          .o 
        </Literal>
        extension; the example driver mentioned above is called 
        <Literal remap="tt">
          drv&lowbar;hello.o 
        </Literal>
        , so to insert this, one would say ` 
        <Literal remap="tt">
          insmod drv&lowbar;hello.o 
        </Literal>
        '. To see the modules that the kernel is currently using, use 
        <Literal remap="tt">
          lsmod 
        </Literal>
        . The output looks like this: blah# lsmod Module: #pages: Used by: 
        drv_hello 1 ` 
        <Literal remap="tt">
          drv&lowbar;hello 
        </Literal>
        ' is the name of the module, it uses one page (4k) of memory, and no 
        other kernel modules depend on it at the moment. To remove this 
        module, use ` 
        <Literal remap="tt">
          rmmod drv&lowbar;hello 
        </Literal>
        '. Note that 
        <Literal remap="tt">
          rmmod 
        </Literal>
        wants a 
        <Emphasis remap="it">
          module name, 
        </Emphasis>
        not a filename; you get this from 
        <Literal remap="tt">
          lsmod 
        </Literal>
        's listing. The other module utilities' purposes are documented in 
        their manual pages. 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        Modules distributed with the kernel 
      </Title>
      <Para>
        As of version 2.0.30, most of everything is available as a loadable 
        modules. To use them, first make sure that you don't configure them 
        into the regular kernel; that is, don't say 
        <Literal remap="tt">
          y 
        </Literal>
        to it during ` 
        <Literal remap="tt">
          make config 
        </Literal>
        '. Compile a new kernel and reboot with it. Then, 
        <Literal remap="tt">
          cd 
        </Literal>
        to 
        <Literal remap="tt">
          /usr/src/linux 
        </Literal>
        again, and do a ` 
        <Literal remap="tt">
          make modules 
        </Literal>
        '. This compiles all of the modules which you did not specify in the 
        kernel configuration, and places links to them in 
        <Literal remap="tt">
          /usr/src/linux/modules 
        </Literal>
        . You can use them straight from that directory or execute ` 
        <Literal remap="tt">
          make modules&lowbar;install 
        </Literal>
        ', which installs them in 
        <Literal remap="tt">
          /lib/modules/x.y.z 
        </Literal>
        , where 
        <Literal remap="tt">
          x.y.z 
        </Literal>
        is the kernel release. 
      </Para>
      <Para>
        This can be especially handy with filesystems. You may not use the 
        minix or msdos filesystems frequently. For example, if I encountered 
        an msdos (shudder) floppy, I would 
        <Literal remap="tt">
          insmod /usr/src/linux/modules/msdos.o 
        </Literal>
        , and then 
        <Literal remap="tt">
          rmmod msdos 
        </Literal>
        when finished. This procedure saves about 50k of RAM in the kernel 
        during normal operation. A small note is in order for the minix 
        filesystem: you should 
        <Emphasis remap="it">
          always 
        </Emphasis>
        configure it directly into the kernel for use in ``rescue'' disks. 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        Howto Install Just A Single Module ? 
      </Title>
      <Para>
        Let us assume that you already did 'make modules' and 'make 
        modules&lowbar;install'. And later you did 'make clean' to free up 
        disk space. And now, you want to change a "C" file in one of the 
        modules and want to rebuild just that module and copy the module file 
        to /lib/modules. How do you do it? 
      </Para>
      <Para>
        You can compile just a single module file (say like foo.o) and install 
        it. For this simply edit the Makefile and change the SUBDIRS to add 
        only those directories you are interested. 
      </Para>
      <Para>
        For an example, if I am interested in installing only fs/autofs 
        module, then I do the following : 
        <ProgramListing>
	cd /usr/src/linux
	cp Makefile Makefile.my
	vi Makefile.my  
	# And comment out the line having 'SUBDIRS' and add the 
	# directory you are interested, for example like fs/autofs as below :
		#SUBDIRS	=kernel drivers mm fs net ipc lib abi crypto
		SUBDIRS		=fs/autofs
	# Save the file Makefile.my and give -
	make -f Makefile.my modules
	# This will create module autofs.o
	# Now, copy the module object file to destination /lib/modules
	make -f Makefile.my modules_install
	# And this will do 'cp autofs.o /lib/modules/2.4.18-19.8.0/kernel/fs/autofs'
        </ProgramListing>
      </Para>
      <Para>
        Learn more about Makefile and make. See the manual for GNU make at 
        <ItemizedList>
          <ListItem>
            <Para>
              <ULink URL="http://www.gnu.org/manual/make">
                "http://www.gnu.org/manual/make" 
              </ULink>
              . 
            </Para>
          </ListItem>
          <ListItem>
            <Para>
              University of Utah Makefile 
              <ULink URL="http://www.math.utah.edu/docs/info/make-stds_toc.html">
                "http://www.math.utah.edu/docs/info/make-stds_toc.html" 
              </ULink>
            </Para>
          </ListItem>
          <ListItem>
            <Para>
              University of Hawaii Makefile 
              <ULink URL="http://www.eng.hawaii.edu/Tutor/Make">
                "http://www.eng.hawaii.edu/Tutor/Make" 
              </ULink>
            </Para>
          </ListItem>
          <ListItem>
            <Para>
              In Linux - man make 
            </Para>
          </ListItem>
          <ListItem>
            <Para>
              In Linux - info make 
            </Para>
          </ListItem>
        </ItemizedList>
      </Para>
      <Para>
        Get familiar with the Makefile which makes the modules. The Makefile 
        has module line like 
        <ProgramListing>
	modules: $(patsubst %, _mod_%, $(SUBDIRS))
        </ProgramListing>
      </Para>
      <Para>
        The patsubst function has the syntax $(patsubst 
        pattern,replacement,text). It uses the percent symbol (&percnt;) the 
        same way pattern rules do - as a string which matches in both the 
        pattern and the replacement text. It searches the text for 
        whitespace-separated words that match the pattern and substitutes the 
        replacement for them. 
      </Para>
      <Para>
        This makefile includes shell functions as well as standard make 
        functions. The syntax for a shell function is $(shell command). This 
        returns the output of the shell function (stripping new lines). 
      </Para>
    </Sect2>
  </Sect1>
  <Sect1 id="cloning">
    <Title>
      Cloning of Linux Kernels 
    </Title>
    <Para>
      You may want to build a Linux kernel on a system and then you may want 
      to mass deploy to many identical hardware PCs. To make it easy to 
      install your newly built kernel on hundreds of other systems, you may 
      want to package it in RPMs (Redhat) or DEB package (Debian) or just 
      tar.gz files. 
    </Para>
    <Para>
      <OrderedList>
        <ListItem>
          <Para>
            Build a kernel rpm package with rpmbuild -ba kernel*.spec 
          </PARA>
        </ListItem>
        <ListItem>
          <Para>
            Check that the kernel*.rpm generated has all the files in 
            /lib/modules/2.x.x-y directory. Otherwise you may want to tar gzip 
            the directory /lib/modules/2.x.x-y and take it to destination 
            machines. 
          </PARA>
        </ListItem>
        <ListItem>
          <Para>
            Check that your kernel package has /boot/initrd-2.x.x-y.img file, 
            otherwise you may want to tar gzip and take it to destination 
            machines. 
          </PARA>
        </ListItem>
        <ListItem>
          <Para>
            And other files in /boot which are not in the kernel*.rpm package. 
          </PARA>
        </ListItem>
      </OrderedList>
    </Para>
  </Sect1>
  <Sect1>
    <Title>
      Important questions and their answers 
    </Title>
    <Sect2>
      <Title>
        What does the kernel do, anyway? 
      </Title>
      <Para>
        The Unix kernel acts as a mediator for your programs and your 
        hardware. First, it does (or arranges for) the memory management for 
        all of the running programs (processes), and makes sure that they all 
        get a fair (or unfair, if you please) share of the processor's cycles. 
        In addition, it provides a nice, fairly portable interface for 
        programs to talk to your hardware. 
      </Para>
      <Para>
        There is certainly more to the kernel's operation than this, but these 
        basic functions are the most important to know. 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        Why would I want to upgrade my kernel? 
      </Title>
      <Para>
        Newer kernels generally offer the ability to talk to more types of 
        hardware (that is, they have more device drivers), they can have 
        better process management, they can run faster than the older 
        versions, they could be more stable than the older versions, and they 
        fix silly bugs in the older versions. Most people upgrade kernels 
        because they want the device drivers and the bug fixes. 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        What kind of hardware do the newer kernels support? 
      </Title>
      <Para>
        See the 
        <ULink URL="http://www.tldp.org/HOWTO/Hardware-HOWTO">
          Hardware-HOWTO 
        </ULink>
        . Alternatively, you can look at the ` 
        <Literal remap="tt">
          config.in 
        </Literal>
        ' file in the linux source, or just find out when you try ` 
        <Literal remap="tt">
          make config 
        </Literal>
        '. This shows you all hardware supported by the standard kernel 
        distribution, but not everything that linux supports; many common 
        device drivers (such as the PCMCIA drivers and some tape drivers) are 
        loadable modules maintained and distributed separately. 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        What version of gcc and libc do I need? 
      </Title>
      <Para>
        Linus recommends a version of gcc in the 
        <Literal remap="tt">
          README 
        </Literal>
        file included with the linux source. If you don't have this version, 
        the documentation in the recommended version of gcc should tell you if 
        you need to upgrade your libc. This is not a difficult procedure, but 
        it is important to follow the instructions. 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        What's a loadable module? 
      </Title>
      <Para>
        See the Modules chapter at 
        <XRef LinkEnd="loadablemodules">
        . 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        How much disk space do I need? 
      </Title>
      <Para>
        It depends on your particular system configuration. First, the 
        compressed linux source is nearly 14 megabytes large at version 2.2.9. 
        Many sites keep this even after unpacking. Uncompressed and built with 
        a moderate configuration, it takes up another 67 MB. 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        How long does it take? 
      </Title>
      <Para>
        With newer machines, the compilation takes dramatically less time than 
        older ones; an AMD K6-2/300 with a fast disk can do a 2.2.x kernel in 
        about four minutes. As for old Pentiums, 486s, and 386s, if you plan 
        to compile one, be prepared to wait, possibly hours, days.. 
      </Para>
      <Para>
        If this troubles you, and you happen to have a faster machine around 
        to compile on, you can build on the fast machines (assuming you give 
        it the right parameters, that your ulilities are up-to-date, and so 
        on), and then transfer the kernel image to the slower machine. 
      </Para>
    </Sect2>
  </Sect1>
  <Sect1>
    <Title>
      Patching the kernel 
    </Title>
    <Sect2>
      <Title>
        Applying a patch 
      </Title>
      <Para>
        Incremental upgrades of the kernel are distributed as patches. For 
        example, if you have Linux v1.1.45, and you notice that there's a ` 
        <Literal remap="tt">
          patch46.gz 
        </Literal>
        ' out there for it, it means you can upgrade to version 1.1.46 through 
        application of the patch. You might want to make a backup of the 
        source tree first (` 
        <Literal remap="tt">
          make clean 
        </Literal>
        ' and then ` 
        <Literal remap="tt">
          cd /usr/src; tar zcvf old-tree.tar.gz linux 
        </Literal>
        ' will make a compressed tar archive for you.). 
      </Para>
      <Para>
        So, continuing with the example above, let's suppose that you have ` 
        <Literal remap="tt">
          patch46.gz 
        </Literal>
        ' in 
        <Literal remap="tt">
          /usr/src 
        </Literal>
        . 
        <Literal remap="tt">
          cd 
        </Literal>
        to 
        <Literal remap="tt">
          /usr/src 
        </Literal>
        and do a ` 
        <Literal remap="tt">
          zcat patch46.gz &verbar; patch -p0 
        </Literal>
        ' (or ` 
        <Literal remap="tt">
          patch -p0 &lt; patch46 
        </Literal>
        ' if the patch isn't compressed). You'll see things whizz by (or 
        flutter by, if your system is that slow) telling you that it is trying 
        to apply hunks, and whether it succeeds or not. Usually, this action 
        goes by too quickly for you to read, and you're not too sure whether 
        it worked or not, so you might want to use the 
        <Literal remap="tt">
          -s 
        </Literal>
        flag to 
        <Literal remap="tt">
          patch 
        </Literal>
        , which tells 
        <Literal remap="tt">
          patch 
        </Literal>
        to only report error messages (you don't get as much of the ``hey, my 
        computer is actually doing something for a change!'' feeling, but you 
        may prefer this..). To look for parts which might not have gone 
        smoothly, cd to 
        <Literal remap="tt">
          /usr/src/linux 
        </Literal>
        and look for files with a 
        <Literal remap="tt">
          .rej 
        </Literal>
        extension. Some versions of 
        <Literal remap="tt">
          patch 
        </Literal>
        (older versions which may have been compiled with on an inferior 
        filesystem) leave the rejects with a 
        <Literal remap="tt">
          &num; 
        </Literal>
        extension. You can use ` 
        <Literal remap="tt">
          find 
        </Literal>
        ' to look for you; find . -name '*.rej' -print prints all files who 
        live in the current directory or any subdirectories with a 
        <Literal remap="tt">
          .rej 
        </Literal>
        extension to the standard output. 
      </Para>
      <Para>
        If everything went right, do a ` 
        <Literal remap="tt">
          make clean 
        </Literal>
        ', ` 
        <Literal remap="tt">
          config 
        </Literal>
        ', and ` 
        <Literal remap="tt">
          dep 
        </Literal>
        ' as described in sections 3 and 4. 
      </Para>
      <Para>
        There are quite a few options to the 
        <Literal remap="tt">
          patch 
        </Literal>
        command. As mentioned above, 
        <Literal remap="tt">
          patch -s 
        </Literal>
        will suppress all messages except the errors. If you keep your kernel 
        source in some other place than 
        <Literal remap="tt">
          /usr/src/linux 
        </Literal>
        , 
        <Literal remap="tt">
          patch -p1 
        </Literal>
        (in that directory) will patch things cleanly. Other 
        <Literal remap="tt">
          patch 
        </Literal>
        options are well-documented in the manual page. 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        If something goes wrong 
      </Title>
      <Para>
        (Note: this section refers mostly to quite old kernels) 
      </Para>
      <Para>
        The most frequent problem that used to arise was when a patch modified 
        a file called ` 
        <Literal remap="tt">
          config.in 
        </Literal>
        ' and it didn't look quite right, because you changed the options to 
        suit your machine. This has been taken care of, but one still might 
        encounter it with an older release. To fix it, look at the 
        <Literal remap="tt">
          config.in.rej 
        </Literal>
        file, and see what remains of the original patch. The changes will 
        typically be marked with ` 
        <Literal remap="tt">
          + 
        </Literal>
        ' and ` 
        <Literal remap="tt">
          - 
        </Literal>
        ' at the beginning of the line. Look at the lines surrounding it, and 
        remember if they were set to ` 
        <Literal remap="tt">
          y 
        </Literal>
        ' or ` 
        <Literal remap="tt">
          n 
        </Literal>
        '. Now, edit 
        <Literal remap="tt">
          config.in 
        </Literal>
        , and change ` 
        <Literal remap="tt">
          y 
        </Literal>
        ' to ` 
        <Literal remap="tt">
          n 
        </Literal>
        ' and ` 
        <Literal remap="tt">
          n 
        </Literal>
        ' to ` 
        <Literal remap="tt">
          y 
        </Literal>
        ' when appropriate. Do a patch -p0 &#60; config.in.rej and if it 
        reports that it succeeded (no fails), then you can continue on with a 
        configuration and compilation. The 
        <Literal remap="tt">
          config.in.rej 
        </Literal>
        file will remain, but you can get delete it. 
      </Para>
      <Para>
        If you encounter further problems, you might have installed a patch 
        out of order. If patch says ` 
        <Literal remap="tt">
          previously applied patch detected: Assume -R? 
        </Literal>
        ', you are probably trying to apply a patch which is below your 
        current version number; if you answer ` 
        <Literal remap="tt">
          y 
        </Literal>
        ', it will attempt to degrade your source, and will most likely fail; 
        thus, you will need to get a whole new source tree (which might not 
        have been such a bad idea in the first place). 
      </Para>
      <Para>
        To back out (unapply) a patch, use ` 
        <Literal remap="tt">
          patch -R 
        </Literal>
        ' on the original patch. 
      </Para>
      <Para>
        The best thing to do when patches really turn out wrong is to start 
        over again with a clean, out-of-the-box source tree (for example, from 
        one of the 
        <Literal remap="tt">
          linux-x.y.z.tar.gz 
        </Literal>
        files), and start again. 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        Getting rid of the .orig files 
      </Title>
      <Para>
        After just a few patches, the 
        <Literal remap="tt">
          .orig 
        </Literal>
        files will start to pile up. For example, one 1.1.51 tree I had was 
        once last cleaned out at 1.1.48. Removing the .orig files saved over a 
        half a meg. find . -name '*.orig' -exec rm -f {} ';' will take care of 
        it for you. Versions of 
        <Literal remap="tt">
          patch 
        </Literal>
        which use 
        <Literal remap="tt">
          &num; 
        </Literal>
        for rejects use a tilde instead of 
        <Literal remap="tt">
          .orig 
        </Literal>
        . 
      </Para>
      <Para>
        There are better ways to get rid of the 
        <Literal remap="tt">
          .orig 
        </Literal>
        files, which depend on GNU 
        <Literal remap="tt">
          xargs 
        </Literal>
        : find . -name '*.orig' | xargs rm or the ``quite secure but a little 
        more verbose'' method: find . -name '*.orig' -print0 | xargs --null rm 
        -- 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        Other patches 
      </Title>
      <Para>
        There are other patches (I'll call them ``nonstandard'') than the ones 
        Linus distributes. If you apply these, Linus' patches may not work 
        correctly and you'll have to either back them out, fix the source or 
        the patch, install a new source tree, or a combination of the above. 
        This can become very frustrating, so if you do not want to modify the 
        source (with the possibility of a very bad outcome), back out the 
        nonstandard patches before applying Linus', or just install a new 
        tree. Then, you can see if the nonstandard patches still work. If they 
        don't, you are either stuck with an old kernel, playing with the patch 
        or source to get it to work, or waiting (possibly begging) for a new 
        version of the patch to come out. 
      </Para>
      <Para>
        How common are the patches not in the standard distribution? You will 
        probably hear of them. I used to use the noblink patch for my virtual 
        consoles because I hate blinking cursors (This patch is (or at least 
        was) frequently updated for new kernel releases.). With most newer 
        device drivers being developed as loadable modules, though, the 
        frequecy of ``nonstandard'' patches is decreasing significantly. 
      </Para>
    </Sect2>
  </Sect1>
  <Sect1>
    <Title>
      Tips and tricks 
    </Title>
    <Sect2>
      <Title>
        Redirecting output of the make or patch commands 
      </Title>
      <Para>
        If you would like logs of what those ` 
        <Literal remap="tt">
          make 
        </Literal>
        ' or ` 
        <Literal remap="tt">
          patch 
        </Literal>
        ' commands did, you can redirect output to a file. First, find out 
        what shell you're running: ` 
        <Literal remap="tt">
          grep root /etc/passwd 
        </Literal>
        ' and look for something like ` 
        <Literal remap="tt">
          /bin/csh 
        </Literal>
        '. 
      </Para>
      <Para>
        If you use sh or bash, (command) 2&#62;&#38;1 | tee (output file) will 
        place a copy of 
        <Literal remap="tt">
          (command) 
        </Literal>
        's output in the file ` 
        <Literal remap="tt">
          (output file) 
        </Literal>
        '. 
      </Para>
      <Para>
        For csh or tcsh, use (command) |&#38; tee (output file) 
      </Para>
      <Para>
        For rc (Note: you probably do not use rc) it's (command) &#62;[2=1] | 
        tee (output file) 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        Conditional kernel install 
      </Title>
      <Para>
        Other than using floppy disks, there are several methods of testing 
        out a new kernel without touching the old one. Unlike many other Unix 
        flavors, LILO has the ability to boot a kernel from anywhere on the 
        disk (if you have a large (500 MB or above) disk, please read over the 
        LILO documentation on how this may cause problems). So, if you add 
        something similar to image = /usr/src/linux/arch/i386/boot/bzImage 
        label = new_kernel to the end of your LILO configuration file, you can 
        choose to run a newly compiled kernel without touching your old 
        <Literal remap="tt">
          /vmlinuz 
        </Literal>
        (after running 
        <Literal remap="tt">
          lilo 
        </Literal>
        , of course). The easiest way to tell LILO to boot a new kernel is to 
        press the shift key at bootup time (when it says 
        <Literal remap="tt">
          LILO 
        </Literal>
        on the screen, and nothing else), which gives you a prompt. At this 
        point, you can enter ` 
        <Literal remap="tt">
          new&lowbar;kernel 
        </Literal>
        ' to boot the new kernel. 
      </Para>
      <Para>
        If you wish to keep several different kernel source trees on your 
        system at the same time (this can take up a 
        <Emphasis remap="it">
          lot 
        </Emphasis>
        of disk space; be careful), the most common way is to name them 
        <Literal remap="tt">
          /usr/src/linux-x.y.z 
        </Literal>
        , where 
        <Literal remap="tt">
          x.y.z 
        </Literal>
        is the kernel version. You can then ``select'' a source tree with a 
        symbolic link; for example, ` 
        <Literal remap="tt">
          ln -sf linux-1.2.2 /usr/src/linux 
        </Literal>
        ' would make the 1.2.2 tree current. Before creating a symbolic link 
        like this, make certain that the last argument to 
        <Literal remap="tt">
          ln 
        </Literal>
        is not a real directory (old symbolic links are fine); the result will 
        not be what you expect. 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        Kernel updates 
      </Title>
      <Para>
        Russell Nelson ( 
        <Literal remap="tt">
          nelson@crynwr.com 
        </Literal>
        ) summarizes the changes in new kernel releases. These are short, and 
        you might like to look at them before an upgrade. They are available 
        with anonymous ftp from 
        <ULink URL="ftp://ftp.emlist.com">
          "ftp://ftp.emlist.com" 
        </ULink>
        in 
        <Literal remap="tt">
          pub/kchanges 
        </Literal>
        or through the URL 
        <ULink URL="http://www.crynwr.com/kchanges">
          "http://www.crynwr.com/kchanges" 
        </ULink>
      </Para>
    </Sect2>
  </Sect1>
  <Sect1>
    <Title>
      Linux Kernel Textbooks and Documents 
    </Title>
    <Para>
      Check the following books on "The Linux Kernel" at 
      <ItemizedList>
        <ListItem>
          <Para>
            Kernel book 
            <ULink URL="http://kernelbook.sourceforge.net">
              "http://kernelbook.sourceforge.net" 
            </ULink>
            and at 
            <ULink URL="http://sourceforge.net/projects/kernelbook">
              "http://sourceforge.net/projects/kernelbook" 
            </ULink>
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            Linux Kernel books 
            <ULink URL="http://www.tldp.org/guides.html">
              "http://www.tldp.org/guides.html" 
            </ULink>
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            FreeTech books 
            <ULink URL="http://www.tcfb.com/freetechbooks/booklinuxdev.html">
              "http://www.tcfb.com/freetechbooks/booklinuxdev.html" 
            </ULink>
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            Rusty's 
            <ULink URL="http://www.netfilter.org/unreliable-guides">
              "http://www.netfilter.org/unreliable-guides" 
            </ULink>
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            Linux Kernel links 
            <ULink URL="http://www.topology.org/soft/lkernel.html">
              "http://www.topology.org/soft/lkernel.html" 
            </ULink>
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            Linux Kernel Internals 
            <ULink URL="http://www.moses.uklinux.net/patches/lki.html">
              "http://www.moses.uklinux.net/patches/lki.html" 
            </ULink>
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            Books links 
            <ULink URL="http://linux-mm.org/kernel-links.shtml">
              "http://linux-mm.org/kernel-links.shtml" 
            </ULink>
          </Para>
        </ListItem>
      </ItemizedList>
    </Para>
    <Para>
      Refer also to other relevant HOWTOs at: 
      <ItemizedList>
        <ListItem>
          <Para>
            Sound-HOWTO: sound cards and utilities 
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            SCSI-HOWTO: all about SCSI controllers and devices 
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            NET-2-HOWTO: networking 
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            PPP-HOWTO: PPP networking in particular 
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            PCMCIA-HOWTO: about the drivers for your notebook 
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            ELF-HOWTO: ELF: what it is, converting.. 
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            Hardware-HOWTO: overview of supported hardware 
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            Module mini-HOWTO: more on kernel modules 
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            Kerneld mini-HOWTO: about kerneld 
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            BogoMips mini-HOWTO: in case you were wondering 
          </Para>
        </ListItem>
      </ItemizedList>
    </Para>
  </Sect1>
  <Sect1 id="kernelinfo">
    <Title>
      Kernel Files Information 
    </Title>
    <Para>
      This section gives a "very brief" and "introduction" to some of the 
      Linux Kernel System. If you have time you can give one reading. 
    </Para>
    <Sect2 id="vmlinuz">
      <Title>
        vmlinuz and vmlinux 
      </Title>
      <Para>
        The vmlinuz is the Linux kernel executable. This is located at 
        /boot/vmlinuz. This can be a soft link to something like 
        /boot/vmlinuz-2.4.18-19.8.0 
      </Para>
      <Para>
        The vmlinux is the uncompressed built kernel, vmlinuz is the 
        compressed one, that has been made bootable. (Note both names vmlinux 
        and vmlinuz look same except for last letter z). Generally, you don't 
        need to worry about vmlinux, it is just an intermediate step. 
      </Para>
      <Para>
        The kernel usually makes a bzImage, and stores it in arch/i386/boot, 
        and it is up to the user to copy it to /boot and configure GRUB or 
        LILO. 
      </Para>
    </Sect2>
    <Sect2 id="bootload">
      <Title>
        Bootloader Files 
      </Title>
      <Para>
        <ProgramListing>
	ls -l /boot/*.b
	-rw-r--r--    1 root     root         5824 Sep  5  2002 /boot/boot.b
	-rw-r--r--    1 root     root          612 Sep  5  2002 /boot/chain.b
	-rw-r--r--    1 root     root          640 Sep  5  2002 /boot/os2_d.b
        </ProgramListing>
        the .b files are "bootloader" files. they are part of the dance 
        required to get a kernel into memory to begin with. You should NOT 
        touch them. 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        Message File 
      </Title>
      <Para>
        <ProgramListing>
	ls -l /boot/message*
	-rw-r--r--    1 root     root        23108 Sep  6  2002 /boot/message
	-rw-r--r--    1 root     root        21282 Sep  6  2002 /boot/message.ja
        </ProgramListing>
        The 'message' file contains the message your bootloader will display, 
        prompting you to choose an OS. So DO NOT touch it. 
      </Para>
    </Sect2>
    <Sect2 id="initrdimg">
      <Title>
        initrd.img 
      </Title>
      <Para>
        See the Appendix A at 
        <XRef LinkEnd="createinitrd">
        . 
      </Para>
    </Sect2>
    <Sect2 id="bzImagelbl">
      <Title>
        bzImage 
      </Title>
      <Para>
        The bzImage is the compressed kernel image created with command 'make 
        bzImage' during kernel compile. 
      </Para>
    </Sect2>
    <Sect2 id="moduleinfo">
      <Title>
        module-info 
      </Title>
      <Para>
        This file 'module-info' is created by anaconda/utils/modlist (specific 
        to Redhat Linux Anaconda installer). Other Linux distributions may be 
        having equivalent command. 
      </Para>
      <Para>
        See this script and search for "module-info" 
        <ULink URL="http://www.mit.edu/afs/sipb/system/rhlinux/redhat-6.2/misc/src/trees/updmodules">
          updmodules 
        </ULink>
        . 
      </Para>
      <Para>
        Below is a cut from this script: 
        <ProgramListing>
	#!/bin/bash
	# updmodules.sh
		MODLIST=$PWD/../anaconda/utils/modlist
	-- snip cut 
	blah blah blah 
	-- snip cut 
	    # create the module-info file
	    $MODLIST --modinfo-file $MODINFO --ignore-missing --modinfo \
			$(ls *.o | sed 's/\.o$//') &#62; ../modinfo
        </ProgramListing>
      </Para>
      <Para>
        The program anaconda/utils/modlist is located in anaconda-runtime*.rpm 
        on the Redhat CDROM 
        <ProgramListing>
	cd /mnt/cdrom/RedHat/RPMS
	rpm -i anaconda-8.0-4.i386.rpm
	rpm -i anaconda-runtime-8.0-4.i386.rpm
	ls -l /usr/lib/anaconda-runtime/modlist
        </ProgramListing>
        Get the source code for anaconda/utils/modlist.c from 
        anaconda*.src.rpm at 
        <ULink URL="http://www.rpmfind.net/linux/rpm2html/search.php?query=anaconda">
          "http://www.rpmfind.net/linux/rpm2html/search.php?query=anaconda" 
        </ULink>
        . 
      </Para>
      <Para>
        The file 'module-info' is generated during the compile. It is an 
        information file that is at least used during filing proper kernel 
        OOPS reports. It is a list of the module entry points. It may also be 
        used by depmod in building the tables that are used by insmod and its 
        kith and kin. This includes dependancy information for other modules 
        needed to be loaded before any other given module, etc. "Don't remove 
        it." 
      </Para>
      <Para>
        Some points about module-info: 
        <ItemizedList>
          <ListItem>
            <Para>
              Is provided by the kernel rpms (built by anaconda-runtime*.rpm) 
            </Para>
          </ListItem>
          <ListItem>
            <Para>
              Is a link to module-info-&lcub;kernel-version&rcub; 
            </Para>
          </ListItem>
          <ListItem>
            <Para>
              Contains information about all available modules (at least those 
              included in the default kernel config.) 
            </Para>
          </ListItem>
          <ListItem>
            <Para>
              Important to anaconda - in anaconda/utils/modlist command. 
            </Para>
          </ListItem>
          <ListItem>
            <Para>
              Might be used by kudzu to determine default parameters for 
              modules when it creates entries in /etc/modules.conf. If you 
              move module-info out of the way, shut down, install a new 
              network card, and re-boot then kudzu would complain loudly. Look 
              at the kudzu source code. 
            </Para>
          </ListItem>
        </ItemizedList>
      </Para>
    </Sect2>
    <Sect2 id="configfiles">
      <Title>
        config 
      </Title>
      <Para>
        Everytime you compile and install the kernel image in /boot, you 
        should also copy the corresponding config file to /boot area, for 
        documentation and future reference. Do NOT touch or edit these files!! 
        <ProgramListing>
	ls -l /boot/config-*
	-rw-r--r--    1 root     root        42111 Sep  4  2002 /boot/config-2.4.18-14
	-rw-r--r--    1 root     root        42328 Jan 26 01:29 /boot/config-2.4.18-19.8.0
	-rw-r--r--    1 root     root        51426 Jan 25 22:21 /boot/config-2.4.18-19.8.0BOOT
	-rw-r--r--    1 root     root        52328 Jan 28 03:22 /boot/config-2.4.18-19.8.0-26mar2003
        </ProgramListing>
      </Para>
    </Sect2>
    <Sect2 id="grubdir">
      <Title>
        grub 
      </Title>
      <Para>
        If you are using GRUB, then there will be 'grub' directory. 
        <ProgramListing>
	ls /boot/grub
	device.map     ffs_stage1_5  menu.lst        reiserfs_stage1_5  stage2
	e2fs_stage1_5  grub.conf     minix_stage1_5  splash.xpm.gz      vstafs_stage1_5
	fat_stage1_5   jfs_stage1_5  stage1          xfs_stage1_5
        </ProgramListing>
        See also 
        <XRef LinkEnd="grubconf">
        file. 
      </Para>
    </Sect2>
    <Sect2 id="systemmap">
      <Title>
        System.map 
      </Title>
      <Para>
        System.map is a "phone directory" list of function in a particular 
        build of a kernel. It is typically a symlink to the System.map of the 
        currently running kernel. If you use the wrong (or no) System.map, 
        debugging crashes is harder, but has no other effects. Without 
        System.map, you may face minor annoyance messages. 
      </Para>
      <Para>
        Do NOT touch the System.map files. 
        <ProgramListing>
	ls -ld /boot/System.map*
	lrwxrwxrwx    1 root     root           30 Jan 26 19:26 /boot/System.map -&#62; System.map-2.4.18-19.8.0custom
	-rw-r--r--    1 root     root       501166 Sep  4  2002 /boot/System.map-2.4.18-14
	-rw-r--r--    1 root     root       510786 Jan 26 01:29 /boot/System.map-2.4.18-19.8.0
	-rw-r--r--    1 root     root       331213 Jan 25 22:21 /boot/System.map-2.4.18-19.8.0BOOT
	-rw-r--r--    1 root     root       503246 Jan 26 19:26 /boot/System.map-2.4.18-19.8.0custom
        </ProgramListing>
      </Para>
      <Para>
        <Emphasis remap="bf">
          How The Kernel Symbol Table Is Created ? 
        </Emphasis>
        System.map is produced by 'nm vmlinux' and irrelevant or uninteresting 
        symbols are grepped out, When you compile the kernel, this file 
        'System.map' is created at /usr/src/linux/System.map. Something like 
        below: 
        <ProgramListing>
	nm /boot/vmlinux-2.4.18-19.8.0 &#62; System.map
	# Below is the line from /usr/src/linux/Makefile 
	nm vmlinux | grep -v '\(compiled\)\|\(\.o$$\)\|\( [aUw] \)\|\(\.\.ng$$\)\|\(LASH[RL]DI\)' | sort &#62; System.map
	cp /usr/src/linux/System.map /boot/System.map-2.4.18-14   # For v2.4.18
        </ProgramListing>
      </Para>
      <Para>
        From 
        <ULink URL="http://www.dirac.org/linux/systemmap.html">
          "http://www.dirac.org/linux/systemmap.html" 
        </ULink>
      </Para>
      <Sect3>
        <Title>
          System.map 
        </Title>
        <Para>
          There seems to be a dearth of information about the System.map file. 
          It's really nothing mysterious, and in the scheme of things, it's 
          really not that important. But a lack of documentation makes it 
          shady. It's like an earlobe; we all have one, but nobody really 
          knows why. This is a little web page I cooked up that explains the 
          why. 
        </Para>
        <Para>
          Note, I'm not out to be 100&percnt; correct. For instance, it's 
          possible for a system to not have /proc filesystem support, but most 
          systems do. I'm going to assume you "go with the flow" and have a 
          fairly typical system. 
        </Para>
        <Para>
          Some of the stuff on oopses comes from Alessandro Rubini's "Linux 
          Device Drivers" which is where I learned most of what I know about 
          kernel programming. 
        </Para>
      </Sect3>
      <Sect3>
        <Title>
          What Are Symbols? 
        </Title>
        <Para>
          In the context of programming, a symbol is the building block of a 
          program: it is a variable name or a function name. It should be of 
          no surprise that the kernel has symbols, just like the programs you 
          write. The difference is, of course, that the kernel is a very 
          complicated piece of coding and has many, many global symbols. 
        </Para>
      </Sect3>
      <Sect3>
        <Title>
          What Is The Kernel Symbol Table? 
        </Title>
        <Para>
          The kernel doesn't use symbol names. It's much happier knowing a 
          variable or function name by the variable or function's address. 
          Rather than using size&lowbar;t BytesRead, the kernel prefers to 
          refer to this variable as (for example) c0343f20. 
        </Para>
        <Para>
          Humans, on the other hand, do not appreciate names like c0343f20. We 
          prefer to use something like size&lowbar;t BytesRead. Normally, this 
          doesn't present much of a problem. The kernel is mainly written in 
          C, so the compiler/linker allows us to use symbol names when we code 
          and allows the kernel to use addresses when it runs. Everyone is 
          happy. 
        </Para>
        <Para>
          There are situations, however, where we need to know the address of 
          a symbol (or the symbol for an address). This is done by a symbol 
          table, and is very similar to how gdb can give you the function name 
          from a address (or an address from a function name). A symbol table 
          is a listing of all symbols along with their address. Here is an 
          example of a symbol table: 
        </Para>
        <Para>
          <ProgramListing>
	   c03441a0 B dmi_broken
	   c03441a4 B is_sony_vaio_laptop
	   c03441c0 b dmi_ident
	   c0344200 b pci_bios_present
	   c0344204 b pirq_table
	   c0344208 b pirq_router
	   c034420c b pirq_router_dev
	   c0344220 b ascii_buffer
	   c0344224 b ascii_buf_bytes
          </ProgramListing>
        </Para>
        <Para>
          You can see that the variable named dmi&lowbar;broken is at the 
          kernel address c03441a0. 
        </Para>
      </Sect3>
      <Sect3>
        <Title>
          What Is The System.map File? 
        </Title>
        <Para>
          There are 2 files that are used as a symbol table: 
          <OrderedList>
            <ListItem>
              <Para>
                /proc/ksyms 
              </Para>
            </ListItem>
            <ListItem>
              <Para>
                System.map 
              </Para>
            </ListItem>
          </OrderedList>
        </Para>
        <Para>
          There. You now know what the System.map file is. 
        </Para>
        <Para>
          Every time you compile a new kernel, the addresses of various symbol 
          names are bound to change. 
        </Para>
        <Para>
          /proc/ksyms is a "proc file" and is created on the fly when a kernel 
          boots up. Actually, it's not really a file; it's simply a 
          representation of kernel data which is given the illusion of being a 
          disk file. If you don't believe me, try finding the filesize of 
          /proc/ksyms. Therefore, it will always be correct for the kernel 
          that is currently running.. 
        </Para>
        <Para>
          However, System.map is an actual file on your filesystem. When you 
          compile a new kernel, your old System.map has wrong symbol 
          information. A new System.map is generated with each kernel compile 
          and you need to replace the old copy with your new copy. 
        </Para>
      </Sect3>
      <Sect3>
        <Title>
          What Is An Oops? 
        </Title>
        <Para>
          What is the most common bug in your homebrewed programs? The 
          segfault. Good ol' signal 11. 
        </Para>
        <Para>
          What is the most common bug in the Linux kernel? The segfault. 
          Except here, the notion of a segfault is much more complicated and 
          can be, as you can imagine, much more serious. When the kernel 
          dereferences an invalid pointer, it's not called a segfault -- it's 
          called an "oops". An oops indicates a kernel bug and should always 
          be reported and fixed. 
        </Para>
        <Para>
          Note that an oops is not the same thing as a segfault. Your program 
          cannot recover from a segfault. The kernel doesn't necessarily have 
          to be in an unstable state when an oops occurs. The Linux kernel is 
          very robust; the oops may just kill the current process and leave 
          the rest of the kernel in a good, solid state. 
        </Para>
        <Para>
          An oops is not a kernel panic. In a panic, the kernel cannot 
          continue; the system grinds to a halt and must be restarted. An oops 
          may cause a panic if a vital part of the system is destroyed. An 
          oops in a device driver, for example, will almost never cause a 
          panic. 
        </Para>
        <Para>
          When an oops occurs, the system will print out information that is 
          relevent to debugging the problem, like the contents of all the CPU 
          registers, and the location of page descriptor tables. In 
          particular, the contents of the EIP (instruction pointer) is 
          printed. Like this: 
          <ProgramListing>
	   EIP: 0010:[&#60;00000000&#62;]
	   Call Trace: [&#60;c010b860&#62;]
          </ProgramListing>
        </Para>
      </Sect3>
      <Sect3>
        <Title>
          What Does An Oops Have To Do With System.map? 
        </Title>
        <Para>
          You can agree that the information given in EIP and Call Trace is 
          not very informative. But more importantly, it's really not 
          informative to a kernel developer either. Since a symbol doesn't 
          have a fixed address, c010b860 can point anywhere. 
        </Para>
        <Para>
          To help us use this cryptic oops output, Linux uses a daemon called 
          klogd, the kernel logging daemon. klogd intercepts kernel oopses and 
          logs them with syslogd, changing some of the useless information 
          like c010b860 with information that humans can use. In other words, 
          klogd is a kernel message logger which can perform name-address 
          resolution. Once klogd tranforms the kernel message, it uses 
          whatever logger is in place to log system wide messages, usually 
          syslogd. 
        </Para>
        <Para>
          To perform name-address resolution, klogd uses System.map. Now you 
          know what an oops has to do with System.map. 
        </Para>
        <Para>
          <Emphasis remap="bf">
            Fine print: 
          </Emphasis>
          There are actually two types of address resolution are performed by 
          klogd. 
        </Para>
        <Para>
          <ItemizedList>
            <ListItem>
              <Para>
                Static translation, which uses the System.map file. 
              </Para>
            </ListItem>
            <ListItem>
              <Para>
                Dynamic translation which is used with loadable modules, 
                doesn't use 
              </Para>
            </ListItem>
          </ItemizedList>
        </Para>
        <Para>
          System.map and is therefore not relevant to this discussion, but 
          I'll describe it briefly anyhow. 
        </Para>
        <Para>
          <Emphasis remap="bf">
            Klogd Dynamic Translation 
          </Emphasis>
        </Para>
        <Para>
          Suppose you load a kernel module which generates an oops. An oops 
          message is generated, and klogd intercepts it. It is found that the 
          oops occured at d00cf810. Since this address belongs to a 
          dynamically loaded module, it has no entry in the System.map file. 
          klogd will search for it, find nothing, and conclude that a loadable 
          module must have generated the oops. klogd then queries the kernel 
          for symbols that were exported by loadable modules. Even if the 
          module author didn't export his symbols, at the very least, klogd 
          will know what module generated the oops, which is better than 
          knowing nothing about the oops at all. 
        </Para>
        <Para>
          There's other software that uses System.map, and I'll get into that 
          shortly. 
        </Para>
      </Sect3>
      <Sect3>
        <Title>
          Where Should System.map Be Located? 
        </Title>
        <Para>
          System.map should be located wherever the software that uses it 
          looks for it. That being said, let me talk about where klogd looks 
          for it. Upon bootup, if klogd isn't given the location of System.map 
          as an argument, it will look for System.map in 3 places, in the 
          following order: 
          <OrderedList>
            <ListItem>
              <Para>
                /boot/System.map 
              </Para>
            </ListItem>
            <ListItem>
              <Para>
                /System.map 
              </Para>
            </ListItem>
            <ListItem>
              <Para>
                /usr/src/linux/System.map 
              </Para>
            </ListItem>
          </OrderedList>
        </Para>
        <Para>
          System.map also has versioning information, and klogd intelligently 
          searches for the correct map file. For instance, suppose you're 
          running kernel 2.4.18 and the associated map file is 
          /boot/System.map. You now compile a new kernel 2.5.1 in the tree 
          /usr/src/linux. During the compiling process, the file 
          /usr/src/linux/System.map is created. When you boot your new kernel, 
          klogd will first look at /boot/System.map, determine it's not the 
          correct map file for the booting kernel, then look at 
          /usr/src/linux/System.map, determine that it is the correct map file 
          for the booting kernel and start reading the symbols. 
        </Para>
        <Para>
          A few nota bene's: 
        </Para>
        <Para>
          <ItemizedList>
            <ListItem>
              <Para>
                Somewhere during the 2.5.x series, the Linux kernel started to 
                untar into linux-version, rather than just linux (show of 
                hands -- how many people have been waiting for this to 
                happen?). I don't know if klogd has been modified to search in 
                /usr/src/linux-version/System.map yet. TODO: Look at the klogd 
                srouce. If someone beats me to it, please email me and let me 
                know if klogd has been modified to look in the new directory 
                name for the linux source code. 
              </Para>
            </ListItem>
            <ListItem>
              <Para>
                The man page doesn't tell the whole the story. Look at this: 
              </Para>
            </ListItem>
          </ItemizedList>
        </Para>
        <Para>
          <ProgramListing>
	   # strace -f /sbin/klogd | grep 'System.map'
	   31208 open("/boot/System.map-2.4.18", O_RDONLY|O_LARGEFILE) = 2
          </ProgramListing>
        </Para>
        <Para>
          Apparently, not only does klogd look for the correct version of the 
          map in the 3 klogd search directories, but klogd also knows to look 
          for the name "System.map" followed by "-kernelversion", like 
          System.map-2.4.18. This is undocumented feature of klogd. 
        </Para>
        <Para>
          A few drivers will need System.map to resolve symbols (since they're 
          linked against the kernel headers instead of, say, glibc). They will 
          not work correctly without the System.map created for the particular 
          kernel you're currently running. This is NOT the same thing as a 
          module not loading because of a kernel version mismatch. That has to 
          do with the kernel version, not the kernel symbol table which 
          changes between kernels of the same version! 
        </Para>
      </Sect3>
      <Sect3>
        <Title>
          What else uses the System.map 
        </Title>
        <Para>
          Don't think that System.map is only useful for kernel oopses. 
          Although the kernel itself doesn't really use System.map, other 
          programs such as klogd, lsof, 
        </Para>
        <Para>
          <ProgramListing>
	   satan# strace lsof 2&#62;&#38;1 1&#62; /dev/null | grep System
	   readlink("/proc/22711/fd/4", "/boot/System.map-2.4.18", 4095) = 23
          </ProgramListing>
        </Para>
        <Para>
          and ps : 
        </Para>
        <Para>
          <ProgramListing>
	   satan# strace ps 2&#62;&#38;1 1&#62; /dev/null | grep System
	   open("/boot/System.map-2.4.18", O_RDONLY|O_NONBLOCK|O_NOCTTY) = 6
          </ProgramListing>
        </Para>
        <Para>
          and many other pieces of software like dosemu require a correct 
          System.map. 
        </Para>
      </Sect3>
      <Sect3>
        <Title>
          What Happens If I Don't Have A Healthy System.map? 
        </Title>
        <Para>
          Suppose you have multiple kernels on the same machine. You need a 
          separate System.map files for each kernel! If boot a kernel that 
          doesn't have a System.map file, you'll periodically see a message 
          like: System.map does not match actual kernel Not a fatal error, but 
          can be annoying to see everytime you do a ps ax. Some software, like 
          dosemu, may not work correctly (although I don't know of anything 
          off the top of my head). Lastly, your klogd or ksymoops output will 
          not be reliable in case of a kernel oops. 
        </Para>
      </Sect3>
      <Sect3>
        <Title>
          How Do I Remedy The Above Situation? 
        </Title>
        <Para>
          The solution is to keep all your System.map files in /boot and 
          rename them with the kernel version. Suppose you have multiple 
          kernels like: 
        </Para>
        <Para>
          <ItemizedList>
            <ListItem>
              <Para>
                /boot/vmlinuz-2.2.14 
              </Para>
            </ListItem>
            <ListItem>
              <Para>
                /boot/vmlinuz-2.2.13 
              </Para>
            </ListItem>
          </ItemizedList>
        </Para>
        <Para>
          Then just rename your map files according to the kernel version and 
          put them in /boot, like: 
          <ProgramListing>
	   /boot/System.map-2.2.14
	   /boot/System.map-2.2.13
          </ProgramListing>
        </Para>
        <Para>
          Now what if you have two copies of the same kernel? Like: 
          <ItemizedList>
            <ListItem>
              <Para>
                /boot/vmlinuz-2.2.14 
              </Para>
            </ListItem>
            <ListItem>
              <Para>
                /boot/vmlinuz-2.2.14.nosound 
              </Para>
            </ListItem>
          </ItemizedList>
        </Para>
        <Para>
          The best answer would be if all software looked for the following 
          files: 
          <ProgramListing>
	   /boot/System.map-2.2.14
	   /boot/System.map-2.2.14.nosound
          </ProgramListing>
        </Para>
        <Para>
          You can also use symlinks: 
          <ProgramListing>
	   System.map-2.2.14
	   System.map-2.2.14.sound
	   ln -s System.map-2.2.14.sound System.map     # Here System.map -&#62; System.map-2.2.14.sound
          </ProgramListing>
        </Para>
      </Sect3>
    </Sect2>
  </Sect1>
  <Sect1 id="ftpfs">
    <Title>
      Mount RPMs With FTPFS 
    </Title>
    <Para>
      By this time, your kernel is compiled and running ok. You will have the 
      need to access countless number of RPMs which you may need to install in 
      near future. One way is to physically mount the Linux CDROMS, but there 
      are more than 3 Linux cdroms and it is cumbersome to remove and change 
      the Linux cdroms. Hence, here comes the FTPFS. 
    </Para>
    <Para>
      FTP File System is a Linux kernel module, enhancing the VFS with FTP 
      volume mounting capabilities. That is, you can "mount" FTP shared 
      directories in your very personal file system and take advantage of 
      local files ops. It is at 
      <ULink URL="http://lufs.sourceforge.net/lufs">
        "http://lufs.sourceforge.net/lufs" 
      </ULink>
      and at 
      <ULink URL="http://ftpfs.sourceforge.net">
        "http://ftpfs.sourceforge.net" 
      </ULink>
      . 
    </Para>
    <Sect2>
      <Title>
        Using the ftpfs 
      </Title>
      <Para>
        Download the ftpfs and install it on your system. The ftpfs is 
        installed as a module in 
        /lib/modules/2.4.18-19.8.0/kernel/fs/ftpfs/ftpfs.o. And also the 
        command ftpmount is in /usr/bin/ftpmount. And you can do the 
        following: 
      </Para>
      <Para>
        Login as root (su - root) and run this script: 
        <ProgramListing>
	#!/bin/sh -x
	# Use this script to mount ftp redhat cdroms rpms directory disk1,2,3
	# Built rpm by name ftpfs.
	# http://lufs.sourceforge.net/main/projects.html
	# ftpmount --help
	# Try this: ftpmount [user[:pass]@]host_name[:port][/root_dir] mount_point [-o]
	# [-uid=id] [gid=id] [fmask=mask] [dmask=mask]
	#ftpmount anonymous:pass@ftp.kernel.org /mnt/ftpfs
	#mkdir -p /mnt/ftpfs /mnt/ftpfs/updates /mnt/ftpfs/rpms /mnt/ftpfs/contrib
	# Redhat ftp mirror sites - http://www.redhat.com/download/mirror.html
	FTPSITE="csociety-ftp.ecn.purdue.edu"
	USER="anonymous:pass"
	ftpmount $USER@$FTPSITE/pub/redhat/redhat  /mnt/ftpfs/site
	ftpmount $USER@$FTPSITE/pub/redhat/redhat/linux/updates/8.0/en/os  /mnt/ftpfs/updates
	ftpmount $USER@$FTPSITE/pub/redhat/redhat/linux/8.0/en/os/i386/RedHat /mnt/ftpfs/rpms
	ftpmount $USER@$FTPSITE/pub/redhat-contrib /mnt/ftpfs/contrib
        </ProgramListing>
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        The ftpfs Commands 
      </Title>
      <Para>
        Before you even start thinking about mounting FTP volumes, make sure 
        you have a decent bandwidth or it's gonna suck. 
      </Para>
      <Sect3>
        <Title>
          The autofs way - A must try! 
        </Title>
        <Para>
          If you were wise enough to install the autofs/automount bridge 
          (check out the installation notes) there is a cool way to use ftpfs: 
          just try to access any file/dir on the desired server under 
          /mnt/ftpfs. 
          <ProgramListing>
	cd /mnt/ftpfs/[user:pass@]ftp_server[:port]
          </ProgramListing>
        </Para>
        <Para>
          Something like cd /mnt/ftpfs/ftp.kernel.org. And guess what? You're 
          there! 
        </Para>
        <Para>
          Normally you will only use this for anonymous ftp since you don't 
          want your user/pass info to show up in the /mnt/ftpfs/ tree. 
        </Para>
      </Sect3>
      <Sect3>
        <Title>
          The ftpmount way 
        </Title>
        <Para>
          <Emphasis remap="bf">
            ftpmount &lsqb;user&lsqb;:password]@]hostname&lsqb;:port 
            ]&lsqb;/root&lowbar;dir] mount&lowbar;point &lsqb;-own] 
            &lsqb;-uid=id] &lsqb;-gid=id] &lsqb;-fmask=mask] 
            &lsqb;-dmask=mask] &lsqb;-active] 
          </Emphasis>
        </Para>
        <Para>
          <ProgramListing>
	The parameters: [defaults]
	    * user: The user to be used for logging on the FTP server. [anonymous]
	    * password: The password for that user. [user@ftpfs.sourceforge.net]
	    * hostname: The FTP server.
	    * port: The port the server is listening on. [21]
	    * root_dir: The directory on the FTP server you want to be mounted. This should be specified without the trailing slash (that is "/home/duru", not "/home/duru/"). [/]
	    * mount_point: The local directory you want to mount the FTP server onto.
	    * own: Flag to force ownership on all remote files. Useful for FTP servers that list user IDs instead of user names.
	    * uid: The local user ID you want to be the owner of the mounted tree.
	    * gid: The local group ID you want to own the mounted tree.
	    * fmask: The numeric mode to be ORed on all mounted files.
	    * dmask: The numeric mode to be ORed on all mounted dirs.
	    * active: Flag to enable active mode for FTP transfers. Useful if you're behind some firewall and cannot connect to random ports.
          </ProgramListing>
        </Para>
        <Para>
          Eg: ftpmount mali@ftp.linuxnet.wox.org /mnt/ftpfs -uid=500 -gid=500 
          -dmask=555 
        </Para>
        <Para>
          It is generally a good idea not to provide your password as a 
          parameter, since ftpmount will ask for it. 
        </Para>
      </Sect3>
      <Sect3>
        <Title>
          The mount way 
        </Title>
        <Para>
          If for some reason you choose not to use ftpmount (you probably 
          installed the kernel patch and are too lazy to install ftpmount 
          too), here's the way to use good-ol mount: 
        </Para>
        <Para>
          <Emphasis remap="bf">
            mount -n -t ftpfs none mount&lowbar;point -o ip=server&lowbar;ip 
            &lsqb;,user=user&lowbar;name] &lsqb;,pass=password] 
            &lsqb;,port=server&lowbar;port] &lsqb;,root= root&lowbar;dir] 
            &lsqb;,own] &lsqb;,uid=id] &lsqb;,gid=id] &lsqb;,fmode=mask] 
            &lsqb;,dmode=mask] &lsqb;,active] 
          </Emphasis>
        </Para>
        <Para>
          Please note that you have to provide the server's IP and that the 
          only way to enter a password is in clear. For example, while 
          testing, I used the following command: 
        </Para>
        <Para>
          mount -n -t ftpfs none /mnt/ftpfs -o 
          ip=127.0.0.1,user=mali,pass=my&lowbar;pass 
        </Para>
      </Sect3>
      <Sect3>
        <Title>
          Some notes 
        </Title>
        <Para>
          To unmount the volume, you go like 
          <ProgramListing>
	umount mount_point
          </ProgramListing>
        </Para>
        <Para>
          The own option (-o for ftpmount) forces ownership by the mounting 
          user on all files. This is useful for accommodating servers with 
          strange user/permissions management (SERVU &#38; stuff). 
        </Para>
        <Para>
          A few words of wisdom: 
          <ItemizedList>
            <ListItem>
              <Para>
                Use -n mount option! I bet you don't want your user/password 
                information listed in mtab. 
              </Para>
            </ListItem>
            <ListItem>
              <Para>
                Don't push it! (pushing it = a dozen processes reading on the 
                mount point) 
              </Para>
            </ListItem>
            <ListItem>
              <Para>
                It works best for one process! While concurrent access (under 
                normal circumstances) shouldn't cause any problem, the output 
                is optimized for one process reading (the TCP connection is 
                kept alive). So, if you're gonna watch a movie, you don't want 
                other processes to access the mount point and kill the 
                throughoutput (trust me!). 
              </Para>
            </ListItem>
            <ListItem>
              <Para>
                The address in IP format sucks! - Go get ftpmount. 
              </Para>
            </ListItem>
          </ItemizedList>
        </Para>
      </Sect3>
    </Sect2>
  </Sect1>
  <Sect1>
    <Title>
      Other Formats of this Document 
    </Title>
    <Para>
      This section is written by 
      <ULink URL="mailto:alavoor[AT]yahoo.com">
        Al Dev 
      </ULink>
      (at site 
      <ULink URL="http://www.milkywaygalaxy.freeservers.com">
        "http://www.milkywaygalaxy.freeservers.com" 
      </ULink>
      mirrors at 
      <ULink URL="http://www.angelfire.com/country/aldev0">
        angelfire 
      </ULink>
      , 
      <ULink URL="http://www.geocities.com/alavoor/index.html">
        geocities 
      </ULink>
      , 
      <ULink URL="http://aldev0.virtualave.net">
        virtualave 
      </ULink>
      , 
      <ULink URL="http://members.fortunecity.com/aldev">
        Fortunecity 
      </ULink>
      , 
      <ULink URL="http://aldev.freewebsites.com">
        Freewebsites 
      </ULink>
      , 
      <ULink URL="http://members.tripod.lycos.com/aldev">
        Tripod 
      </ULink>
      , 
      <ULink URL="http://www.101xs.com/101xs/aldev">
        101xs 
      </ULink>
      , 
      <ULink URL="http://aldev0.50megs.com">
        50megs 
      </ULink>
      ) 
    </Para>
    <Para>
      This document is published in 14 different formats namely - DVI, 
      Postscript, Latex, Adobe Acrobat PDF, LyX, GNU-info, HTML, RTF(Rich Text 
      Format), Plain-text, Unix man pages, single HTML file, SGML (Linuxdoc 
      format), SGML (Docbook format), MS WinHelp format. 
    </Para>
    <Para>
      This howto document is located at - 
      <ItemizedList>
        <ListItem>
          <Para>
            <ULink URL="http://www.linuxdoc.org">
              "http://www.linuxdoc.org" 
            </ULink>
            and click on HOWTOs and search for howto document name using 
            CTRL+f or ALT+f within the web-browser. 
          </Para>
        </ListItem>
      </ItemizedList>
    </Para>
    <Para>
      You can also find this document at the following mirrors sites - 
      <ItemizedList>
        <ListItem>
          <Para>
            <ULink URL="http://www.caldera.com/LDP/HOWTO">
              "http://www.caldera.com/LDP/HOWTO" 
            </ULink>
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            <ULink URL="http://www.linux.ucla.edu/LDP">
              "http://www.linux.ucla.edu/LDP" 
            </ULink>
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            <ULink URL="http://www.cc.gatech.edu/linux/LDP">
              "http://www.cc.gatech.edu/linux/LDP" 
            </ULink>
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            <ULink URL="http://www.redhat.com/mirrors/LDP">
              "http://www.redhat.com/mirrors/LDP" 
            </ULink>
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            Other mirror sites near you (network-address-wise) can be found at 
            <ULink URL="http://www.linuxdoc.org/mirrors.html">
              "http://www.linuxdoc.org/mirrors.html" 
            </ULink>
            select a site and go to directory /LDP/HOWTO/xxxxx-HOWTO.html 
          </Para>
        </ListItem>
      </ItemizedList>
    </Para>
    <Para>
      <ItemizedList>
        <ListItem>
          <Para>
            You can get this HOWTO document as a single file tar ball in HTML, 
            DVI, Postscript or SGML formats from - 
            <ULink URL="ftp://www.linuxdoc.org/pub/Linux/docs/HOWTO/other-formats/">
              "ftp://www.linuxdoc.org/pub/Linux/docs/HOWTO/other-formats/" 
            </ULink>
            and 
            <ULink URL="http://www.linuxdoc.org/docs.html#howto">
              "http://www.linuxdoc.org/docs.html#howto" 
            </ULink>
          </PARA>
        </ListItem>
        <ListItem>
          <Para>
            Plain text format is in: 
            <ULink URL="ftp://www.linuxdoc.org/pub/Linux/docs/HOWTO">
              "ftp://www.linuxdoc.org/pub/Linux/docs/HOWTO" 
            </ULink>
            and 
            <ULink URL="http://www.linuxdoc.org/docs.html#howto">
              "http://www.linuxdoc.org/docs.html#howto" 
            </ULink>
          </PARA>
        </ListItem>
        <ListItem>
          <Para>
            Single HTML file format is in: 
            <ULink URL="http://www.linuxdoc.org/docs.html#howto">
              "http://www.linuxdoc.org/docs.html#howto" 
            </ULink>
            <Para>
              Single HTML file can be created with command (see man sgml2html) 
              - sgml2html -split 0 xxxxhowto.sgml 
            </Para>

        </ListItem>
        <ListItem>
          <Para>
            Translations to other languages like French, German, Spanish, 
            Chinese, Japanese are in 
            <ULink URL="ftp://www.linuxdoc.org/pub/Linux/docs/HOWTO">
              "ftp://www.linuxdoc.org/pub/Linux/docs/HOWTO" 
            </ULink>
            and 
            <ULink URL="http://www.linuxdoc.org/docs.html#howto">
              "http://www.linuxdoc.org/docs.html#howto" 
            </ULink>
            Any help from you to translate to other languages is welcome. 
          </Para>
        </ListItem>
      </ItemizedList>
      The document is written using a tool called "SGML-Tools" which can be 
      got from - 
      <ULink URL="http://www.sgmltools.org">
        "http://www.sgmltools.org" 
      </ULink>
      Compiling the source you will get the following commands like 
      <ItemizedList>
        <ListItem>
          <Para>
            sgml2html xxxxhowto.sgml (to generate html file) 
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            sgml2html -split 0 xxxxhowto.sgml (to generate a single page html 
            file) 
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            sgml2rtf xxxxhowto.sgml (to generate RTF file) 
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            sgml2latex xxxxhowto.sgml (to generate latex file) 
          </Para>
        </ListItem>
      </ItemizedList>
    </Para>
    <Sect2 id="acrobatpdf">
      <Title>
        Acrobat PDF format 
      </Title>
      <Para>
        PDF file can be generated from postscript file using either acrobat 
        <Emphasis remap="bf">
          distill 
        </Emphasis>
        or 
        <Emphasis remap="bf">
          Ghostscript 
        </Emphasis>
        . And postscript file is generated from DVI which in turn is generated 
        from LaTex file. You can download distill software from 
        <ULink URL="http://www.adobe.com">
          "http://www.adobe.com" 
        </ULink>
        . Given below is a sample session: 
        <ProgramListing>
	bash$ man sgml2latex
	bash$ sgml2latex filename.sgml
	bash$ man dvips
	bash$ dvips -o filename.ps filename.dvi
	bash$ distill filename.ps
	bash$ man ghostscript
	bash$ man ps2pdf
	bash$ ps2pdf input.ps output.pdf
	bash$ acroread output.pdf &#38;
        </ProgramListing>
        Or you can use Ghostscript command 
        <Emphasis remap="bf">
          ps2pdf 
        </Emphasis>
        . ps2pdf is a work-alike for nearly all the functionality of Adobe's 
        Acrobat Distiller product: it converts PostScript files to Portable 
        Document Format (PDF) files. 
        <Emphasis remap="bf">
          ps2pdf 
        </Emphasis>
        is implemented as a very small command script (batch file) that 
        invokes Ghostscript, selecting a special "output device" called 
        <Emphasis remap="bf">
          pdfwrite 
        </Emphasis>
        . In order to use ps2pdf, the pdfwrite device must be included in the 
        makefile when Ghostscript was compiled; see the documentation on 
        building Ghostscript for details. 
      </Para>
    </Sect2>
    <Sect2 id="linuxdoc2docbook">
      <Title>
        Convert Linuxdoc to Docbook format 
      </Title>
      <Para>
        This document is written in linuxdoc SGML format. The Docbook SGML 
        format supercedes the linuxdoc format and has lot more features than 
        linuxdoc. The linuxdoc is very simple and is easy to use. To convert 
        linuxdoc SGML file to Docbook SGML use the program 
        <Emphasis remap="bf">
          ld2db.sh 
        </Emphasis>
        and some perl scripts. The ld2db output is not 100&percnt; clean and 
        you need to use the 
        <Emphasis remap="bf">
          clean&lowbar;ld2db.pl 
        </Emphasis>
        perl script. You may need to manually correct few lines in the 
        document. 
        <ItemizedList>
          <ListItem>
            <Para>
              Download ld2db program from 
              <ULink URL="http://www.dcs.gla.ac.uk/~rrt/docbook.html">
                "http://www.dcs.gla.ac.uk/~rrt/docbook.html" 
              </ULink>
              or from 
              <ULink URL="http://www.milkywaygalaxy.freeservers.com">
                Milkyway Galaxy site 
              </ULink>
            </Para>
          </ListItem>
          <ListItem>
            <Para>
              Download the cleanup&lowbar;ld2db.pl perl script from from 
              <ULink URL="http://www.milkywaygalaxy.freeservers.com">
                Milkyway Galaxy site 
              </ULink>
            </Para>
          </ListItem>
        </ItemizedList>
        The ld2db.sh is not 100&percnt; clean, you will get lot of errors when 
        you run 
        <ProgramListing>
		bash$ ld2db.sh file-linuxdoc.sgml db.sgml
		bash$ cleanup.pl db.sgml &#62; db_clean.sgml
		bash$ gvim db_clean.sgml 
		bash$ docbook2html db.sgml
        </ProgramListing>
        And you may have to manually edit some of the minor errors after 
        running the perl script. For e.g. you may need to put closing tag 
        &#60; /Para&#62; for each &#60; Listitem&#62; 
      </Para>
    </Sect2>
    <Sect2 id="mswinhelp">
      <Title>
        Convert to MS WinHelp format 
      </Title>
      <Para>
        You can convert the SGML howto document to Microsoft Windows Help 
        file, first convert the sgml to html using: 
        <ProgramListing>
		bash$ sgml2html xxxxhowto.sgml     (to generate html file)
		bash$ sgml2html -split 0   xxxxhowto.sgml (to generate a single page html file)
        </ProgramListing>
        Then use the tool 
        <ULink URL="http://javadocs.planetmirror.com/htmltohlpe.html">
          HtmlToHlp 
        </ULink>
        . You can also use sgml2rtf and then use the RTF files for generating 
        winhelp files. 
      </Para>
    </Sect2>
    <Sect2 id="readformats">
      <Title>
        Reading various formats 
      </Title>
      <Para>
        In order to view the document in dvi format, use the xdvi program. The 
        xdvi program is located in tetex-xdvi*.rpm package in Redhat Linux 
        which can be located through ControlPanel &verbar; Applications 
        &verbar; Publishing &verbar; TeX menu buttons. To read dvi document 
        give the command - 
        <Screen>
          xdvi -geometry 80x90 howto.dvi man xdvi 
        </Screen>
        And resize the window with mouse. To navigate use Arrow keys, Page Up, 
        Page Down keys, also you can use 'f', 'd', 'u', 'c', 'l', 'r', 'p', 
        'n' letter keys to move up, down, center, next page, previous page 
        etc. To turn off expert menu press 'x'. 
      </Para>
      <Para>
        You can read postscript file using the program 'gv' (ghostview) or 
        'ghostscript'. The ghostscript program is in ghostscript*.rpm package 
        and gv program is in gv*.rpm package in Redhat Linux which can be 
        located through ControlPanel &verbar; Applications &verbar; Graphics 
        menu buttons. The gv program is much more user friendly than 
        ghostscript. Also ghostscript and gv are available on other platforms 
        like OS/2, Windows 95 and NT, you view this document even on those 
        platforms. 
      </Para>
      <Para>
        <ItemizedList>
          <ListItem>
            <Para>
              Get ghostscript for Windows 95, OS/2, and for all OSes from 
              <ULink URL="http://www.cs.wisc.edu/~ghost">
                "http://www.cs.wisc.edu/~ghost" 
              </ULink>
            </Para>
          </ListItem>
        </ItemizedList>
      </Para>
      <Para>
        To read postscript document give the command - 
        <Screen>
          gv howto.ps ghostscript howto.ps 
        </Screen>
      </Para>
      <Para>
        You can read HTML format document using Netscape Navigator, Microsoft 
        Internet explorer, Redhat Baron Web browser or any of the 10 other web 
        browsers. 
      </Para>
      <Para>
        You can read the latex, LyX output using LyX a X-Windows front end to 
        latex. 
      </Para>
    </Sect2>
  </Sect1>
  <Sect1 id="createinitrd">
    <Title>
      Appendix A - Creating initrd.img file 
    </Title>
    <Para>
      The 
      <Emphasis remap="bf">
        initrd 
      </Emphasis>
      is the "initial ramdisk". It is enough files stored in a ramdisk to 
      store needed drivers . You need the drivers so that the kernel can mount 
      / and kick off init. 
    </Para>
    <Para>
      You can avoid this if you build your scsi drivers right into the kernel, 
      instead of into modules. (Many persons recommend this). 
    </Para>
    <Sect2>
      <Title>
        Using mkinitrd 
      </Title>
      <Para>
        The mkinitrd utility creates an initrd image in a single command. This 
        is command is peculiar to RedHat. There may be equivalent command of 
        mkinitrd in other distributions of Linux. This is very convenient 
        utility. 
      </Para>
      <Para>
        You can read the mkinitrd man page. 
      </Para>
      <Para>
        <ProgramListing>
	/sbin/mkinitrd --help   # Or simply type 'mkinitrd --help'
	usage: mkinitrd [--version] [-v] [-f] [--preload &#60;module&#62;]
	       [--omit-scsi-modules] [--omit-raid-modules] [--omit-lvm-modules]
	       [--with=&#60;module&#62;] [--image-version] [--fstab=&#60;fstab&#62;] [--nocompress]
	       [--builtin=&#60;module&#62;] [--nopivot] &#60;initrd-image&#62; &#60;kernel-version&#62;
	       (example: mkinitrd /boot/initrd-2.2.5-15.img 2.2.5-15)
	# Read the online manual page with .....
	man mkinitrd
	su - root
	# The command below creates the initrd image file
	mkinitrd  ./initrd-2.4.18-19.8.0custom.img   2.4.18-19.8.0custom
	ls -l initrd-2.4.18-19.8.0custom.img
	-rw-r--r--    1 root     root       127314 Mar 19 21:54 initrd-2.4.18-19.8.0custom.img
	cp  ./initrd-2.4.18-19.8.0custom.img   /boot
        </ProgramListing>
      </Para>
      <Para>
        See the following sections for the manual method of creating an initrd 
        image. 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        Kernel Docs 
      </Title>
      <Para>
        To create /boot/initrd.img see the documentation at 
        /usr/src/linux/Documentation/initrd.txt and see also 
        <ULink URL="http://www.tldp.org/HOWTO/mini/Loopback-Root-FS-3.html#ss3.3">
          Loopback-Root-mini-HOWTO 
        </ULink>
        . 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        Linuxman Book 
      </Title>
      <Para>
        A cut from 
        <ULink URL="http://www.linuxman.com.cy/rute/node1.html">
          "http://www.linuxman.com.cy/rute/node1.html" 
        </ULink>
        chapter 31.7. 
      </Para>
      <Para>
        SCSI Installation Complications and initrd 
      </Para>
      <Para>
        Some of the following descriptions may be difficult to understand 
        without knowledge of kernel modules explained in Chapter 42. You may 
        want to come back to it later. 
      </Para>
      <Para>
        Consider a system with zero IDE disks and one SCSI disk containing a 
        LINUX installation. There are BIOS interrupts to read the SCSI disk, 
        just as there were for the IDE, so LILO can happily access a kernel 
        image somewhere inside the SCSI partition. However, the kernel is 
        going to be lost without a kernel module &lsqb;See Chapter 42. The 
        kernel doesn't support every possible kind of hardware out there all 
        by itself. It is actually divided into a main part (the kernel image 
        discussed in this chapter) and hundreds of modules (loadable parts 
        that reside in /lib/modules/) that support the many type of SCSI, 
        network, sound etc., peripheral devices.] that understands the 
        particular SCSI driver. So although the kernel can load and execute, 
        it won't be able to mount its root file system without loading a SCSI 
        module first. But the module itself resides in the root file system in 
        /lib/modules/. This is a tricky situation to solve and is done in one 
        of two ways: either (a) using a kernel with preenabled SCSI support or 
        (b) using what is known as an initrd preliminary root file system 
        image. 
      </Para>
      <Para>
        The first method is what I recommend. It's a straightforward (though 
        time-consuming) procedure to create a kernel with SCSI support for 
        your SCSI card built-in (and not in a separate module). Built-in SCSI 
        and network drivers will also autodetect cards most of the time, 
        allowing immediate access to the device--they will work without being 
        given any options &lsqb;Discussed in Chapter 42.] and, most 
        importantly, without your having to read up on how to configure them. 
        This setup is known as compiled-in support for a hardware driver (as 
        opposed to module support for the driver). The resulting kernel image 
        will be larger by an amount equal to the size of module. Chapter 42 
        discusses such kernel compiles. 
      </Para>
      <Para>
        The second method is faster but trickier. LINUX supports what is known 
        as an initrd image ( initial rAM disk image). This is a small, +1.5 
        megabyte file system that is loaded by LILO and mounted by the kernel 
        instead of the real file system. The kernel mounts this file system as 
        a RAM disk, executes the file /linuxrc, and then only mounts the real 
        file system. 
      </Para>
      <Para>
        31.6 Creating an initrd Image 
      </Para>
      <Para>
        Start by creating a small file system. Make a directory &nbsp;/initrd 
        and copy the following files into it. 
      </Para>
      <Para>
        <ProgramListing>
	drwxr-xr-x    7 root     root         1024 Sep 14 20:12 initrd/
	drwxr-xr-x    2 root     root         1024 Sep 14 20:12 initrd/bin/
	-rwxr-xr-x    1 root     root       436328 Sep 14 20:12 initrd/bin/insmod
	-rwxr-xr-x    1 root     root       424680 Sep 14 20:12 initrd/bin/sash
	drwxr-xr-x    2 root     root         1024 Sep 14 20:12 initrd/dev/
	crw-r--r--    1 root     root       5,   1 Sep 14 20:12 initrd/dev/console
	crw-r--r--    1 root     root       1,   3 Sep 14 20:12 initrd/dev/null
	brw-r--r--    1 root     root       1,   1 Sep 14 20:12 initrd/dev/ram
	crw-r--r--    1 root     root       4,   0 Sep 14 20:12 initrd/dev/systty
	crw-r--r--    1 root     root       4,   1 Sep 14 20:12 initrd/dev/tty1
	crw-r--r--    1 root     root       4,   1 Sep 14 20:12 initrd/dev/tty2
	crw-r--r--    1 root     root       4,   1 Sep 14 20:12 initrd/dev/tty3
	crw-r--r--    1 root     root       4,   1 Sep 14 20:12 initrd/dev/tty4
	drwxr-xr-x    2 root     root         1024 Sep 14 20:12 initrd/etc/
	drwxr-xr-x    2 root     root         1024 Sep 14 20:12 initrd/lib/
	-rwxr-xr-x    1 root     root           76 Sep 14 20:12 initrd/linuxrc
	drwxr-xr-x    2 root     root         1024 Sep 14 20:12 initrd/loopfs/
        </ProgramListing>
      </Para>
      <Para>
        On my system, the file initrd/bin/insmod is the statically linked 
        &lsqb;meaning it does not require shared libraries.] version copied 
        from /sbin/insmod.static--a member of the modutils-2.3.13 package. 
        initrd/bin/sash is a statically linked shell from the sash-3.4 
        package. You can recompile insmod from source if you don't have a 
        statically linked version. Alternatively, copy the needed DLLs from 
        /lib/ to initrd/lib/. (You can get the list of required DLLs by 
        running ldd /sbin/insmod. Don't forget to also copy symlinks and run 
        strip -s &lcub;lib&rcub; to reduce the size of the DLLs.) 
      </Para>
      <Para>
        Now copy into the initrd/lib/ directory the SCSI modules you require. 
        For example, if we have an Adaptec AIC-7850 SCSI adapter, we would 
        require the aic7xxx.o module from 
        /lib/modules/&lcub;version&rcub;/scsi/aic7xxx.o. Then, place it in the 
        initrd/lib/ directory. 
      </Para>
      <Para>
        <ProgramListing>
	-rw-r--r--    1 root     root       129448 Sep 27  1999 initrd/lib/aic7xxx.o
        </ProgramListing>
      </Para>
      <Para>
        The file initrd/linuxrc should contain a script to load all the 
        modules needed for the kernel to access the SCSI partition. In this 
        case, just the aic7xxx module &lsqb; insmod can take options such as 
        the IRQ and IO-port for the device. See Chapter 42.]: 
      </Para>
      <Para>
        <ProgramListing>
	#!/bin/sash
	 
	aliasall
	 
	echo "Loading aic7xxx module"
	insmod /lib/aic7xxx.o 
        </ProgramListing>
      </Para>
      <Para>
        Now double-check all your permissions and then chroot to the file 
        system for testing. 
      </Para>
      <Para>
        <ProgramListing>
	chroot ~/initrd /bin/sash
	/linuxrc
        </ProgramListing>
      </Para>
      <Para>
        Now, create a file system image similar to that in Section 19.9: 
        <ProgramListing>
	dd if=/dev/zero of=~/file-inird count=2500 bs=1024
	losetup /dev/loop0 ~/file-inird
	mke2fs /dev/loop0
	mkdir ~/mnt
	mount /dev/loop0 ~/mnt
	cp -a initrd/* ~/mnt/
	umount ~/mnt
	losetup -d /dev/loop0
        </ProgramListing>
      </Para>
      <Para>
        Finally, gzip the file system to an appropriately named file: 
        <ProgramListing>
	gzip -c ~/file-inird &#62; initrd-&#60;kernel-version&#62;
        </ProgramListing>
      </Para>
      <Para>
        31.7 Modifying lilo.conf for initrd 
      </Para>
      <Para>
        Your lilo.conf file can be changed slightly to force use of an initrd 
        file system. Simply add the initrd option. For example: 
      </Para>
      <Para>
        <ProgramListing>
	boot=/dev/sda
	prompt
	timeout = 50
	compact
	vga = extended
	linear
	image = /boot/vmlinuz-2.2.17
	        initrd = /boot/initrd-2.2.17
	        label = linux
	        root = /dev/sda1
	        read-only
        </ProgramListing>
      </Para>
      <Para>
        Notice the use of the linear option. This is a BIOS trick that you can 
        read about in lilo(5). It is often necessary but can make SCSI disks 
        nonportable to different BIOSs (meaning that you will have to rerun 
        lilo if you move the disk to a different computer). 
      </Para>
    </Sect2>
  </Sect1>
  <Sect1 id="liloconf">
    <Title>
      Appendix B - Sample lilo.conf 
    </Title>
    <Para>
      See also 
      <XRef LinkEnd="grubconf">
      file. 
    </Para>
    <Para>
      Always give a date extension to the filename, because it tells you when 
      you built the kernel, as shown below: 
      <ProgramListing>
	bash# man lilo
	bash# man lilo.conf
	And edit /etc/lilo.conf file and put these lines - 
		image=/boot/bzImage.myker.26mar2001 
		label=myker
		root=/dev/hda1 
		read-only 
	You can check device name for 'root=' with the command - 
		bash# df   / 
	Now give -
		bash# lilo 
		bash# lilo -q 
      </ProgramListing>
      You must re-run lilo even if the entry 'myker' exists, everytime you 
      create a new bzImage. 
    </Para>
    <Para>
      Given below is a sample /etc/lilo.conf file. You should follow the 
      naming conventions like ker2217 (for kernel 2.2.17), ker2214 (for kernel 
      2.2.14). You can have many kernel images on the same /boot system. On my 
      machine I have something like: 
      <ProgramListing>
	boot=/dev/hda
	map=/boot/map
	install=/boot/boot.b
	prompt
	timeout=50
	default=firewall
	image=/boot/vmlinuz-2.2.14-5.0
		label=ker2214
		read-only
		root=/dev/hda9
	image=/boot/vmlinuz-2.2.17-14
		label=ker2217
		read-only
		root=/dev/hda9
	#image=/usr/src/linux/arch/i386/boot/bzImage 
	#	label=myker 
	#	root=/dev/hda7
	#	read-only 
	image=/boot/bzImage.myker.11feb2001
		label=myker11feb 
		root=/dev/hda9
		read-only 
	image=/boot/bzImage.myker.01jan2001
		label=myker01jan 
		root=/dev/hda9
		read-only 
	image=/boot/bzImage.myker-firewall.16mar2001
		label=firewall 
		root=/dev/hda9
		read-only 
      </ProgramListing>
    </Para>
  </Sect1>
  <Sect1 id="grubconf">
    <Title>
      Appendix C - GRUB Details And A Sample grub.conf 
    </Title>
    <Para>
      See 
      <ItemizedList>
        <ListItem>
          <Para>
            <ULink URL="http://www.tldp.org/HOWTO/Linux+Win9x+Grub-HOWTO/intro.html">
              "http://www.tldp.org/HOWTO/Linux+Win9x+Grub-HOWTO/intro.html" 
            </ULink>
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            GNU GRUB 
            <ULink URL="http://www.gnu.org/software/grub">
              "http://www.gnu.org/software/grub" 
            </ULink>
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            <ULink URL="http://www.redhat.com/docs/manuals/linux/RHL-7.2-Manual/ref-guide/ch-grub.html">
              Redhat Manual 
            </ULink>
            . 
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            <ULink URL="http://www.tldp.org/HOWTO/mini/Multiboot-with-GRUB.html">
              Multiboot-with-GRUB minihowto 
            </ULink>
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            <ULink URL="http://www.mcc.ac.uk/grub/grub_toc.html">
              Grub Manual 
            </ULink>
          </Para>
        </ListItem>
      </ItemizedList>
      <ProgramListing>
	bash# man grub
	bash# man grubby   # (command line tool for configuring grub, lilo, and elilo)
	bash# man grub-install
      </ProgramListing>
      Edit the file /etc/grub.conf to make entries for the new kernel. See the 
      sample file below: 
    </Para>
    <Para>
      <ProgramListing>
	# grub.conf generated by anaconda
	#
	# Note that you do not have to rerun grub after making changes to this file
	# NOTICE:  You do not have a /boot partition.  This means that
	#          all kernel and initrd paths are relative to /, eg.
	#          root (hd0,8)
	#          kernel /boot/vmlinuz-version ro root=/dev/hda9
	#          initrd /boot/initrd-version.img
	#boot=/dev/hda
	# By default boot the second entry
	default=1
	# Fallback to the first entry.
	fallback 0
	# Boot automatically after 2 minutes
	timeout=120
	splashimage=(hd0,8)/boot/grub/splash.xpm.gz
	title Windows 2000 
	unhide (hd0,0)
	hide (hd0,1)
	hide (hd0,2)
	rootnoverify (hd0,0)
	chainloader +1
	makeactive
	title Red Hat Linux (2.4.18-19.8.0.19mar2003)
		root (hd0,8)
		kernel /boot/bzImage.2.4.18-19.8.0.19mar2003 ro root=LABEL=/ hdd=ide-scsi
		initrd /boot/initrd-2.4.18-19.8.0custom.img.19mar03
	title Red Hat Linux (2.4.18-19.8.0custom)
		root (hd0,8)
		kernel /boot/vmlinuz-2.4.18-19.8.0custom ro root=LABEL=/ hdd=ide-scsi
		initrd /boot/initrd-2.4.18-19.8.0custom.img
	title Red Hat Linux (2.4.18-14)
		root (hd0,8)
		kernel /boot/vmlinuz-2.4.18-14 ro root=LABEL=/ hdd=ide-scsi
		initrd /boot/initrd-2.4.18-14.img
	title MyKernel.26jan03 (Red Hat Linux 2.4.18-14)
		root (hd0,8)
		kernel /boot/bzImage.myker.26jan03 ro root=LABEL=/ hdd=ide-scsi
		initrd /boot/initrd-2.4.18-19.8.0.img
	title Windows 98
	hide (hd0,0)
	hide (hd0,1)
	unhide (hd0,2)
	rootnoverify (hd0,2)
	chainloader +1
	makeactive
	title DOS 6.22
	hide (hd0,0)
	unhide (hd0,1)
	hide (hd0,2)
	rootnoverify (hd0,1)
	chainloader +1
	makeactive
	title Partition 2 (floppy)
	hide (hd0,0)
	unhide (hd0,1)
	hide (hd0,2)
	chainloader (fd0)+1
	title Partition 3 (floppy)
	hide (hd0,0)
	hide (hd0,1)
	unhide (hd0,2)
	chainloader (fd0)+1
      </ProgramListing>
    </Para>
  </Sect1>
  <Sect1 id="postkerneld">
    <Title>
      Appendix D - Post Kernel Building 
    </Title>
    <Para>
      After successfully building and booting the Linux kernel, you may be 
      required to do these additional steps to make some of the devices to 
      work with Linux. (The steps below were tested on Redhat Linux but should 
      work with other distributions as well.) 
    </Para>
    <Para>
      <Emphasis remap="bf">
        Video card/Monitor configuration: 
      </Emphasis>
      <ItemizedList>
        <ListItem>
          <Para>
            Please see the video card manual which is usually shipped with the 
            PC. You should look for a "Technical Specifications" page. 
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            Please see the monitor's manual and look for a "Technical 
            Specifications" page. 
          </Para>
        </ListItem>
      </ItemizedList>
    </Para>
    <Para>
      If you are using latest version of Linux (2.4 or later) and inside 
      KDE/GNOME desktop click on Start-&#62;"System Settings"-&#62;Display. 
    </Para>
    <Para>
      For older versions of Linux follow the steps below: 
    </Para>
    <Para>
      You can configure the Video card and monitor by using these commands: 
      <ProgramListing>
	bash$ su - root
	bash# man Xconfigurator
	bash# /usr/bin/X11/Xconfigurator --help
	bash# /usr/bin/X11/Xconfigurator 
	bash# /usr/bin/X11/Xconfigurator --expert
	See also:
	bash# man xf86config
	bash# /usr/bin/X11/xf86config
      </ProgramListing>
      If your card is not detected automatically, then you can use the 
      --expert option and select the "Unlisted card". If your monitor is not 
      listed then select the generic monitor type SVGA 1024x768. 
    </Para>
    <Para>
      <Emphasis remap="bf">
        Sound card configuration: 
      </Emphasis>
      <ItemizedList>
        <ListItem>
          <Para>
            Connect your external speakers to the sound card's audio port. 
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            Connect your CDROM audio wire to sound card's audio 4-pin socket. 
            (Otherwise your cdrom drive will not play the music from your 
            music cd) 
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            Refer to HOWTO docs on 'Sound' at 
            <ULink URL="http://www.linuxdoc.org">
              "http://www.linuxdoc.org" 
            </ULink>
          </Para>
        </ListItem>
      </ItemizedList>
      If you are using latest version of Linux (2.4 or later) and inside 
      KDE/GNOME desktop click on Start-&#62;"System Settings"-&#62;Soundcard 
      Detection. 
    </Para>
    <Para>
      For older versions of Linux follow the steps below: 
    </Para>
    <Para>
      <ProgramListing>
	bash$ su - root
	bash# man sndconfig
	bash# /usr/sbin/sndconfig
      </ProgramListing>
      Then start X-window 'KDE desktop' with 'startx' command. Click on 'K 
      Start-&#62;ControlCenter-&#62;SoundServer-&#62;General-&#62;Test Sound'. 
      This should play the test sound. Then click on 'K 
      Start-&#62;MultiMedia-&#62;SoundMixer-&#62;SoundVolumeSlider' and adjust 
      the sound volume. 
    </Para>
    <Para>
      <Emphasis remap="bf">
        Network card configuration: 
      </Emphasis>
      If you are using latest version of Linux (2.4 or later) and inside 
      KDE/GNOME desktop click on Start-&#62;"System Settings"-&#62;Network. 
    </Para>
    <Para>
      For older versions of Linux follow the steps below: 
    </Para>
    <Para>
      <ItemizedList>
        <ListItem>
          <Para>
            Use /sbin/linuxconf 
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            Or use KDE control panel 
          </Para>
        </ListItem>
        <ListItem>
          <Para>
            Refer to HOWTO docs on 'Networking' at 
            <ULink URL="http://www.linuxdoc.org">
              "http://www.linuxdoc.org" 
            </ULink>
          </Para>
        </ListItem>
      </ItemizedList>
    </Para>
    <Para>
      <Emphasis remap="bf">
        Configure Firewall and IP Masquerading : 
      </Emphasis>
      For Linux kernel version 2.4 and above, the firewall and IP Masquerading 
      is implemented by NetFilter package. Hence in kernel config you should 
      enable Netfilter and run the Firewall/IPMasq script. Download the 
      scripts from 
      <ULink URL="http://www.BoingWorld.com/workshops/linux/iptables-tutorial">
        Firewall-IPMasq scripts 
      </ULink>
      , main page of Netfilter is at 
      <ULink URL="http://netfilter.samba.org">
        "http://netfilter.samba.org" 
      </ULink>
      . Related materials at 
      <ULink URL="http://www.linuxsecurity.com/feature_stories/kernel-netfilter.html">
        firewalling-matures 
      </ULink>
      and 
      <ULink URL="http://netfilter.filewatcher.org/netfilter-faq.html">
        Netfilter-FAQ 
      </ULink>
      . 
    </Para>
    <Para>
      For kernel version below 2.4 you should install the firewall rpms from 
      <ULink URL="http://rpmfind.net/linux/rpm2html/search.php?query=firewall">
        rpmfind.net 
      </ULink>
      or 
      <ULink URL="http://rpmfind.net/linux/RPM/contrib/noarch//SRPMS//firewall-2.2-3.src.html">
        firewall.src.rpm 
      </ULink>
      . 
    </Para>
    <Para>
      <Emphasis remap="bf">
        Configuration of other devices: 
      </Emphasis>
      Refer to HOWTO docs relating to your devices at 
      <ULink URL="http://www.linuxdoc.org">
        "http://www.linuxdoc.org" 
      </ULink>
    </Para>
  </Sect1>
  <Sect1 id="troubleshoot">
    <Title>
      Appendix E - Troubleshoot Common Mistakes 
    </Title>
    <Sect2>
      <Title>
        Compiles OK but does not boot 
      </Title>
      <Para>
        If the kernel compiles ok but booting never works and it always 
        complains with a kernel panic about /sbin/modprobe. 
      </Para>
      <Para>
        Solution: You did not create initrd image file. See the Appendix A at 
        <XRef LinkEnd="createinitrd">
        . Also, you must do 'make modules' and 'make modules&lowbar;install' 
        in addition to creating the initrd image file. 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        The System Hangs at LILO 
      </Title>
      <Para>
        <Emphasis remap="bf">
          Sympton: 
        </Emphasis>
        After you build the kernel and reboot, the system hangs just before 
        LILO. 
      </Para>
      <Para>
        <Emphasis remap="bf">
          Reason: 
        </Emphasis>
        Probably you did not set the BIOS to pick up the proper Primary Master 
        IDE and Secondary Slave IDE hard disk partition. 
      </Para>
      <Para>
        <Emphasis remap="bf">
          Solution: 
        </Emphasis>
        Power on the machine and press DEL key to do setup of the BIOS (Basic 
        Input Output system). Select the IDE settings and set proper primary 
        hard disk partition and slave drives. When the system boots it looks 
        for the primary IDE hard disk and the Master Boot Record partition. It 
        reads the MBR and starts loading the Linux Kernel from the hard disk 
        partition. 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        No init found 
      </Title>
      <Para>
        The following mistake is commited very frequently by new users. 
      </Para>
      <Para>
        If your new kernel does not boot and you get - 
        <ProgramListing>
	Warning: unable to open an initial console
	Kernel panic: no init found. Try passing init= option to kernel
        </ProgramListing>
        The problem is that you 
        <Emphasis remap="bf">
          did not 
        </Emphasis>
        set the "root=" parameter properly in the /etc/lilo.conf. In my case, 
        I used root=/dev/hda1 which is having the root partition "/". You must 
        properly point the root device in your lilo.conf, it can be like 
        /dev/hdb2 or /dev/hda7. 
      </Para>
      <Para>
        The kernel looks for the init command which is located in /sbin/init. 
        And /sbin directory lives on the root partition. For details see - 
        <ProgramListing>
	bash# man init
        </ProgramListing>
        See the 
        <XRef LinkEnd="grubconf">
        file and see the 
        <XRef LinkEnd="liloconf">
        . 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        Lot of Compile Errors 
      </Title>
      <Para>
        The 'make', 'make bzImage', 'make modules' or 'make 
        modules&lowbar;install' gives compile problems. You should give 'make 
        mrproper' before doing make. 
        <ProgramListing>
	bash# make mrproper
        </ProgramListing>
        If this problem persists, then try menuconfig instead of xconfig. 
        Sometimes GUI version xconfig causes some problems: 
        <ProgramListing>
	bash# export TERM=VT100
	bash# make menuconfig
        </ProgramListing>
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        The 'depmod' gives "Unresolved symbol error messages" 
      </Title>
      <Para>
        When you run 
        <Literal remap="tt">
          depmod 
        </Literal>
        it gives "Unresolved symbols". A sample error message is given here to 
        demonstrate the case: 
        <ProgramListing>
	bash$ su - root
	bash# man depmod
	bash# depmod
	depmod: *** Unresolved symbols in /lib/modules/version/kernel/drivers/md/linear.o
	depmod: *** Unresolved symbols in /lib/modules/version/kernel/drivers/md/multipath.o
	depmod: *** Unresolved symbols in /lib/modules/version/kernel/drivers/md/raid0.o
	depmod: *** Unresolved symbols in /lib/modules/version/kernel/drivers/md/raid1.o
	depmod: *** Unresolved symbols in /lib/modules/version/kernel/drivers/md/raid5.o
        </ProgramListing>
      </Para>
      <Para>
        <Emphasis remap="bf">
          Reason: 
        </Emphasis>
        You did not make modules and install the modules after building the 
        new kernel with 
        <Literal remap="tt">
          "make bzImage" 
        </Literal>
        . 
      </Para>
      <Para>
        <Emphasis remap="bf">
          Solution: 
        </Emphasis>
        After you build the new kernel, you must do: 
        <ProgramListing>
	bash$ su - root
	bash# cd /usr/src/linux
	bash# make modules
	bash# make modules_install
        </ProgramListing>
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        Kernel Does Not Load Module - "Unresolved symbols" Error Messages 
      </Title>
      <Para>
        When you boot kernel and system tries to load any modules and you get 
        "Unresolved symbol : &lowbar;&lowbar;some&lowbar;function&lowbar;name" 
        then it means that you did not clean compile the modules and kernel. 
        It is mandatory that you should do 
        <Emphasis remap="bf">
          make clean 
        </Emphasis>
        and make the modules. Do this - 
        <ProgramListing>
		bash# cd /usr/src/linux
		bash# make dep
		bash# make clean
		bash# make mrproper
		bash# nohup make bzImage &#38;  
		bash# tail -f nohup.out     (.... to monitor the progress) 
		bash# make modules
		bash# make modules_install
        </ProgramListing>
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        Kernel fails to load a module 
      </Title>
      <Para>
        If the kernel fails to load a module (say loadable module for network 
        card or other devices), then you may want to try to build the driver 
        for device right into the kernel. Sometimes 
        <Emphasis remap="it">
          <Emphasis remap="bf">
            loadable module will NOT work 
          </Emphasis>
        </Emphasis>
        and the driver needs to be built right inside the kernel. For example 
        - some network cards do not support loadable module feature - you MUST 
        build the driver of the network card right into linux kernel. Hence, 
        in 'make xconfig' you MUST not select loadable module for this device. 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        Loadable modules 
      </Title>
      <Para>
        You can install default loadable modules with - 
      </Para>
      <Para>
        The step given below may not be required but is needed 
        <Emphasis remap="bf">
          ONLY FOR EMERGENCIES 
        </Emphasis>
        where your /lib/modules files are damaged. If you already have the 
        /lib/modules directory and in case you want replace them use the 
        --force to replace the package and select appropriate cpu 
        architecture. 
      </Para>
      <Para>
        For new versions of linux redhat linux 6.0 and later, the kernel 
        modules are included with kernel-2.2*.rpm. Install the loadable 
        modules and the kernel with 
        <ProgramListing>
		This will list the already installed package.
	bash# rpm -qa | grep -i kernel
		
	bash# rpm -U --force  /mnt/cdrom/Redhat/RPMS/kernel-2.2.14-5.0.i686.rpm
	(or)
	bash# rpm -U --force  /mnt/cdrom/Redhat/RPMS/kernel-2.2.14-5.0.i586.rpm
	(or)
	bash# rpm -U --force  /mnt/cdrom/Redhat/RPMS/kernel-2.2.14-5.0.i386.rpm
        </ProgramListing>
      </Para>
      <Para>
        This is only for old versions of redhat linux 5.2 and before. Boot new 
        kernel and install the loadable modules from RedHat Linux "contrib" 
        cdrom 
        <ProgramListing>
	bash# rpm -i /mnt/cdrom/contrib/kernel-modules*.rpm 
	....(For old linux systems which do not have insmod pre-installed) 
        </ProgramListing>
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        See Docs 
      </Title>
      <Para>
        More problems. You can read the /usr/src/linux/README (at least once) 
        and also /usr/src/linux/Documentation. 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        make clean 
      </Title>
      <Para>
        If your new kernel does really weird things after a routine kernel 
        upgrade, chances are you forgot to 
        <Literal remap="tt">
          make clean 
        </Literal>
        before compiling the new kernel. Symptoms can be anything from your 
        system outright crashing, strange I/O problems, to crummy performance. 
        Make sure you do a 
        <Literal remap="tt">
          make dep 
        </Literal>
        , too. 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        Huge or slow kernels 
      </Title>
      <Para>
        If your kernel is sucking up a lot of memory, is too large, and/or 
        just takes forever to compile even when you've got your new 
        Quadbazillium-III/4400 working on it, you've probably got lot of 
        unneeded stuff (device drivers, filesystems, etc) configured. If you 
        don't use it, don't configure it, because it does take up memory. The 
        most obvious symptom of kernel bloat is extreme swapping in and out of 
        memory to disk; if your disk is making a lot of noise and it's not one 
        of those old Fujitsu Eagles that sound like like a jet landing when 
        turned off, look over your kernel configuration. 
      </Para>
      <Para>
        You can find out how much memory the kernel is using by taking the 
        total amount of memory in your machine and subtracting from it the 
        amount of ``total mem'' in 
        <Literal remap="tt">
          /proc/meminfo 
        </Literal>
        or the output of the command ` 
        <Literal remap="tt">
          free 
        </Literal>
        '. 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        The parallel port doesn't work/my printer doesn't work 
      </Title>
      <Para>
        Configuration options for PCs are: First, under the category `General 
        Setup', select `Parallel port support' and `PC-style hardware'. Then 
        under `Character devices', select `Parallel printer support'. 
      </Para>
      <Para>
        Then there are the names. Linux 2.2 names the printer devices 
        differently than previous releases. The upshot of this is that if you 
        had an 
        <Literal remap="tt">
          lp1 
        </Literal>
        under your old kernel, it's probably an 
        <Literal remap="tt">
          lp0 
        </Literal>
        under your new one. Use ` 
        <Literal remap="tt">
          dmesg 
        </Literal>
        ' or look through the logs in 
        <Literal remap="tt">
          /var/log 
        </Literal>
        to find out. 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        Kernel doesn't compile 
      </Title>
      <Para>
        If it does not compile, then it is likely that a patch failed, or your 
        source is somehow corrupt. Your version of gcc also might not be 
        correct, or could also be corrupt (for example, the include files 
        might be in error). Make sure that the symbolic links which Linus 
        describes in the 
        <Literal remap="tt">
          README 
        </Literal>
        are set up correctly. In general, if a standard kernel does not 
        compile, something is seriously wrong with the system, and 
        reinstallation of certain tools is probably necessary. 
      </Para>
      <Para>
        In some cases, gcc can crash due to hardware problems. The error 
        message will be something like ``xxx exited with signal 15'' and it 
        will generally look very mysterious. I probably would not mention 
        this, except that it happened to me once - I had some bad cache 
        memory, and the compiler would occasionally barf at random. Try 
        reinstalling gcc first if you experience problems. You should only get 
        suspicious if your kernel compiles fine with external cache turned 
        off, a reduced amount of RAM, etc. 
      </Para>
      <Para>
        It tends to disturb people when it's suggested that their hardware has 
        problems. Well, I'm not making this up. There is an FAQ for it -- it's 
        at 
        <ULink URL="http://www.bitwizard.nl/sig11">
          "http://www.bitwizard.nl/sig11" 
        </ULink>
        . 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        New version of the kernel doesn't seem to boot 
      </Title>
      <Para>
        You did not run LILO, or it is not configured correctly. One thing 
        that ``got'' me once was a problem in the config file; it said ` 
        <Literal remap="tt">
          boot = /dev/hda1 
        </Literal>
        ' instead of ` 
        <Literal remap="tt">
          boot = /dev/hda 
        </Literal>
        ' (This can be really annoying at first, but once you have a working 
        config file, you shouldn't need to change it.). 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        You forgot to run LILO, or system doesn't boot at all 
      </Title>
      <Para>
        Ooops! The best thing you can do here is to boot off of a floppy disk 
        or CDROM and prepare another bootable floppy (such as ` 
        <Literal remap="tt">
          make zdisk 
        </Literal>
        ' would do). You need to know where your root ( 
        <Literal remap="tt">
          / 
        </Literal>
        ) filesystem is and what type it is (e.g. second extended, minix). In 
        the example below, you also need to know what filesystem your 
        <Literal remap="tt">
          /usr/src/linux 
        </Literal>
        source tree is on, its type, and where it is normally mounted. 
      </Para>
      <Para>
        In the following example, 
        <Literal remap="tt">
          / 
        </Literal>
        is 
        <Literal remap="tt">
          /dev/hda1 
        </Literal>
        , and the filesystem which holds 
        <Literal remap="tt">
          /usr/src/linux 
        </Literal>
        is 
        <Literal remap="tt">
          /dev/hda3 
        </Literal>
        , normally mounted at 
        <Literal remap="tt">
          /usr 
        </Literal>
        . Both are second extended filesystems. The working kernel image in 
        <Literal remap="tt">
          /usr/src/linux/arch/i386/boot 
        </Literal>
        is called 
        <Literal remap="tt">
          bzImage 
        </Literal>
        . 
      </Para>
      <Para>
        The idea is that if there is a functioning 
        <Literal remap="tt">
          bzImage 
        </Literal>
        , it is possible to use that for the new floppy. Another alternative, 
        which may or may not work better (it depends on the particular method 
        in which you messed up your system) is discussed after the example. 
      </Para>
      <Para>
        First, boot from a boot/root disk combo or rescue disk, and mount the 
        filesystem which contains the working kernel image: 
      </Para>
      <Para>
        mkdir /mnt mount -t ext2 /dev/hda3 /mnt 
      </Para>
      <Para>
        If 
        <Literal remap="tt">
          mkdir 
        </Literal>
        tells you that the directory already exists, just ignore it. Now, 
        <Literal remap="tt">
          cd 
        </Literal>
        to the place where the working kernel image was. Note that /mnt + 
        /usr/src/linux/arch/i386/boot - /usr = /mnt/src/linux/arch/i386/boot 
        Place a formatted disk in drive ``A:'' (not your boot or root disk!), 
        dump the image to the disk, and configure it for your root filesystem: 
      </Para>
      <Para>
        cd /mnt/src/linux/arch/i386/boot dd if=bzImage of=/dev/fd0 rdev 
        /dev/fd0 /dev/hda1 
      </Para>
      <Para>
        <Literal remap="tt">
          cd 
        </Literal>
        to 
        <Literal remap="tt">
          / 
        </Literal>
        and unmount the normal 
        <Literal remap="tt">
          /usr 
        </Literal>
        filesystem: 
      </Para>
      <Para>
        cd / umount /mnt 
      </Para>
      <Para>
        You should now be able to reboot your system as normal from this 
        floppy. Don't forget to run lilo (or whatever it was that you did 
        wrong) after the reboot! 
      </Para>
      <Para>
        As mentioned above, there is another common alternative. If you 
        happened to have a working kernel image in 
        <Literal remap="tt">
          / 
        </Literal>
        ( 
        <Literal remap="tt">
          /vmlinuz 
        </Literal>
        for example), you can use that for a boot disk. Supposing all of the 
        above conditions, and that my kernel image is 
        <Literal remap="tt">
          /vmlinuz 
        </Literal>
        , just make these alterations to the example above: change 
        <Literal remap="tt">
          /dev/hda3 
        </Literal>
        to 
        <Literal remap="tt">
          /dev/hda1 
        </Literal>
        (the 
        <Literal remap="tt">
          / 
        </Literal>
        filesystem), 
        <Literal remap="tt">
          /mnt/src/linux 
        </Literal>
        to 
        <Literal remap="tt">
          /mnt 
        </Literal>
        , and 
        <Literal remap="tt">
          if=bzImage 
        </Literal>
        to 
        <Literal remap="tt">
          if=vmlinuz 
        </Literal>
        . The note explaining how to derive 
        <Literal remap="tt">
          /mnt/src/linux 
        </Literal>
        may be ignored. 
      </Para>
      <Para>
        Using LILO with big drives (more than 1024 cylinders) can cause 
        problems. See the LILO mini-HOWTO or documentation for help on that. 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        It says `warning: bdflush not running' 
      </Title>
      <Para>
        This can be a severe problem. Starting with a kernel release after 
        Linux v1.0 (around 20 Apr 1994), a program called ` 
        <Literal remap="tt">
          update 
        </Literal>
        ' which periodically flushes out the filesystem buffers, was 
        upgraded/replaced. Get the sources to ` 
        <Literal remap="tt">
          bdflush 
        </Literal>
        ' (you should find it where you got your kernel source), and install 
        it (you probably want to run your system under the old kernel while 
        doing this). It installs itself as ` 
        <Literal remap="tt">
          update 
        </Literal>
        ' and after a reboot, the new kernel should no longer complain. 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        I can't get my IDE/ATAPI CD-ROM drive to work 
      </Title>
      <Para>
        Strangely enough, lot of people cannot get their ATAPI drives working, 
        probably because there are a number of things that can go wrong. 
      </Para>
      <Para>
        If your CD-ROM drive is the only device on a particular IDE interface, 
        it must be jumpered as ``master'' or ``single.'' Supposedly, this is 
        the most common error. 
      </Para>
      <Para>
        Creative Labs (for one) has put IDE interfaces on their sound cards 
        now. However, this leads to the interesting problem that while some 
        people only have one interface to being with, many have two IDE 
        interfaces built-in to their motherboards (at IRQ15, usually), so a 
        common practice is to make the soundblaster interface a third IDE port 
        (IRQ11, or so I'm told). 
      </Para>
      <Para>
        This causes problems with older Linux versions like 1.3 and below. in 
        that versions Linux don't support a third IDE interface. To get around 
        this, you have a few choices. 
      </Para>
      <Para>
        If you have a second IDE port already, chances are that you are not 
        using it or it doesn't already have two devices on it. Take the ATAPI 
        drive off the sound card and put it on the second interface. You can 
        then disable the sound card's interface, which saves an IRQ anyway. 
      </Para>
      <Para>
        If you don't have a second interface, jumper the sound card's 
        interface (not the sound card's sound part) as IRQ15, the second 
        interface. It should work. 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        It says weird things about obsolete routing requests 
      </Title>
      <Para>
        Get new versions of the 
        <Literal remap="tt">
          route 
        </Literal>
        program and any other programs which do route manipulation. 
        <Literal remap="tt">
          /usr/include/linux/route.h 
        </Literal>
        (which is actually a file in 
        <Literal remap="tt">
          /usr/src/linux 
        </Literal>
        ) has changed. 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        ``Not a compressed kernel Image file'' 
      </Title>
      <Para>
        Don't use the 
        <Literal remap="tt">
          vmlinux 
        </Literal>
        file created in 
        <Literal remap="tt">
          /usr/src/linux 
        </Literal>
        as your boot image; 
        <Literal remap="tt">
          [..]/arch/i386/boot/bzImage 
        </Literal>
        is the right one. 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        Problems with console terminal after upgrade to Linux v1.3.x 
      </Title>
      <Para>
        Change the word 
        <Literal remap="tt">
          dumb 
        </Literal>
        to 
        <Literal remap="tt">
          linux 
        </Literal>
        in the console termcap entry in 
        <Literal remap="tt">
          /etc/termcap 
        </Literal>
        . You may also have to make a terminfo entry. 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        Can't seem to compile things after kernel upgrade 
      </Title>
      <Para>
        The linux kernel source includes a number of include files (the things 
        that end with 
        <Literal remap="tt">
          .h 
        </Literal>
        ) which are referenced by the standard ones in 
        <Literal remap="tt">
          /usr/include 
        </Literal>
        . They are typically referenced like this (where 
        <Literal remap="tt">
          xyzzy.h 
        </Literal>
        would be something in 
        <Literal remap="tt">
          /usr/include/linux 
        </Literal>
        ): #include &#60;linux/xyzzy.h&#62; Normally, there is a link called 
        <Literal remap="tt">
          linux 
        </Literal>
        in 
        <Literal remap="tt">
          /usr/include 
        </Literal>
        to the 
        <Literal remap="tt">
          include/linux 
        </Literal>
        directory of your kernel source ( 
        <Literal remap="tt">
          /usr/src/linux/include/linux 
        </Literal>
        in the typical system). If this link is not there, or points to the 
        wrong place, most things will not compile at all. If you decided that 
        the kernel source was taking too much room on the disk and deleted it, 
        this will obviously be a problem. Another way it might go wrong is 
        with file permissions; if your 
        <Literal remap="tt">
          root 
        </Literal>
        has a umask which doesn't allow other users to see its files by 
        default, and you extracted the kernel source without the 
        <Literal remap="tt">
          p 
        </Literal>
        (preserve filemodes) option, those users also won't be able to use the 
        C compiler. Although you could use the 
        <Literal remap="tt">
          chmod 
        </Literal>
        command to fix this, it is probably easier to re-extract the include 
        files. You can do this the same way you did the whole source at the 
        beginning, only with an additional argument: 
      </Para>
      <Para>
        blah# tar zxvpf linux.x.y.z.tar.gz linux/include Note: `` 
        <Literal remap="tt">
          make config 
        </Literal>
        '' will recreate the 
        <Literal remap="tt">
          /usr/src/linux 
        </Literal>
        link if it isn't there. 
      </Para>
    </Sect2>
    <Sect2>
      <Title>
        Increasing limits 
      </Title>
      <Para>
        The following few 
        <Emphasis remap="it">
          example 
        </Emphasis>
        commands may be helpful to those wondering how to increase certain 
        soft limits imposed by the kernel: echo 4096 &#62; 
        /proc/sys/kernel/file-max echo 12288 &#62; /proc/sys/kernel/inode-max 
        echo 300 400 500 &#62; /proc/sys/vm/freepages 
      </Para>
    </Sect2>
  </Sect1>
</Article>
