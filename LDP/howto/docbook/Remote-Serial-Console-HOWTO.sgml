<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V3.1//EN">

<article>

<!-- Header -->

 <artheader>

  <!-- title of HOWTO, include the word HOWTO -->

  <title>Remote Serial Console HOWTO</title>

  <author>
     <firstname>Mark</firstname>
     <othername>F.</othername>
     <surname>Komarinski</surname>
     <affiliation>
        <address>
           <email>mkomarinski@valinux.com</email>
        </address>
     </affiliation>
  </author>

   <revhistory>
      <revision>
         <revnumber>0.2</revnumber>
	 <date>2001-04-13</date>
	 <authorinitials>mfk</authorinitials>
	 <revremark>
	   Minor revisions from readers.
	 </revremark>
      </revision>
      <revision>
         <revnumber>0.1</revnumber>
         <date>2001-03-20</date>
         <authorinitials>mfk</authorinitials>
          <revremark>
	    First revision
          </revremark>
      </revision>

      <!-- Additional (*earlier*) revision histories go here -->
   </revhistory>

  <abstract>
    <indexterm>
      <primary>abstract</primary>
    </indexterm>

    <para>
      Most UNIX-based systems have the concept of a serial console.
      Linux is no exception to this, and this document covers how to
      set up your hardware to use a serial console.
    </para>

  </abstract>

 </artheader>



 <section id="intro">
   <title>Introduction</title>


  <section id="copyright">
   <title>Copyright Information</title>

   <para>
    This document is copyrighted (c) 2001 Mark F. Komarinski and is
    distributed under the terms of the Linux Documentation Project
    (LDP) license, stated below.
   </para>

   <para>
    Unless otherwise stated, Linux HOWTO documents are
    copyrighted by their respective authors. Linux HOWTO documents may
    be reproduced and distributed in whole or in part, in any medium
    physical or electronic, as long as this copyright notice is
    retained on all copies. Commercial redistribution is allowed and
    encouraged; however, the author would like to be notified of any
    such distributions.
   </para>

   <para>
    All translations, derivative works, or aggregate works
    incorporating any Linux HOWTO documents must be covered under this
    copyright notice. That is, you may not produce a derivative work
    from a HOWTO and impose additional restrictions on its
    distribution. Exceptions to these rules may be granted under
    certain conditions; please contact the Linux HOWTO coordinator at
    the address given below.
   </para>

   <para>
    In short, we wish to promote dissemination of this
    information through as many channels as possible. However, we do
    wish to retain copyright on the HOWTO documents, and would like to
    be notified of any plans to redistribute the HOWTOs.
   </para>

   <para>
    If you have any questions, please contact 
    <email>linux-howto@metalab.unc.edu</email>
   </para>
  </section> <!-- copyright -->


  <section id="disclaimer">
   <title>Disclaimer</title>

   <para>
    No liability for the contents of this documents can be accepted.
    Use the concepts, examples and other content at your own risk.
    As this is a new edition of this document, there may be errors
    and inaccuracies, that may of course be damaging to your system.
    Proceed with caution, and although this is highly unlikely,
    the author(s) do not take any responsibility for that.
   </para>

   <para>
    All copyrights are held by their by their respective owners, unless
    specifically noted otherwise.  Use of a term in this document
    should not be regarded as affecting the validity of any trademark
    or service mark.
   </para>

   <para>
    Naming of particular products or brands should not be seen 
    as endorsements.
   </para>

   <para>
    You are strongly recommended to take a backup of your system 
    before major installation and backups at regular intervals.
   </para>
  </section> <!-- disclaimer -->

  <section id="credits">
   <title>Credits</title>

   <para>
     This HOWTO is based on
     <filename>/usr/src/linux/Documentation/serial-consold.txt</filename>,
     written by Miquel van Smoorenburg (<email>miquels AT cistron.nl</email>).
     Many thanks to Miquel for the information in his document.
   </para>
  </section> <!-- credits -->

  <section id="feedback">
   <title>Feedback</title>

   <para>
    Feedback is most certainly welcome for this document. Without
    your submissions and input, this document wouldn't exist. Please
    send your additions, comments and criticisms to the following
    email address : <email>mkomarinski AT valinux.com</email>.
   </para>
   </section> <!-- feedback -->

 </section> <!-- introduction -->

 <section id="whyserial">
  <title>Why use Serial Consoles?</title>
  
  <para>
    Serial consoles do not appear to have much going for
    them.  They are slow, require special null-modem cables,
    and do not provide a graphical interface.  But what is
    going for them is considerable.  Serial cables are
    standard equipment and can run over RJ-45 cables,
    can run up to 200 ft (about 100m) at 9600bps.
    Serial concentrators can run the consoles of over 32
    ports into a central box, so all the consoles in a
    cluster can be accessed from a single location.
  </para>
  <para>
    You will not require a crash cart, KVM switch, or keyboard,
    montior, or mouse.  Because of the serial concentrator, you can
    access the console of a machine in a colocation cage from
    your desktop.
  </para>

  <para>
    The real limiting factor so far has been that even though you can
    access the Linux console via a serial port, most x86 hardware was
    not set to send its POST and BIOS information to the serial port.
    More and more <quote>server</quote> motherboards are starting to
    include full serial support in the BIOS, so you can access the
    BIOS and make boot changes via the serial port.
  </para>
 </section> <!-- whyserial -->

 <section id="configuration">
  <title>Configuring Linux for Serial Consoles</title>

  <para>
    There is two parts to getting a serial console set up under
    Linux.  First, you must tell Linux to redirect its console output
    to the serial port.  Second, you must set up mgetty to start
    a login process on the serial port once the kernel has completed booting.
    Some distributions use mingetty for the video console, but mingetty
    has no serial port support.  You will instead want to use mgetty.
    A third (optional) configuration is to set the hardware BIOS to redirect
    its POST and BIOS information to the serial port.  Check your motherboard
    documentation for more information about this.
  </para>

  <section id="configurationkernel">
    <title>Configuring LILO and the Linux Kernel</title>
    <para>
      If you're using LILO as your bootloader, you can quickly test
      using serial console from Linux by entering:
    </para>
<screen>
LILO: Linux console=ttyS0,9600n8
</screen>
    <para>
      Assuming the LILO tag for your Linux kernel is called
      <quote>Linux</quote>.  Change this for the name of your kernel.
      The generic format for the console option is console=device,options.
      You can give multiple console statements, and kernel messages will go to
      all listed devices, but the last one listed will be used as
      <filename>/dev/console</filename>.
    </para>
    <informaltable>
      <tgroup cols="2">
      <tbody>
        <row>
	  <entry>device</entry>
	  <entry>The device entry to use as the console without
	  <filename>/dev/</filename>.  You can use tty0 to get normal behavior,
	  ttyx to put the console on another virtual console, or ttySx to put
	  the console on a serial port.</entry>
	</row>
	<row>
	  <entry>options</entry>
	  <entry>This is mostly used for passing options to the serial port.
	  The format for this is BPN, where B is speed in bps (so use 9600,
	  19200, 38400, etc.).  The P is parity and is one of three letters:  n
	  for no parity, e for even parity, and o for odd parity.  The N is the
	  number of data bits, and is usually either 7 or 8.  The default is
	  9600n8.  Most users will want to use the default, or increase the
	  speed to 19200 bps.
	  </entry>
	</row>
      </tbody>
      </tgroup>
    </informaltable>
    <para>
      You should see the Linux kernel start through the decompression process
      then you will see no more on-screen information until the kernel has
      completed and mgetty starts up a login prompt on the screen.  If you are
      monitoring the serial port, you'll see the Linux bootup information coming
      over the serial port.  However, you probably will not see a login prompt
      on the serial port (yet).  We'll cover that in
      <xref linkend="configurationgetty">.
    </para>
    <para>
      Once you are sure this is working, you can now edit LILO to pass this
      information to the kernel each time it boots.  You can also configure
      LILO to send its prompt to the serial port.  Fire up your favorite editor
      of choice and load up the /etc/lilo.conf file.  You will want to add
      two lines, one to the general configuration and one to the specific
      kernels you want to use.
    </para>
<screen>
serial=0,9600n8
append="console=tty0 console=ttyS0,9600n8"
</screen>
    <para>
      The append statement contains the statement we listed above, and tells
      Linux to send its output to the serial port.  The serial command goes to
      LILO, and tells it to open port 0 (ttyS0, or COM1).  The options for
      serial are the same as to the console statement.
    </para>
    <note>
      <para>
        Make sure the serial port settings for serial and console are the
	same.  If they are different, you will need to change your serial
	port application between LILO and the kernel, which becomes very
	inconvenient.
      </para>
    </note>
    <para>
      Re-run <filename>/sbin/lilo</filename> and reboot.  You should now see
      everything except the login prompt on the serial port.  Information
      should still be going to the monitor, just in case you have problems
      with the serial port.
    </para>
  </section> <!-- configurationkernel -->

  <section id="configurationgetty">
    <title>Configuring getty for use with serial ports</title>
    <para>
      Some distributions may ship with mingetty that does not support serial
      ports.  The first thing you have to do is make sure the version
      of getty you are using supports serial ports.  Both agetty and mgetty
      do this.  So run off now using your favorite packaging system to make
      sure this is the case.  Don't worry, this document will still be here
      when you get back.
    </para>
    <para>
      Back so soon?  Great!  Let's get that serial port configured.
    </para>
    <para>
      You will want to make sure that all your serial port settings are
      consistent.  No sense in making getty run at 9600bps, while
      LILO and the kernel are talking 19200.
    </para>
    <para>
      To get login prompts to appear on the serial port, edit the
      <filename>/etc/inittab</filename> file and add a line similar to
      the following:
    </para>
<screen>
s0:2345:respawn:/sbin/getty ttyS0 DT9600
</screen>
    <para>
      The format for entries in inittab are covered in most basic Linux and UNIX
      books, but to repeat, each field is separated by a colon (:) and
      represent:
    </para>
    <itemizedlist>
      <listitem>
        <para>
	  s0 - Arbitrary entry for inittab.  As long as this entry doesn't
	  appear anywhere else in inittab, you're okay.  We named
	  this entry s0 because it's for ttyS0.
	</para>
      </listitem>
      <listitem>
        <para>
	  2345 - run levels where this entry gets called.  If we switch to
	  runlevel 1, this getty process will be shut down.
	</para>
      </listitem>
      <listitem>
        <para>
	  respawn - re-run the program if it dies.  We want this to happen
	  so that a new login prompt will appear when you log out of the
	  console.
	</para>
      </listitem>
      <listitem>
        <para>
	  /sbin/getty ttyS0 DT9600 - the command to run.  In this case, we're
	  telling getty to connect to /dev/ttyS0 using the settings for DT9600
	  which exist in <filename>/etc/gettydefs</filename>.  This entry
	  represents a dumb terminal running at 9600bps.  There are other
	  entries that run at different speeds.
	</para>
      </listitem>
    </itemizedlist>
    <para>
      The entries in <filename>/etc/inittab</filename> will be loaded into
      <command>init</command> when root sends a HUP signal.
    </para>
<screen>
# kill -HUP 1
</screen>
    <note>
      <para>
        Remember that <command>init</command> always has a PID of 1.
      </para>
    </note>
    <para>
      Now that <command>getty</command> is set up, you will be able to go
      from powerup to login prompt all over the serial port
    </para>
  </section> <!-- configurationgetty -->
    
 </section> <!-- configuration -->
 
 <section id="applications">
   <title>Serial Port Applications</title>
   <para>
     This section covers applications and some configuration information
     that you can use to look at your serial console, now that
     your Linux boxes are talking to the serial port.
   </para>
   <section id="applicationsminicom">
     <title>Minicom</title>
     <para>
       Minicom is one of the easier serial port applications to use.  It is
       curses based, so it's a full screen application with a status bar,
       menus, and an easy-to-use interface.  It is installed on most
       distributions, and initially has to be run as the root user.  In
       some cases, <command>minicom</command> will be installed suid root,
       so anyone will be able to access the configurations.  Check the
       documentation for your particular distribution to see how it's
       configured.
     </para>
     <para>
       Security of minicom is set by the
       <filename>/etc/minicom.users</filename> file.  Usernames can that are
       listed along with a configuration can use the listed configurations.
       This allows only authorized users to connect to the serial ports.
     </para>
     <para>
       <command>Minicom</command> creates individual configurations to
       separate files.  Configure the serial port as needed, then save the
       configuration.  Files are kept in <filename>/etc</filename> with a
       prefix of minirc.
     </para>
   </section> <!-- applicationsminicom -->

   <section id="applicationsvacm">
     <title>VACM</title>
     <para>
       The <ulink url="http://vacm.sourceforge.net/">VA Cluster Manager</ulink>
       software from <ulink url="http://www.valinux.com/">VA Linux</ulink>
       includes serial console support for management of nodes.  VACM is
       used to monitor other aspects of clusters, such as CPU temperature,
       fan speed, CPU usage, and so on.
     </para>
   </section> <!-- applicationsvacm -->
 
 </section> <!-- applications -->

 <section id="cabling">
   <title>Cabling serial ports together</title>
   <para>
     Since you will be connecting two DTEs together, you will need to
     have a null modem run between the two devices.  A null modem
     crosses transmit and receive, and ties a few status lines together
     so the application can open the port.  This null modem can be a
     dongle that connects to the cable, or can be built into the cable.
     A dongle will get expensive if you have a large number of cables, so
     it is usually easier to get cables with the null modem
     built in.
   </para>
   <para>
     Most PC hardware these days use DB-9 connectors
     <footnote>
       <para>
         The pedantic will note that there is no such thing as a DB-9
	 connector, and should really be called <quote>DE9</quote>.
	 This is most likely a holdover from the parallel port
	 being called a DB-25 connector.  Don't ask me.  I'm not that
	 pedantic.
       </para>
     </footnote>
     , giving 9 pins for
     transmitting data and status, which is fine for us.  Pre-built DB-9
     cables can be had for a few dollars for a few feet of cable.  More
     flexible is building a DB-9 to RJ-45 connector and building
     the null modem into that.  The RJ-45 connector then accepts
     regular 10BaseT cables that can be custom-built, or with varying
     legths.  This gives a lot of flexibiliy in arranging cables, since
     each cable can be the correct length to run between machines.  Little
     extra cable is left lying around.
   </para>
   <para>
     DB-9 to RJ-45 connectors can be purchased unassembled since
     there are no real standards for making this conversion.
     So long as Tx and Rx cross and CTS RTS cross, you have a null
     modem connection.  The cabling I have here comes from my own
     design, and works just fine.  Note that there have to be two different
     DB-9 to RJ-45 connectors because of the way pins are switched.  I labeled
     them as <quote>1</quote> and <quote>2</quote>.  They can be placed
     on either end of the cable.
   </para>
   <table id="dbtorj">
     <title>DB9 to RJ-45 connector</title>
     <tgroup cols="4">
     <colspec colname="column1">
     <colspec colname="column2">
     <colspec colname="column3">
     <colspec colname="column4">
     <spanspec namest="column1" nameend="column2" spanname="hdr1"
     align="center">
     <spanspec namest="column3" nameend="column4" spanname="hdr2"
     align="center">
     <thead>
       <row>
         <entry spanname="hdr1">Connector 1</entry>
	 <entry spanname="hdr2">Connector 2</entry>
       </row>
       <row>
         <entry>DB-9</entry>
	 <entry>RJ-45</entry>
	 <entry>DB-9</entry>
	 <entry>RJ-45</entry>
       </row>
     </thead>
     <tbody>
       <row>
         <entry>1</entry>
	 <entry>5</entry>
	 <entry>1</entry>
	 <entry>5</entry>
       </row>
       <row>
         <entry>2</entry>
	 <entry>6</entry>
	 <entry>2</entry>
	 <entry>4</entry>
       </row>
       <row>
         <entry>3</entry>
	 <entry>4</entry>
	 <entry>3</entry>
	 <entry>6</entry>
       </row>
       <row>
         <entry>4</entry>
	 <entry>7</entry>
	 <entry>4</entry>
	 <entry>7</entry>
       </row>
       <row>
         <entry>5</entry>
	 <entry>3</entry>
	 <entry>5</entry>
	 <entry>3</entry>
       </row>
       <row>
         <entry>6</entry>
	 <entry>2</entry>
	 <entry>6</entry>
	 <entry>2</entry>
       </row>
       <row>
         <entry>7</entry>
	 <entry>1</entry>
	 <entry>7</entry>
	 <entry>8</entry>
       </row>
       <row>
         <entry>8</entry>
	 <entry>8</entry>
	 <entry>8</entry>
	 <entry>1</entry>
       </row>
       <row>
         <entry>9</entry>
	 <entry>n/c</entry>
	 <entry>9</entry>
	 <entry>n/c</entry>
       </row>
     </tbody>
     </tgroup>
   </table>
 </section> <!-- cabling -->

</article>

