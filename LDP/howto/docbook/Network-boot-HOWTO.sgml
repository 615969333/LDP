<!doctype article public "-//OASIS//DTD DocBook V3.1//EN"
[
  <!entity bbpmail "bbp@via.ecp.fr">

  <!entity logilab "Logilab">
  <!entity logilaburl "http://www.logilab.org">

  <!entity etb "etherboot">
  <!entity etburl "http://etherboot.sourceforge.net/">

  <!entity ltsp "linux terminal server project">
  <!entity ltspurl "http://www.ltsp.org">

  <!entity vmware "VMWare">
  <!entity vmwareurl "http://www.vmware.com">

  <!entity freemware "FreeMWare">
  <!entity freemwareurl "http://www.freemware.org">

  <!entity imggenurl "ftp://www.ltsp.org/pub/download/lts/contrib">

  <!entity disklesshowtourl "http://www.linuxdoc.org/HOWTO/Diskless-HOWTO.html">

  <!entity disklessrootnfshowtourl "http://www.linuxdoc.org/HOWTO/Diskless-root-NFS-HOWTO.html">

  <!entity powerup2bashurl "http://www.linuxdoc.org/HOWTO/From-PowerUp-to-bash-prompt-HOWTO.html">

  <!entity thinclienturl "http://www.linuxdoc.org/HOWTO/Thin-Client-HOWTO.html">

  <!entity cdwritingurl "http://www.linuxdoc.org/HOWTO/CD-Writing-HOWTO.html">

  <!entity netboot "netboot">
  <!entity netbooturl "http://www.han.de/~gero/netboot/">

]>

<article>

<artheader>

  <title>Network boot and exotic root HOWTO</title>

  <authorgroup>
    <author>
      <firstname>Brieuc</firstname>
      <surname>Jeunhomme</surname>
    </author>

    <author>
      <surname>Logilab S.A.</surname>
    </author>
  </authorgroup>

  <abstract>

    <para>This document explains how to quickly setup a linux server to provide
    what diskless linux clients require to get up and running, using an IP
    network. It includes data and partly rewritten text from the Diskless-HOWTO,
    the Diskless-root-NFS-HOWTO, the linux kernel documentation, the &ltsp;'s
    homepage, and the author's personal experience, acquired when working for
    &logilab;. Eventually this document may end up deprecating the
    Diskless-HOWTO and Diskless-root-NFS-HOWTO. Please note that you'll also
    find useful information in the From-PowerUp-to-bash-prompt-HOWTO and the
    Thin-Client-HOWTO.</para>

  </abstract>

  <revhistory>
    <revision>
      <revnumber>0.1.1</revnumber>
      <date>2001-04-09</date>
      <authorinitials>logilab</authorinitials>
      <revremark>First public draft.</revremark>
    </revision>

    <revision>
      <revnumber>0.1</revnumber>
      <date>2000-12-09</date>
      <authorinitials>bej</authorinitials>
      <revremark>Initial draft.</revremark>
    </revision>
  </revhistory>

</artheader>

<sect1>

  <title>Introduction</title>

  <sect2>

    <title>What is this all about&nbsp;?</title>

    <para>Recent linux kernels offer the possibility to boot a linux box
    entirely from network, by loading its kernel and root filesystem from a
    server. In that case, the client may use several ways to get the first
    instructions it has to execute when booting&nbsp;: home made eproms, special
    network cards implementing the BOOTP or DHCP protocols, cdroms, or
    bootloaders loaded from a boot floppy or a local hard drive.</para>

  </sect2>

  <sect2>

    <title>Thanks</title>

    <para>&logilab; sponsored this HOWTO. Check their <ulink
    url="&logilaburl;">website</ulink> for new versions of this document.  I
    also thank the &etb; and &ltsp; developers and webmasters, who made it
    really possible to boot a Linux worstation over a network.</para>

  </sect2>

  <sect2>

    <title>Diskless booting advocacy</title>

    <sect3>

      <title>Buying is cheaper than building</title>

      <para>Sometimes, buying a diskless linux computer will be cheaper than
      building&nbsp;! Checkout the list of commercial sites given in appendix,
      which are selling diskless linux network cards and diskless
      computers. These companies do mass production of linux diskless computers
      selling millions of units and thereby reducing the cost per unit.</para>

    </sect3>

    <sect3>

      <title>Advantages of diskless computers</title>

      <para>Diskless computers will become more and more popular in the next
      years. They will be very successful because of the availability of very
      high-speed network cards at very low prices. Today 100 Megabit per second
      (12.5&nbsp;MB per sec transfer rate) network cards are common and in about
      1 to 2 years 1000&nbsp;MBit (125&nbsp;MB per sec transfer rate) network
      cards will become very cheap and will be the standard.</para>

      <para>In near future, monitor manufacturers will place the CPU, NIC, RAM
      right inside the monitor to form a diskless computer. This eliminates the
      diskless computer box and saves space. The monitor will have outlet for
      mouse, keyboard, network RJ45 and power supply.</para>

      <para>The following are benefits of using diskless computers&nbsp;:</para>

        <itemizedlist mark="opencircle">

          <listitem>
            <para>Total cost of ownership is very low in case of diskless
            computers. Total cost of ownership is cost of initial
            purchasing&nbsp;+ cost of maintenance. The cost of maintenance is
            usually 3 to 5 times the cost of initial computer purchase and this
            cost is recurring year after year. In case of diskless computers,
            the cost of maintenance is completely eliminated.
            </para>
          </listitem>

          <listitem>
            <para>All the backups are centralized at one single main server.
            </para>
          </listitem>

          <listitem>
            <para>No need of UPS battery, air-conditioning, dust proof
            environment for diskless clients, only server needs UPS battery, A/C
            and dust proof environment.
            </para>
          </listitem>

          <listitem>
            <para>A better protection from virus attack&nbsp;- Some computer
            virus cannot attack diskless computers as they do not have any hard
            disk. This kind of virus cannot do any damage to diskless
            computers. Only one single server box need to be protected against
            virus attack. This saves millions of dollars for the company by
            avoiding installation of vaccines and cleaning the hard disks.
            </para>
          </listitem>

          <listitem>
            <para>Servers can have large powerful/high performance hard disks,
            can optimize the usage of disk space via sharing by many diskless
            computer users. Fault tolerance of hard disk failure is possible by
            using RAID on main server.
            </para>
          </listitem>

          <listitem>
            <para>On some installations&nbsp;: sharing of central server RAM
            memory by many diskless computer users. For example, if many users
            are using web browser then in server RAM there will be only one copy
            of web browser in the RAM.
            </para>
          </listitem>

          <listitem>
            <para>Very few system administrators required to maintain central
            server.</para>
          </listitem>

          <listitem>
            <para>Zero administration at diskless client side. Diskless
            computers are absolutely maintenance free and troublefree.
            </para>
          </listitem>

          <listitem>
            <para>Long life of diskless clients&nbsp;- more than 100 years
            without any hardware or software upgrades.
            </para>
          </listitem>

          <listitem>
            <para>Eliminates install/upgrade of hardware, software on diskless
            client side.
            </para>
          </listitem>

          <listitem>
            <para>Eliminates cost of cdrom, floppy, tape drive, modem, UPS
            battery, printer parallel ports, serial ports etc...
            </para>
          </listitem>

          <listitem>
            <para>Can operate in places like factory floor where a hard disk
            might be too fragile.
            </para>
          </listitem>

        </itemizedlist>

    </sect3>

  </sect2>

  <sect2>

    <title>Requirements</title>

    <sect3>

      <title>Hardware requirements</title>

      <para>The most important thing in order to boot from network is to have an
      equipment which enables the stations to execute a bootloader, which will
      get the kernel on the server and launch it. Another solution is to use a
      device which will load a local kernel, which will mount the root
      filesystem on the server. There are several solutions&nbsp;: homemade
      eproms containing the first instructions to execute when booting the
      station, boot with BOOTP/DHCP capable network adapters, or a local floppy,
      a tiny hard drive, or a cdrom to load the kernel. Note that some vendors
      also sell network booting capable stations&nbsp;: for instance, some Sun
      stations implement the BOOTP protocol.</para>

      <para>Other hardware requirements depend on the configuration you plan to
      use&nbsp;: on some sites, every application run by the stations is
      executed remotely on the server, this implies that a very high-performance server
      is required, but only light stations are required&nbsp;: depending on
      what they will have to do, 80486 CPUs with 16&nbsp;MB of RAM may be
      enough. On the other side, if application programs are really executed
      locally on the stations, the requirements for the stations depend
      completely on these applications. In that case, only a small server is
      required. A 80486 CPU with 32&nbsp;MB of RAM will be sufficient for a
      small number of stations, but more memory will be necessary in very large
      installations with hundreds or thousands of machines. Note the server's
      CPU does not really matter for such an installation.</para>

    </sect3>

    <sect3>

      <title>Software requirements</title>

      <para>Recent linux kernel sources are required&nbsp;: 2.2.x kernels will
      do fine, but 2.0.x won't. "What about my 2.1.x kernel&nbsp;?", you may
      wonder. Well, I don't know :=). All tools required to build a linux kernel
      are also necessary (see the linux kernel documentation for more
      information on this).</para>

      <para>A BOOTP daemon (a DHCP daemon may also do fine, but I won't explain
      how to configure this), a NFS daemon, are also required. We will also need
      a TFTP daemon if you plan to load the kernel remotely. At last, the
      mknbi utility provided with the <ulink url="&etburl;">&etb;
      distribution</ulink>, and, if you use the 3c905 3com ethernet adapter, you
      will also need the imggen utility, available at <ulink
      url="&imggenurl;">&imggenurl;</ulink>.</para>

    </sect3>

  </sect2>

  <sect2>

    <title>Acknowledgements and related documentation</title>

    <para>This documentation has been written for experimented system
    administrators, who are already aware of linux fundamentals, like the use of
    grep, sed, and awk, basic shell programming, the init process and the boot
    scripts, kernel compilation, and NFS server configuration. Experience of
    kernel arguments passing should also help. Information on these subjects can
    be found respectively in the grep, sed, awk, and bash man/info pages, in the
    Bootdisk-HOWTO, the From-PowerUp-To-Bash-Prompt-HOWTO, the Kernel-HOWTO,
    the BootPrompt-HOWTO, the bootparam man page, the rdev man page, the
    NFS-HOWTO, and the <command>exports</command> manual page.</para>

    <para>There are many sources of information on network booting, but, and
    this is why I wrote this HOWTO, none describes all the existing ways of
    booting over a network, and much of them are specific to a way of
    operating. The most useful to me has been the documentation provided by the
    <ulink url="&ltspurl;">&ltsp;</ulink>, although I did not use the packages
    they recommend, and I have chosen to describe here how to proceed without
    these packages, because they configure things so that every application
    program is executed remotely on a server. Useful information can also be found
    on the <ulink url="&etburl;">&etb; project's homepage</ulink>.</para>

    <para>At last, you can also find useful but succinct information in the
    kernel's source tree, in /usr/src/linux/Documentation, assuming your kernel
    source tree resides in /usr/src/linux.</para>

  </sect2>

  <sect2>

    <title>Feedback</title>

    <para>I will highly appreciate any feedback about this document. Please feel
    free to mail me at <email>&bbpmail;</email> if you have any comment,
    correction, or suggestion. You mail also use
    <email>contact@logilab.fr</email>.</para>

  </sect2>

  <!-- Section2: copyright -->

  <sect2 id="copyright">
   <title>Copyright Information</title>

   <para>
    This document is copyrighted (c) 2001 and is
    distributed under the terms of the Linux Documentation Project
    (LDP) license, stated below.
   </para>

   <para>
    Unless otherwise stated, Linux HOWTO documents are
    copyrighted by their respective authors. Linux HOWTO documents may
    be reproduced and distributed in whole or in part, in any medium
    physical or electronic, as long as this copyright notice is
    retained on all copies. Commercial redistribution is allowed and
    encouraged; however, the author would like to be notified of any
    such distributions.
   </para>

   <para>
    All translations, derivative works, or aggregate works
    incorporating any Linux HOWTO documents must be covered under this
    copyright notice. That is, you may not produce a derivative work
    from a HOWTO and impose additional restrictions on its
    distribution. Exceptions to these rules may be granted under
    certain conditions; please contact the Linux HOWTO coordinator at
    the address given below.
   </para>

   <para>
    In short, we wish to promote dissemination of this
    information through as many channels as possible. However, we do
    wish to retain copyright on the HOWTO documents, and would like to
    be notified of any plans to redistribute the HOWTOs.
   </para>

   <para>
    If you have any questions, please contact
    <email>linux-howto@metalab.unc.edu</email>
   </para>
  </sect2>

</sect1>

<sect1>

  <title>Diskless booting operation overview</title>

  <para>Hey, you think it's time to start with the real stuff, right&nbsp;? Here
  we go.</para>

  <sect2>

    <title>Obtaining IP parameters</title>

    <para>One could wonder how a station may boot over an IP network if it
    doesn't even know its own IP address. In fact, three protocols enable the
    client to obtain this information and some additional configuration
    parameters&nbsp;:

      <itemizedlist mark="opencircle">

        <listitem>
          <para>RARP&nbsp;: this is the simplest of these protocols. However I
          guess it does not enable the server to specify how the client should
          download the kernel, so we won't use it.</para>
        </listitem>

        <listitem>
          <para>BOOTP&nbsp;: this protocol allows a server to provide the client
          (identified by its hardware MAC address) with much information, in
          particular its IP address, subnet mask, broadcast address, network
          address, gateway address, host name, and kernel loading path. This is
          the one we will use.</para>
        </listitem>

        <listitem>
          <para>DHCP&nbsp;: this is an extension of BOOTP.</para>
        </listitem>

      </itemizedlist>
    </para>

  </sect2>

  <sect2>

    <title>Loading the kernel</title>

    <para>When the client has got its IP parameters, if the kernel is not on a
    local support (like a floppy, a cdrom, or a hard drive), the client will
    start to download it via TFTP. Its location is given by the BOOTP server. A
    server (not necessarily the BOOTP server) will also have to run a TFTP
    daemon for non local kernels. The kernel one obtains after compilation can
    not be used "as is" for BOOTP operation, its binary image has to be modified
    with the mknbi utility (and then modified again with the imggen utility if
    you use 3com 3c905 NICs).</para>

  </sect2>

  <sect2>

    <title>Mounting the root filesystem</title>

    <para>After the kernel has started, it will try to mount its root
    filesystem. The location of this filesystem is also obtained through BOOTP,
    and it is mounted via NFS. It means a client may use BOOTP twice for
    booting&nbsp;: the first time to get its kernel, and the second time to
    learn the location of the root filesystem (which may be on a third
    server).</para>

  </sect2>

  <sect2>

    <title>Terminating the boot process</title>

    <para>When the root filesystem is mounted, you can start breathing&nbsp;:
    you can at least use your swiss army knife with its sh, sed, and awk
    blades. In fact, you will have to customize the initialization scripts of
    the client's filesystem&nbsp;: for instance, you will have to remove all
    hard drive, floppy or cdrom related stuff from /etc/fstab (when your
    stations are not equipped with these devices), you may also have to inhibit
    swap partitions activation (note there is a way to swap over NFS, but this
    possibility is not documented here). You also will have to automagically
    generate all network configuration files at boot time if several clients use
    the same remote root filesystem.</para>

  </sect2>

</sect1>

<sect1>

    <title>Building the kernel</title>

    <para>Firs of all, build a kernel for the clients. I suggest you build it on
    the server, this will be useful later for modules installation. Use a
    bzImage to reduce its size. Include everything you need, but try to use as
    many modules as possible, because many BOOTP client implementations are
    unable to load very large kernels (at least on intel x86
    architectures). Also include NFS protocol support, root filesystem on NFS
    support, support for your NIC, kernel level IP autoconfiguration via
    BOOTP&nbsp;; <emphasis>do not use modules for these&nbsp;!</emphasis> Then
    if you plan to use the same remote root filesystem for several clients, add
    support for ext2fs or some other filesystem and ramdisks (16 Megabytes
    ramdisks will do fine on most systems). You can then modify the kernel
    arguments as usual (see the BootPrompt-HOWTO for information on this topic),
    but you will have another opportunity to modify kernel arguments
    later.</para>

    <para>Then, if you plan to use BOOTP, copy the kernel bzImage on the
    server. We will assume it resides in /tftpboot, its name is bzImage, the
    name of the image you want to create from this bzImage for BOOTP operation
    is kernel, and the nfs root filesystem will reside in /nfsroot.</para>

    <para>Issue the following commands on the server (the mknbi package should
    be installed)&nbsp;:

      <programlisting>
        <prompt># </prompt>cd /tftpboot
        <prompt># </prompt>chmod 0555 bzImage
        <prompt># </prompt>chown root:root bzImage
        <prompt># </prompt>mknbi-linux bzImage --output=kernel --rootdir=/nfsroot
      </programlisting>

    </para>

    <para>If you are using 3com 3c905 NICs, also issue the following commands
    (you need the imggen utility)&nbsp;:

      <programlisting>
        <prompt># </prompt>mv -f kernel tmpkernel
        <prompt># </prompt>imggen -a tmpkernel kernel
        <prompt># </prompt>rm -f tmpkernel
      </programlisting>

    </para>

    <para>Your kernel is ready for BOOTP operation. If you do not plan to use
    BOOTP, but a local floppy, just put the kernel on the kernel on this floppy
    with a command like&nbsp;:

      <programlisting>
        <prompt># </prompt>dd if=bzImage of=/dev/fd0 bs=4096
      </programlisting>

    </para>

    <para>Or, if you plan to use a local hard drive, just use your favorite
    bootloader as usual.</para>

</sect1>

<sect1>

  <title>Daemons setup</title>

  <sect2>

    <title>NFS daemon</title>

    <para>Just export the directory in which the client's root filesystem will
    reside (see the export manpage for more information about this topic). The
    simplest is to export it no_root_squash and rw, but a perfect setup would
    export most of the root filesystem root_squash and ro, and have separate
    lines in the /etc/exports for directories which really require
    no_root_squash and/or rw. Just start with everything rw and no_root_squash,
    the fine tuning will be done later.</para>

  </sect2>

  <sect2>

    <title>BOOTP daemon</title>

    <para>I assume you have installed the bootpd package. The default
    configuration file is /etc/bootptab, and its syntax is detailed in the
    bootptab manpage. Let's create it.</para>

    <para>First, open as root your favourite text editor. It is vim. Yes, it
    is. If it is not, it has to become. Now, enter the following lines (they are
    the default attributes)&nbsp;all the attributes you give here and do not
    override in a machine's specific attributes list will be given to
    clients)&nbsp;:

      <programlisting>
        .default\
                :sm=your subnet mask\
                :ds=the IP address of your DNS server\
                :ht=ethernet\
                :dn=your domain name\
                :gw=the IP address of your gateway\
                :sa=the IP address of the TFTP server\
                :bf=path to find the kernel image\
                :rp=path of the root filesystem\
                :hn
      </programlisting>

    Of course, not all these parameters are required, this depends on your
    network configuration and BOOTP implementations, but these will work in most
    cases.</para>

    <para>Then, add an entry per client in your network. An entry should look
    like this&nbsp;:

      <programlisting>
        dns of the client\
                :ha=MAC address of the client\
                :ip=IP address of the client
      </programlisting>

    The MAC address above is the hexadecimal hardware address of the client
    without the ':' characters.</para>

    <para>Here is a sample /etc/bootptab file&nbsp;:

      <programlisting>
              .default\
                      :sm=255.255.0.0\
                      :ds=192.168.0.2\
                      :ht=ethernet\
                      :dn=test.org\
                      :gw=192.168.0.1\
                      :sa=192.168.0.2\
                      :bf=/tftpboot/kernel\
                      :rp=/nfsroot\
                      :hn

              foo\
                      :ha=001122334455\
                      :ip=192.168.2.12

              bar\
                      :ha=00FFEEDDCCBB\
                      :ip=192.168.12.42\
                      :ds=192.168.2.42
      </programlisting>

    </para>

    <para>Then, run the bootpd daemon with the bootpd&nbsp;-s command (it is
    also a good idea to add it to your startup scripts), or add the following
    line to your /etc/inetd.conf&nbsp;:

      <programlisting>
        bootps dgram udp wait root /usr/sbin/tcpd&nbsp;bootpd -i -t 120
      </programlisting>

    </para>

    <para>If you want to test the BOOTP server, add an entry to your
    /etc/bootptab and use the bootptest program.</para>

  </sect2>

  <sect2>

    <title>TFTP</title>

    <para>Setting up the TFTP daemon is not the hard part&nbsp;: just install
    the tftpd package if you have one, and add the following line to your
    /etc/inetd.conf (again, I assume /tftpboot is the directory where the kernel
    image resides)&nbsp;:

      <programlisting>
        tftp dgram udp wait root /usr/sbin/tcpd in.tftpd /tftpboot
      </programlisting>

    Don't forget to chmod&nbsp;555 the /tftpboot directory, as most TFTP servers
    won't send the files if they are not world readable.</para>

    <para>Now you have properly setup all daemons, you can restart the inetd and
    take a coffee. Don't forget to tell everyone the server setup is over, so
    you think you're a hero before you start building the root filesystem for
    the clients.</para>

  </sect2>

</sect1>

<sect1>

  <title>Clients setup</title>

  <para>Tired&nbsp;? No you're not. Remember you're a hero. Here becomes the
  tricky part. We will (err... <emphasis>you</emphasis> will) build the client's
  root filesystem. This shouldn't be very hard, but you probably will have to
  use trial and error.</para>

  <para>The simplest way to create a root filesystem is to use an already
  working filesystem and customize it for the needs of diskless operation. Of
  course, you can also build one by hand (like in the good old times) if you like
  :=), but I won't explain this here.</para>

  <sect2>

    <title>Creating the first files and directories</title>

    <para>First, <command>cd</command> to your future station's root
    directory. You can safely create the future <filename
    class="directory">/home</filename> directory with <command>mkdir</command>,
    or by copying it from anywhere you want (you can use <command>cp
    -a</command> to do a recursive copy preserving owners, groups, symlinks, and
    permissions). Same thing for the future <filename
    class="directory">/mnt</filename>, <filename
    class="directory">/root</filename>, <filename
    class="directory">/tmp</filename> (don't forget to <command>chmod
    0</command> it, this is only a mount point for the actual <filename
    class="directory">/tmp</filename> we will use, because each workstation
    needs to have its own <filename class="directory">/tmp</filename>). Then,
    copy some existing <filename class="directory">/bin</filename>, <filename
    class="directory">/sbin</filename>, <filename
    class="directory">/boot</filename>, and /usr into this future root directory
    (use <command>cp -a</command>). You can create the /proc directory with
    mkdir, and chmod&nbsp;0 it. Note some applications need write access to
    their user's home directory.</para>

    <para>The <filename class="directory">/lib</filename> directory can be
    safely copied from somewhere else, but you will have to put the proper
    modules in it. To do so, use the following commands (assuming you have
    compiled the kernel for your clients on the server in <filename
    class="directory">/usr/src/linux</filename>, and the root filesystem will
    reside in <filename class="directory">/nfsroot</filename>)&nbsp;:

      <programlisting>
        <prompt># </prompt>cd /usr/src/linux
        <prompt># </prompt>make modules_install INSTALL_MOD_PATH=/nfsroot
      </programlisting>

    </para>

    <para>Don't forget to put the System.map file in <filename
    class="directory">/nfsroot/boot</filename>. A first problem we will have to
    fix is that, depending on your configuration, your system may try to run
    fsck on the root filesystem at boot time. It shouldn't. Most distributions
    will also skip this fsck if they find a fastboot file in the root
    directory. So, issue the following commands&nbsp;:

      <programlisting>
        <prompt># </prompt>cd /nfsroot
        <prompt># </prompt>touch fastboot
        <prompt># </prompt>chmod 0 fastboot
      </programlisting>

    </para>

    <para>The <filename class="directory">/dev</filename> directory can also be
    safely copied from another place into /nfsroot. But permissions and symlinks
    have to be preserved, so use cp&nbsp;-a. Another solution is to use kernel
    2.2.x devfs feature, which will reduce memory consumption and improve
    performance, but the drawback of this method is that all symlinks created in
    <filename class="directory">/dev</filename> will be lost. The point to
    remember is that each workstation needs to have its own <filename
    class="directory">/dev</filename>, so you will have to copy it on a ramdisk
    if you plan to use several clients.</para>

  </sect2>

  <sect2>

    <title>The /var and /etc directories</title>

    <para>We will use ramdisks for these directories, because each client needs
    to have its own one. But we still need them at the beginning to create their
    standard structure. Note you are not required to do so if you use a single
    client. So copy these directories (cp&nbsp;-a) from another place into
    /nfsroot. Then you can make some cleanup in /var&nbsp;: you can remove
    everything in /nfsroot/var/log and /nfsroot/var/run. You also probably can
    remove everything in /nfsroot/var/spool/mail, if you plan to export it via
    NFS. You also will have to remove the files containing host specific
    information in /nfsroot/etc to build them on the fly during the boot
    process.</para>

    <para>The startup scripts will have to be customized in order to mount some
    parts of the filesystem&nbsp;: the /dev directory, if you don't use devfs,
    the /tmp, the /var, and the /etc directories. Here is some code which will
    achieve this&nbsp;:

      <programlisting>
        # this part only if you don't use devfs
        mke2fs -q -i 1024 /dev/ram0 16384
        mount -n -t ext2 -o rw,suid,dev,exec, \
            async,nocheck /dev/ram0 /dev
        # this part for everyone
        mke2fs -q -i 1024 /dev/ram1 16384
        mount -n -t ext2 -o rw,suid,dev,exec, \
            async,nocheck /dev/ram1 /tmp
        chmod 1777 /tmp
        cp -a /etc /tmp
        mke2fs -q -i 1024 /dev/ram2 16384
        mount -n -t ext2 -o rw,suid,dev,exec, \
            async,nocheck /dev/ram2 /etc
        find /tmp/etc -maxdepth 1 -exec cp -a '{}' /etc ';'
        mount -f -t ext2 -o rw,suid,dev,exec, \
            async,nocheck,remount /dev/ram2 /etc
        mount -f -o remount /
        cp -a /var /tmp
        mke2fs -q -i 1024 /dev/ram3 16384
        mount -t ext2 -o rw,suid,dev,exec, \
            async,nocheck /dev/ram3 /var
        find /tmp/var -maxdepth 1 -exec cp -a '{}' /var ';'
      </programlisting>

    </para>

    <para>You will also have to change files dynamically at boot time in
    /etc&nbsp;: the files which contain the IP and hostname of the client. These
    files depend on your distribution, but you will easily find them with a few
    greps. Just remove client-specific information from them, and add code into
    your startup files to generate this information again at boot time
    <emphasis>but only once the new /etc has been mounted on the
    ramdisk&nbsp;!</emphasis>. A way to obtain your IP address and hostname at
    bootup is the following (if you have the bootpc package installed on the
    workstations'filesystem)&nbsp;:

      <programlisting>
        IPADDR="$(bootpc | awk '/IPADDR/ \
                                {
                                  match($0,"[A-Za-z]+")
                                  s=substr($0,RSTART+RLENGTH)
                                  match(s,"[0-9.]+")
                                  print substr(s,RSTART,RLENGTH)
                                }
                               ')"

        HOST="$(bootpc | awk '/HOSTNAME/ \
                              {
                                match($0,"[A-Za-z]+")
                                s=substr($0,RSTART+RLENGTH)
                                match(s,"[A-Za-z0-9-]+")
                                print substr(s,RSTART,RLENGTH)
                              }')"

        DOMAIN="$(bootpc | awk '/DOMAIN/ \
                                {
                                  match($0,"[A-Za-z]+")
                                  s=substr($0,RSTART+RLENGTH)
                                  match(s,"[A-Za-z0-9-.]+")
                                  print substr(s,RSTART,RLENGTH)
                                }')"
      </programlisting>

    This is a complicated solution, but I guess it should work on most
    sites. The IP address can alternatively be obtained with the output of
    ifconfig and the hostname can be obtained from the output of the host
    command, but this is not portable, because these outputs differ from system
    to system depending on the distribution you are using, and the locales
    settings.</para>

    <para>Then, the hostname should be set with the hostname&nbsp;$HOSTNAME
    command. When this is done, it is time to generate on the fly the
    configuration files which contain the IP address or the hostname of the
    client.</para>

  </sect2>

  <sect2>

    <title>Last details</title>

    <para>Now, it's time to do the fine tuning of the client. As /var is mounted
    on a ramdisk, you will have to send the logs to a logs server if you want to
    keep them. One way to do that is to delete the /nfsroot/etc/syslog.conf file
    and replacing it by the following file (see man syslog.conf for
    details)&nbsp;:

      <programlisting>
        *.*     /dev/tty12
        *.*     @dns or IP of the logs server
      </programlisting>

    If you do so, the logs server will have to run syslogd with the -r option
    (see the <command>syslogd</command> manual page).</para>

    <para>If you use logrotate and you have done the preceding operation, you
    should replace the logrotate configuration file (/etc/logrotate.conf on most
    boxes) by an empty file&nbsp;:

      <programlisting>
        <prompt># </prompt>rm -f /etc/logrotate.conf
        <prompt># </prompt>touch /etc/logrotate.conf
      </programlisting>

    If you don't use it, just remove the logs rotation scripts from the crontab,
    and as you no longer have log files in /var/log, put an exit&nbsp;0 at the
    beginning of your logs rotation scripts.</para>

    <para>In the /nfsroot/etc/fstab file, remove anything related to the hard
    drive, floppy disk reader, or cdrom. Add an entry for the /var/spool/mail
    directory, which should be exported by the server through NFS or any other
    network filesystem. You probably also want to put an entry for the /home
    directory in this file.</para>

    <para>You can also comment the lines running newaliases, activating swap,
    and running depmod&nbsp;-a and remove the /nfsroot/etc/mtab file. Comment
    out the line(s) removing /fastboot, /fsckoptions, and /forcefsck in your
    startup scripts. Also remove or comment any line in the startup scripts that
    would try to write on the root filesystem except for really necessary
    writes, which should all be redirected to some ramdisk locationi if you use
    several clients.</para>

  </sect2>

  <sect2>

    <title>Trial...</title>

    <para>Time has come for a small trial. MAKE A BACKUP OF YOUR NEWLY CREATED
    /nfsroot. tar&nbsp;-cvvIf should do fine. Take a minute to verify we didn't
    forget anything. Try to boot a client.</para>

  </sect2>

  <sect2>

    <title>And Error&nbsp;!</title>

    <para>Look carefully at the client's screen during the boot process. Oh, I
    didn't tell you to connect a screen... Run, forest&nbsp;! Run an get
    one. You will probably see some error messages. Fix the problems, and make
    frequent backups of your /nfsroot. One day, the client will boot
    properly. This day, you will have to fix errors occurring during shutdown
    ;=P.</para>

  </sect2>

</sect1>

<sect1>

  <title>Several ways of obtaining the bootloader's code</title>

  <para>We have spoken so far about the client and server's configuration for
  operation after the BOOTP request has been issued by the client, but the first
  problem is that most computers are not able to behave as BOOTP clients by
  default. We will see in this section how to fix this.</para>

  <sect2>

    <title>BOOTP capable NICs</title>

    <para>This is the most simple case&nbsp;: some network cards provide a
    supplement to the BIOS, containing a BOOTP client, so just setup them for
    BOOTP operation in the BIOS, and you're done.</para>

  </sect2>

  <sect2>

    <title>Local floppy or hard drive</title>

    <para>These cases are also quite simple&nbsp;: the kernel is loaded from a
    local drive, and all the kernel has to do is to obtain its network
    parameters from BOOTP, and mount its root filesystem over NFS&nbsp;; this
    should not cause any problem. By the way, a local hard drive is a good place
    to leave a /var, /tmp, and a /dev...</para>

    <para>If you have a local hard drive, all you have to do is to use lilo or
    your favourite boot loader as usual. If you use a floppy, you can use a
    bootloader or simply write the kernel on the floppy&nbsp;: a kernel is
    directly bootable.</para>

  </sect2>

  <sect2>

    <title>Creating ROMs for the clients</title>

    <para>In appendix, you'll find the information about EPROM and various types
    of memory chips.</para>

    <para>For a list of EPROM burner manufacturers visit the Yahoo site and go
    to <ulink
    url="http://dir.yahoo.com/Business_and_Economy/Companies/Computers/Hardware/Peripherals/Device_Programmers/">economy->company->Hardware->Peripherals->Device
    programmers</ulink> or check out the old Diskless-HOWTO <emphasis>List of
    EPROM burner manufacturers</emphasis> section.</para>

    <sect3>

      <title>LanWorks BootWare PROMs</title>

      <para>This information may save you time. In order to make LanWorks
      BootWare(tm) PROMs to correctly start up a linux kernel image, the
      "bootsector" part of the image must be modified so as to enable the boot
      prom to jump right into the image start address. The net-bootable image
      format created by netboot/etherboot's `mknbi-linux' tool differs and will
      not run if used with BootWare PROMs.</para>

      <para>A modified bootsector together with a Makefile to create a
      BootWare-bootable image after kernel compilation can be found at&nbsp;-

        <itemizedlist mark="opencircle">

          <listitem>
            <para>Bwimage package&nbsp;: <ulink
            url="ftp://ftp.ipp.mpg.de/pub/ipp/wls/linux/bwimage-0.1.tgz">ftp://ftp.ipp.mpg.de/pub/ipp/wls/linux/bwimage-0.1.tgz</ulink></para>
          </listitem>

          <listitem>
            <para>See also <ulink
            url="http://www.patoche.org/LTT/net/00000096.html">http://www.patoche.org/LTT/net/00000096.html</ulink></para>
          </listitem>

          <listitem>
            <para>LanWorks BootWare Boot ROMs&nbsp;: <ulink
            url="http://www.3com.com/lanworks">http://www.3com.com/lanworks</ulink></para>
          </listitem>

        </itemizedlist>

      </para>

      <para>Refer to the README file for installation details. Currently, only
      "zImage"-type kernels are supported. Unfortunately, kernel parameters are
      ignored.</para>

      <para>This section was initially written by Jochen Kmietsch for the
      Diskless-HOWTO, email to&nbsp;-
      <email>jochen.kmietsch@tu-clausthal.de</email> for any questions.</para>

    </sect3>

  </sect2>

  <sect2>

    <title>Local CDROM</title>

    <para>This section was originally written by Hans de Goede
    <email>j.w.r.degoede@et.tudelft.nl</email> for the
    Diskless-root-NFS-HOWTO. I modified it slightly in order to reflect some
    differences between this document and the Diskless-root-NFS-HOWTO.</para>

    <para>Much of the above also goes for booting from cdrom. Why would one want
    to boot a machine from cdrom&nbsp;? Booting from cdrom is interesting
    everywhere one wants to run a very specific application, like a kiosk, a
    library database program or an internet cafe, and one doesn't have a network
    or a server to use a root over nfs setup.</para>

    <sect3>

      <title>Creating a test setup</title>

      <para>Now that we know what we want to do and how, it's time to create a
      test setup&nbsp;:

        <itemizedlist mark="opencircle">

          <listitem>
            <para>For starters just take one of the machines which you want to
            use and put in a big disk and a cd burner.</para>
          </listitem>

          <listitem>
            <para>Install your linux of choice on this machine, and leave a
            650&nbsp;MB partition free for the test setup. This install will be
            used to make the iso image and to burn the cd's from, so install the
            necessary tools. It will also be used to restore any booboo's which
            leave the test setup unbootable.</para>
          </listitem>

          <listitem>
            <para>On the 650 mb partition install your linux of choice with the
            setup you want to have on the cd, this will be the test
            setup.</para>
          </listitem>

          <listitem>
            <para>Boot the test setup.</para>
          </listitem>

          <listitem>
            <para>Compile a kernel with isofs and cdrom support compiled in.</para>
          </listitem>

          <listitem>
            <para>Configure the test setup as described above with the root
            filesystem mounted read only.</para>
          </listitem>

          <listitem>
            <para>Verify that the test setup automagically boots and everything
            works.</para>
          </listitem>

          <listitem>
            <para>Boot the main install and mount the 650&nbsp;MB partition on
            /test of the main install.</para>
          </listitem>

          <listitem>
            <para>Put the following in a file called /test/etc/rc.d/rc.iso, this
            file will be sourced at the beginning of rc.sysinit to create
            /var&nbsp;:

              <programlisting>
                #/var
		echo Creating /var ...
		mke2fs -q -i 1024 /dev/ram1 16384
		mount /dev/ram1 /var -o defaults,rw
		cp -a /lib/var /
              </programlisting>
            </para>
          </listitem>

          <listitem>
            <para>Edit /test/etc/rc.sysinit, comment the lines where the root is
            remounted rw, and add the following 2 lines directly after setting
            the PATH&nbsp;:

              <programlisting>
                #to boot from cdrom
		. /etc/rc.d/rc.iso
              </programlisting>
            </para>
          </listitem>

          <listitem>
            <para>Copy the following to a script and execute it to make a
            template for /var and create /tmp and /etc/mtab links.

              <programlisting>

                #!/bin/sh
		echo tmp
		rm -fR /test/tmp
		ln -s var/tmp /test/tmp

		###
		echo mtab
		touch /test/proc/mounts
		rm /test/etc/mtab
		ln -s /proc/mounts /test/etc/mtab

		###
		echo var
		mv /test/var/lib /test/lib/var-lib
		mv /test/var /test/lib
		mkdir /test/var
		ln -s /lib/var-lib /test/lib/var/lib
		rm -fR /test/lib/var/catman
		rm -fR /test/lib/var/log/httpd
		rm -f /test/lib/var/log/samba/*
		for i in `find /test/lib/var/log -type f`; do
		  cat /dev/null > $i;
		done
		rm `find /test/lib/var/lock -type f`
		rm `find /test/lib/var/run -type f`

              </programlisting>

            </para>
          </listitem>

          <listitem>
            <para>Remove the creation of /etc/issue* from
            /test/etc/rc.local&nbsp;: it will only fail.</para>
          </listitem>

          <listitem>
            <para>Now boot the test partition again, it will be read only just
            like a cdrom. If something doesn't work reboot to the working
            partition fix it, try again etc. Or you could remount / rw, fix it
            then reboot straight into to test partition again. To remount / rw
            type:

              <programlisting>
                <prompt># </prompt>mount -o remount,rw /
              </programlisting>

            </para>
          </listitem>

        </itemizedlist>

      </para>

    </sect3>

    <sect3>

      <title>Creating the CD</title>

      <para>If you need more information than you can find below, please refer
      to the CD-Writing-HOWTO.</para>

      <sect4>

        <title>Creating a boot image</title>

        <para>First of all, boot into the working partition. To create a
        bootable cd we'll need an image of a bootable floppy. Just dd-ing a
        zimage doesn't work since the loader at the beginning of the zimage
        doesn't seem to like the fake floppydrive a bootable cd creates. So
        we'll use syslinux instead.

        <itemizedlist mark="opencircle">

          <listitem>
            <para>Get boot.img from a redhat cd.</para>
          </listitem>

          <listitem>
            <para>Mount boot.img somewhere through loopback by typing&nbsp;:

              <programlisting>
                <prompt># </prompt>mount boot.img somewhere -o loop -t vfat
              </programlisting>
            </para>
          </listitem>

          <listitem>
            <para>Remove everything from boot.img except for ldlinux.sys and
            syslinux.cfg.</para>
          </listitem>

          <listitem>
            <para>Cp the kernel-image from the test partition to boot.img.</para>
          </listitem>

          <listitem>
            <para>Edit syslinux.cfg so that it contains the following, of course
            replace zImage by the appropriate image name&nbsp;:

              <programlisting>

                default linux 

                label linux
                kernel zImage
                append root=/dev/&lt;insert your cdrom device here&gt;

              </programlisting>

            </para>

          </listitem>

          <listitem>
            <para>Umount boot.img&nbsp;:

              <programlisting>
                <prompt># </prompt>umount somewhere
              </programlisting>
            </para>
          </listitem>

          <listitem>
            <para>If your /etc/mtab is a link to /proc/mounts, umount won't
            automagically free /dev/loop0 so free it by typing&nbsp;:

              <programlisting>
                <prompt># </prompt>losetup -d /dev/loop0
              </programlisting>
            </para>
          </listitem>

        </itemizedlist>

        </para>

      </sect4>

      <sect4>

        <title>Creating the iso image</title>

        <para>Now that we have the boot image and an install that can boot from
        a readonly mount it's time to create an iso image of the cd&nbsp;:

          <itemizedlist mark="opencircle">

            <listitem>
              <para>Copy boot.img to /test</para>
            </listitem>

            <listitem>
              <para>Cd to the directory where you want to store the image and
              make sure it's on a partition with enough free space.</para>
            </listitem>

            <listitem>
              <para>Now generate the image by typing&nbsp;:

                <programlisting>
                  <prompt># </prompt>mkisofs -R -b boot.img -c boot.catalog -o boot.iso /test
                </programlisting>
              </para>
            </listitem>

          </itemizedlist>

        </para>

      </sect4>

      <sect4>

        <title>Verifying the iso image</title>

        <para>
          <itemizedlist mark="opencircle">

            <listitem>
              <para>Mounting the image through the loopbackdevice by
              typing&nbsp;:

                <programlisting>
                  <prompt># </prompt>mount boot.iso somewhere -o loop -t iso9660
                </programlisting>
              </para>
            </listitem>

            <listitem>
              <para>Umount boot.iso&nbsp;:

                <programlisting>
                  <prompt># </prompt>umount somewhere
                </programlisting>
              </para>
            </listitem>

            <listitem>
              <para>If your /etc/mtab is a link to /proc/mounts umount won't
              automagically free /dev/loop0 so free it by typing&nbsp;:

              <programlisting>
                <prompt># </prompt>losetup -d /dev/loop0
              </programlisting>
              </para>
            </listitem>

          </itemizedlist>

        </para>

      </sect4>

      <sect4>

        <title>Writing the actual CD</title>

        <para>Assuming that you've got cdrecord installed and configured for
        your cd-writer type&nbsp;:

          <programlisting>
            <prompt># </prompt>cdrecord -v speed=&lt;desired writing speed&gt; dev=&lt;path to your writers generic scsi device&gt; boot.iso
          </programlisting>
        </para>

      </sect4>

    </sect3>

    <sect3>

      <title>Boot the cd and test it</title>

      <para>Well the title of this paragraph says it all ;)</para>

    </sect3>

  </sect2>

</sect1>

<sect1>

  <title>How to create diskless MS-Windows stations&nbsp;?</title>

  <para>Since MS-Windows does not support diskless booting, a simple workaround
  is presented here&nbsp;: the solution is to use software like <ulink
  url="&vmwareurl;">&vmware;</ulink> or its free alternative, <ulink
  url="&freemwareurl;">&freemware;</ulink>. These enable MS-Windows to be executed
  transparently on the linux box.</para>

</sect1>

<sect1>

  <title>Troubleshooting, tips, tricks, and useful links</title>

  <sect2>

    <title>The &netboot; distribution</title>

    <para>This <ulink url="&netbooturl;">distribution</ulink> contains a
    bootloader enabling one to boot diskless stations with either Linux or
    DOS. This is an alternative to the usage of etherboot.</para>

  </sect2>

  <sect2>

    <title>Reducing diskless workstations'memory usage</title>

    <para>One simple way to reduce memory consumption is to put several
    dynamically created directories on the same ramdisk. For instance, let's say
    the first ramdisk will contain the /tmp directory. Then, one may move the
    /var/tmp directory on that ramdisk with the following commands issued on the
    server&nbsp;:

      <programlisting>
        <prompt># </prompt>mkdir /nfsroot/tmp/var
        <prompt># </prompt>chmod 0 /nfsroot/tmp/var
        <prompt># </prompt>ln -s /tmp/var /nfsroot/var/tmp
      </programlisting>

    </para>

  </sect2>

  <sect2>

    <title>Getting rid of error messages about /etc/mtab or unmounted
    directories on shutdown</title>

    <para>The following commands, issued on the server may solve the problem&nbsp;:

      <programlisting>
        <prompt># </prompt>ln -s /proc/mounts /nfsroot/etc/mtab
        <prompt># </prompt>touch /nfsroot/proc/mounts
      </programlisting>
    </para>

  </sect2>

  <sect2>

    <title>Installing new packages on workstations</title>

    <para>A simple way to do so is to use, on the server, a chroot and then
    execute your favourite installation commands normally. To chroot to the
    appropriate place, use the following command&nbsp;:

      <programlisting>
        <prompt># </prompt>chroot /nfsroot
      </programlisting>
    </para>

    <para>Debian users will be particularly interested in the --root option of
    dpkg, which simply tells dpkg where the root of the target system is.
    </para>

  </sect2>

</sect1>

<appendix>

  <title>Non-Volatile Memory chips</title>

  <para>Here is a brief descriptions of memory chips and their types&nbsp;:

    <itemizedlist mark="opencircle">

      <listitem>
        <para>PROM&nbsp;: Pronounced prom, an acronym for programmable read-only
        memory. A PROM is a memory chip on which data can be written only
        once. Once a program has been written onto a PROM, it remains there
        forever. Unlike RAM, PROMs retain their contents when the computer is
        turned off. The difference between a PROM and a ROM (read-only memory)
        is that a PROM is manufactured as blank memory, whereas a ROM is
        programmed during the manufacturing process. To write data onto a PROM
        chip, you need a special device called a PROM programmer or PROM
        burner. The process of programming a PROM is sometimes called burning
        the PROM. An EPROM (erasable programmable read-only memory) is a special
        type of PROM that can be erased by exposing it to ultraviolet
        light. Once it is erased, it can be reprogrammed. An EEPROM is similar
        to a PROM, but requires only electricity to be erased.</para>
      </listitem>

      <listitem>
        <para>EPROM&nbsp;: Acronym for erasable programmable read-only memory,
        and pronounced e-prom, EPROM is a special type of memory that retains
        its contents until it is exposed to ultraviolet light. The ultraviolet
        light clears its contents, making it possible to reprogram the
        memory. To write to and erase an EPROM, you need a special device called
        a PROM programmer or PROM burner. An EPROM differs from a PROM in that a
        PROM can be written to only once and cannot be erased. EPROMs are used
        widely in personal computers because they enable the manufacturer to
        change the contents of the PROM before the computer is actually
        shipped. This means that bugs can be removed and new versions installed
        shortly before delivery. A note on EPROM technology&nbsp;: The bits of
        an EPROM are programmed by injecting electrons with an elevated voltage
        into the floating gate of a field-effect transistor where a 0 bit is
        desired. The electrons trapped there cause that transistor to conduct,
        reading as 0. To erase the EPROM, the trapped electrons are given enough
        energy to escape the floating gate by bombarding the chip with
        ultraviolet radiation through the quartz window. To prevent slow erasure
        over a period of years from sunlight and fluorescent lights, this quartz
        window is covered with an opaque label in normal use.</para>
      </listitem>

      <listitem>
        <para>EEPROM&nbsp;: Acronym for electrically erasable programmable
        read-only memory. Pronounced double-e-prom or e-e-prom, an EEPROM is a
        special type of PROM that can be erased by exposing it to an electrical
        charge. Like other types of PROM, EEPROM retains its contents even when
        the power is turned off. Also like other types of ROM, EEPROM is not as
        fast as RAM. EEPROM is similar to flash memory (sometimes called flash
        EEPROM). The principal difference is that EEPROM requires data to be
        written or erased one byte at a time whereas flash memory allows data to
        be written or erased in blocks. This makes flash memory faster.</para>
      </listitem>

      <listitem>
        <para>FRAM&nbsp;: Short for Ferroelectric Random Access Memory, a type
        of non-volatile memory developed by Ramtron International
        Corporation. FRAM combines the access speed of DRAM and SRAM with the
        non-volatility of ROM. Because of its high speed, it is replacing EEPROM
        in many devices. The term FRAM itself is a trademark of Ramtron.</para>
      </listitem>

      <listitem>
        <para>NVRAM&nbsp;: Abbreviation of Non-Volatile Random Access Memory, a
        type of memory that retains its contents when power is turned off. One
        type of NVRAM is SRAM that is made non-volatile by connecting it to a
        constant power source such as a battery. Another type of NVRAM uses
        EEPROM chips to save its contents when power is turned off. In this
        case, NVRAM is composed of a combination of SRAM and EEPROM
        chips.</para>
      </listitem>

      <listitem>
        <para>Bubble Memory&nbsp;: A type of non-volatile memory composed of a
        thin layer of material that can be easily magnetized in only one
        direction. When a magnetic field is applied to circular area of this
        substance that is not magnetized in the same direction, the area is
        reduced to a smaller circle, or bubble. It was once widely believed that
        bubble memory would become one of the leading memory technologies, but
        these promises have not been fulfilled. Other non-volatile memory types,
        such as EEPROM, are both faster and less expensive than bubble
        memory.</para>
      </listitem>

      <listitem>
        <para>Flash Memory&nbsp;: A special type of EEPROM that can be erased
        and reprogrammed in blocks instead of one byte at a time. Many modern
        PCs have their BIOS stored on a flash memory chip so that it can easily
        be updated if necessary. Such a BIOS is sometimes called a flash
        BIOS. Flash memory is also popular in modems because it enables the
        modem manufacturer to support new protocols as they become
        standardized.</para>
      </listitem>

    </itemizedlist>

  </para>
</appendix>

<appendix>

  <title>Companies selling diskless computers</title>

  <para>The original Diskless-HOWTO mentions the names of the following vendors
  of diskless computers&#160;

    <itemizedlist mark="opencircle">

      <listitem>
        <para>Linux Systems Labs Inc., USA <ulink
        url="http://www.lsl.com">http://www.lsl.com</ulink>. Click on "Shop
        On-line" and then click on "HardWare" where all the diskless computers
        will be listed. Phone 1-888-LINUX-88.</para>
      </listitem>

      <listitem>
        <para>Diskless Workstations Corporation, USA <ulink
        url="http://www.disklessworkstations.com">http://www.disklessworkstations.com</ulink>.</para>
      </listitem>

      <listitem>
        <para>Unique Systems of Holland Inc., Ohio, USA <ulink
        url="http://www.uniqsys.com">http://www.uniqsys.com</ulink></para>
      </listitem>

    </itemizedlist>
  </para>

</appendix>

<bibliography>

  <title>References</title>

  <biblioentry xreflabel="Diskless-HOWTO">
    <bibliomisc><ulink url="&disklesshowtourl;">Diskless-HOWTO</ulink></bibliomisc>
  </biblioentry>

  <biblioentry xreflabel="Diskless-root-NFS-HOWTO">
    <bibliomisc><ulink url="&disklessrootnfshowtourl;">Diskless-root-NFS-HOWTO</ulink></bibliomisc>
  </biblioentry>

  <biblioentry xreflabel="ltsp">
    <bibliomisc><ulink url="&ltspurl;">Linux Terminal Server Project</ulink></bibliomisc>
  </biblioentry>

  <biblioentry xreflabel="logilab">
    <bibliomisc><ulink url="&logilaburl;">Logilab.org web site&</ulink></bibliomisc>
  </biblioentry>

  <biblioentry xreflabel="PowerUp2Bash">
    <bibliomisc><ulink url="&powerup2bashurl;">From-PowerUp-to-bash-prompt-HOWTO</ulink></bibliomisc>
  </biblioentry>

  <biblioentry xreflabel="ThinClient">
    <bibliomisc><ulink url="&thinclienturl;">Thin-Client-HOWTO</ulink></bibliomisc>
  </biblioentry>

  <biblioentry xreflabel="cdwriting">
    <bibliomisc><ulink url="&cdwritingurl;">CD-Writing-HOWTO</ulink></bibliomisc>
  </biblioentry>

  <biblioentry xreflabel="etb">
    <bibliomisc><ulink url="&etburl;">etherboot project</ulink></bibliomisc>
  </biblioentry>

  <biblioentry xreflabel="vmware">
    <bibliomisc><ulink url="&vmwareurl;">VMWare</ulink></bibliomisc>
  </biblioentry>

  <biblioentry xreflabel="freemware">
    <bibliomisc><ulink url="&freemwareurl;">FreeMWare</ulink></bibliomisc>
  </biblioentry>

</bibliography>

</article>
