<?xml version='1.0' encoding='ISO-8859-1'?>

<sect1 id="mksqoverview">

<title>The mksquashfs tool, exposed</title>

<sect2 id="mksqusing">

<title>Using mksquashfs</title>

<para>
<command>mksquashfs</command> is the tool for creating new squashed 
file systems, and for appending new data to existing squashed file 
systems. The general command-line format for <command>mksquashfs</command> is:
</para>

<programlisting>
	bash# mksquashfs source1 source2 ... destination [options]
</programlisting>

<itemizedlist>

<listitem><filename>source1</filename>, <filename>source2</filename>, etc.: files and directories to be
added to the resulting filke system, given with relative and/or absolute paths 
</listitem>

<listitem><filename>destination</filename>: a regular file (filesystem 
image file), or a block device (such as <filename>/dev/fd0</filename> or <filename>/dev/hda3</filename>)
where you want to have your squashed file system
</listitem>

</itemizedlist>

<para>

Notes for default <command>mksquashfs</command> behavior:

<itemizedlist>

<listitem>
When the new files are added to the new file system or appended to an existing one,
<command>mksquashfs</command> will automatically rename files with duplicate names:
if two or more files named <filename>text</filename> will appear in the same
resulting directory, the second file will be renamed to
<filename>text_1</filename>, third one to <filename>text_2</filename> and so on.
</listitem>

<listitem>
Duplicate files will be removed, so there will be only one physical instance
(with SquashFS 2.x, you can disable the detection/rtemoval of the duplicates
with the <command>-no-duplicates</command> option).
</listitem>

<listitem>
If <emphasis>destination</emphasis> has a pre-existing SquashFS
file system on it, by default, the new <emphasis>source</emphasis> items will be appended to
the existing root directory. Examine the options table below to force <command>mksquashfs</command> to overwrite the whole destination
and/or change the way new source items are added. Please note that it is not possible to 
append to a file system created with <command>mksquashfs</command> 1.x using 
<command>mksquashfs</command> 2.x. You will need to mount the SquashFS-1.x file system
and copy the files to some location, and then join them with other needed files
to create a SquashFS-2.x file system.
</listitem>

<listitem>
If a single source file or directory is given, it becomes the root in a newly created file system. If two
or more source files and/or directories are given, they will all become sub-items in the root of
the new file system.
</listitem>

<listitem>
The resulting filesystem will be padded to a multiple of 4 Kb: this
is required for filesystems to be used on block devices. If you are very sure
you don't ned this, use the <command>-nopad</command> option to disable this
operation.
</listitem>

</itemizedlist>

</para>

<para>
See the next section for more details about all possible options.
</para>

</sect2>

<sect2 id="mksqoptions">

<title>Command-line options</title>

<para>
All possible options for <command>mksquashfs</command> are shown in the table below.
</para>

<table frame="all">

<title>Command-line options of the <command>mksquashfs</command> tool</title>

<tgroup cols="2">

<thead>
<row>
<entry>Option</entry>
<entry>Description</entry>
</row>
</thead>

<tbody>

<row>
<entry><command>-all-root</command> or <command>-root-owned</command></entry>
<entry>make all files in the target file system owned by root (UID=0, GID=0)</entry>
</row>

<row>
<entry><command>-always-use-fragments</command></entry>
<entry>divide all files greater than block size into fragments (2.x only,
will result in greater compression ratios)</entry>
</row>

<row>
<entry><command>-b [block size]</command></entry>
<entry>use [block size] filesystem block size (32 Kbytes default) - this can be either 512, 1024, 2048, 4096, 8192, 16384 or 32768</entry>
</row>

<row>
<entry><command>-be</command> or <command>-le</command></entry>
<entry>force a big or little endian file system, respectively</entry>
</row>

<row>
<entry><command>-check-data</command></entry>
<entry>enable additional file system checks</entry>
</row>

<row>
<entry><command>-e [file1] ( [file2] ... )</command></entry>
<entry>specify which files and/or directories to omit
from the new file system that is to be created</entry>
</row>

<row>
<entry><command>-ef [file]</command></entry>
<entry>specify a <filename>file</filename> which contains the list of
files/directories to exclude</entry>
</row>

<row>
<entry><command>-force-gid [GID]</command></entry>
<entry>set all group IDs in target file system to [GID]
(can be specified as a name or a number)</entry>
</row>

<row>
<entry><command>-force-uid [UID]</command></entry>
<entry>set all user IDs in target file system to [UID]
(can be specified as a name or a number)</entry>
</row>

<row>
<entry><command>-info</command></entry>
<entry>print files, their original size and compression ratio, as they are added to 
the file system</entry>
</row>

<row>
<entry><command>-keep-as-directory</command></entry>
<entry>if the source is a single directory, force this directory to be a subdirectory 
of the root in the created file system</entry>
</row>

<row>
<entry><command>-noappend</command></entry>
<entry>if the destination file/device already contains a squashed file system, 
overwrite it, rather than append the new data to an existing file system</entry>
</row>

<row>
<entry><command>-no-duplicates</command></entry>
<entry>do not detect/remove duplicate file names</entry>
</row>


<row>
<entry><command>-noD</command> or <command>-noDataCompression</command></entry>
<entry>do not compress the data</entry>
</row>

<row>
<entry><command>-noF</command> or <command>-noFragmentCompression</command></entry>
<entry>do not compress the fragments (2.x only)</entry>
</row>

<row>
<entry><command>-no-fragments</command></entry>
<entry>do not generate fragment blocks (2.x only, this will
produce almost the same filesystem as 1.x did)</entry>
</row>

<row>
<entry><command>-noI</command> or <command>-noInodeCompression</command></entry>
<entry>do not compress the inode table</entry>
</row>

<row>
<entry><command>-nopad</command></entry>
<entry>do not pad the resulting file system to a multiple of 4 KBytes</entry>
</row>

<row>
<entry><command>-root-becomes [name]</command></entry>
<entry>can be used while appending to a pre-existing squashed file system: it will make a new root, 
and [name] directory will contain all pre-existing files/directories
</entry>
</row>

<row>
<entry><command>-version</command></entry>
<entry>print the version, copyright and license message</entry>
</row>

</tbody>

</tgroup>

</table>

<para>
In most cases, you should leave all compression/block options by default, as they allow 
<command>mksquashfs</command> to achieve the best possible compression ratios.
</para>

</sect2>

</sect1>