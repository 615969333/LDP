<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V3.1//EN">

<article>

<artheader>

	<title>The Linux Gamers' HOWTO</title>
	<titleabbrev>LG-HOWTO</titleabbrev>

	<author>
		<firstname>Peter</firstname>
		<othername role='middle'>Jay</othername>
		<surname>Salzman</surname>
		<affiliation>
			<address>
				<email>p(at)dirac.org</email>
			</address>
		</affiliation>
	</author>

	<revhistory>
		<revision>
			<revnumber>0.9.1</revnumber>
			<date>2002-01-03</date>
			<revremark>Converted to docbook</revremark>
		</revision>
		<!-- previous versions get their own <revision> tag -->
	</revhistory>

	<copyright>
		<year>2001</year>
		<holder>Peter Jay Salzman</holder>
	</copyright>

	<legalnotice>
		<para>
			<email>p(at)dirac(dot)org</email> / 
			<systemitem role="url">http://www.dirac.org/p</systemitem>.
		</para>
		<para>
			Distributed subject to the GNU General Public License, version 2.
		</para>
	</legalnotice>


<abstract> <title>Abstract</title>

	<para> The same questions get asked repeatedly on Linux related mailing
	lists and news groups.	Many of them arise because people don't know as
	much as they should about how things &ldquo;work&rdquo; on Linux, at least,
	as far as games go. </para>

	<para> This document is a stepping stone to get the most common problems
	resolved and to give people the knowledge to begin thinking intelligently
	about what is going on with their games.	Just as with anything else on
	Linux, you need to know a little more about what's going on behind the
	scenes with your system to be able to keep your games healthy or to
	diagnose and fix them when they're not. </para>

	<para> I hope that this document will reduce the traffic and educate
	people.	I'm no expert at this stuff, so I hope that some guru out there
	will tell me that I got something wrong and correct my understanding.
	</para>

</abstract>

</artheader>
<!--
	0.0.	Introduction
	0.1.	Authorship, Copyright
	0.2.	Thanks
	0.3.	Latest Version And Contact Information
	0.4.	Translations
	0.5.	TODO and Request For Help

	1.0.	Definitions: Types Of Games
	1.1.	Arcade Style
	1.2.	Text Adventure (aka Interactive Fiction)
	1.3.	Graphical Adventure (aka Point and Click Adventure)
	1.4.	Simulation (aka Sim) and Strategy (aka Strat)
	1.5.	First Person Shooter (aka FPS)
	1.6.	Side Scrollers
	1.7.	Third Person Shooters
	1.8.	Role Playing Game (aka RPG)

	2.0.	Libraries
	2.1.	What is Glide?
	2.2.	What is OpenGL?
	2.3.	What is Mesa?
	2.4.	What is DRI?
	2.5.	What is GLX?
	2.6.	What is Utah GLX?
	2.7.	What is xlib?
	2.8.	What is SDL?
	2.9.	What is GGI?
	2.10.	What is SVGAlib?	Frame buffer?	Console?
	2.11.	What is OpenAL?

	3.0.	Definitions: Video Card and 3D Terminology
	3.1.	What is T&L?
	3.2.	What is FSAA?

	4.0.	XFree86 and You
	4.1.	Getting information about your X system
	4.2.	Getting information about your 3D system

	5.0.	Various Topics
	5.1.	Memory Type Register Ranges
	5.2.	Milking performance from your system for all it's worth
	5.3.	About libraries on Linux

	6.0.	When bad things happen to good people
	6.1.	RTFM!
	6.2.	Look For Updates
	6.3.	Newsgroups
	6.4.	Google
	6.5.	Debugging: Call traces and core files
	6.6.	Saved Games
	6.7.	What to do when a file or library isn't being found
				(better living through strace)
	6.8.	Hosed consoles

	7.0.	Hardware
	7.1.	Which video card is the best?
	7.2.	Which sound card is the best?

	8.0.	Miscellaneous Problems
	8.1.	Hardware acceleration problems
	8.1.1.	Hardware acceleration isn't working at all
	8.1.2.	Hardware acceleration works for root, but not for non-root
	8.1.3.	Voodoo specific slowness
	8.2.	Why isn't my sound working?
	8.2.1.	Shared interrupt
	8.2.2.	Misconfigured driver
	8.2.3.	Something is already accessing your sound card
	8.2.4.	You're using the wrong driver (or no driver)

	9.0.	Websites
	9.1.	Meta Gaming websites
	9.2.	Commercial Linux Game Websites
	9.2.1.	Where to buy commercial games
	9.2.2.	Who is releasing games for Linux

	9.1.	Meta Gaming websites
	9.2.	Commercial Linux Game Websites
	9.4.	Other websites
-->

<sect1 id="admin"><title>Administra</title>

	<para> I'll keep it short.	If you have ideas, comments, corrections or
	questions relating to this HOWTO, please email me.	By receiving feedback
	on this howto (even if I don't have the time to answer), you make me feel
	like I'm doing something useful.	In turn, it motivates me to write more
	and add to this document.  You can reach me at p(at)dirac(dot)org.	My web
	page is <systemitem role="url">www.dirac.org/p</systemitem> and my Linux
	pages are at <systemitem role="url">www.dirac.org/linux</systemitem>.
	Please do send comments and suggestions for this howto.  Even if I don't
	take your suggestions, your input is graciously received.
	</para>

	<para>I assume a working knowledge of Linux, so I use some topics like
	runlevels and modules without defining them.	If there are enough questions
	(or even protests!) I'll add more basic information to this document.
	</para>



	<sect2 id="credits"><title>Authorship and Copyright</title>

	<para> This document is copyright (c) 2001 Peter Jay Salzman.  Permission is
	granted to copy, distribute and/or modify this document under the terms of
	the GNU Free Documentation License, Version 1.1, except for the provisions
	I list in the next paragraph.  I hate HOWTO's that include the license; it's
	a tree killer.  You can read the GNU FDL at
	<systemitem role="url">http://www.gnu.org/copyleft/fdl.html</systemitem>.
	</para>

	<para> If you want to create a derivative work or publish this HOWTO for
	commercial purposes, contact me first.  This will give me a chance to give
	you the most recent version.  I'd also appreciate either a copy of whatever
	it is you're doing or a spinach, garlic, mushroom, feta cheese and artichoke
	heart pizza. </para>

	</sect2>



	<sect2 id="thanks"><title>Thanks</title>

		<para>Thanks to Mike Phillips who commented extensively on the howto,
		even if it is in his best interests.	:)	Thanks to Dmitry Samoyloff,
		dsamoyloff(at) mail(dot)ru, for translating this document to Russian.	I
		hope he keeps up with my revisions, since I'll be adding to this document
		almost every day until it reaches 0.1.0.	It blew my mind when he first
		told me that he was translating my words to Russian.</para>

	</sect2>



	<sect2 id="version"><title>Latest Version</title>

		<para>The latest version can be found at <systemitem role="url">
		http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/lgh/LG-HOWTO/</systemitem>
		and <systemitem role="url">http://www.dirac.org/writing</systemitem>.
		</para>

	</sect2>



	<sect2 id="translations"><title>Translations</title>

		<para> Dmitry Samoyloff, dsamoyloff(at)mail(dot)ru, is the maintainer of
		the Russian translation of this HOWTO.	The most recent version can be
		found at http://linuxgames.hut.ru/data/docs/HOWTO/LG-HOWTO-ru.html.
		</para>

	</sect2>



	<sect2 id="todo"><title>TODO</title>

		<para> Discuss gaming under wine and dosemu.	Discuss transgaming.com.
		Fill in sections on meices, GGI, Simulations and Strategy. </para>

	</sect2>

</sect1>





<sect1 id="definitions"><title>Definitions: Types Of Games</title>

	<para> Not everyone knows the different types of games that are out there,
	so in an effort to form a common language that we can all use, I'll run
	through each game type and provide a very brief history. </para>



	<sect2 id="arcade"><title>Arcade Style</title>

		<para> Arcade style games refer to any game not covered by the rest of
		the categories.	It covers a vast expanse of games: card and board games
		(solitaire, monopoly), classics (Missile Command, Asteroids), brain
		teezers (Master Mind, chess), old favorites (Lode Runner, Hunt the
		Wumpus), and all the tens of millions Tetris clones.	Historically, this
		was just about the only thing there was available to the open source
		community.	To this day, the overwhelming majority of Linux games are
		open source arcade games. </para>

	</sect2>



	<sect2><title>Text Adventure (aka Interactive Fiction)</title>

		<para> Once upon a time, when Apple ][, Commodore,	and Atari ruled the
		world, text adventures were the game of choice of &ldquo;intelligent
		folk&rdquo;.	They were self contained executables on disks (even
		casettes). 	These days, we're a bit more sophisticated and concerned
		with elegance than that.  Now there's usually a data file and an
		interpreter.  The interpreter reads data files and provides the gaming
		interface.	The data file is the actual game, and is often implemented by
		a language.	So for example, you you could have the two Scott Adams
		datafiles &ldquo;The Count.dat&rdquo; and &ldquo;Voodoo
		Castle.dat&rdquo;.	To actually play the games, you'd invoke the
		scottfree interpreter with the name of the datafile you wish to play.
		</para>

		<para> The first adventure game was Adventure (actually
		&ldquo;ADVENT&rdquo;, written on a PDP-1 in 1972).	You can play
		adventure yourself (actually, a descendent); it comes with &ldquo;bsd
		games&rdquo; on most Linux distros. </para>

		<para> They became popularized by Scott Adams, who is widely considered
		(by really old people) to be the father of text adventuring.	 You can
		play Scott Adams adventures using scottfree, written by Alan Cox.
		Scottfree needs data files; most of the old data files are now shareware,
		and you can download them directly from Scott Adams' website, which I've
		included in this howto. </para>

		<para> Text adventures climaxed in the 80's with Infocom.	There are many
		infocom interpreters available for Linux; the most popular one being frotz.
		You still need the data files, and these are all still owned and considered
		commercial property by Activision. </para>

		<para> As computer graphics became easier and more powerful, text
		adventures gave rise to graphic adventures.	The death of interactive
		fiction more or less coincided with the bankruptcy of Infocom.  </para>

	</sect2>



	<sect2><title>Graphical Adventures</title>

		<para> Graphical adventures are, at heart, text adventures on steroids.
		The degree to which they use graphics varies widely.  Back in the 80's,
		they were little more than text adventures which showed a screen of
		static graphics.  When you picked up an item, the background would be
		redrawn without the item appearing (oooh, aaah!).  The canonical example
		would be the so-called `Hi-Res Adventures' like The Wizard And The
		Princess.  I never did make it past the snake!
		 </para>

		<para> Next there are the `point and click adventures' which basically
		have no text interface at all, and often have dynamic graphics, like a
		cat wandering around the room while you're deciding what to do next.  In
		these games, you point at an object (say, a book) and can choose from a
		pull-down list of functions.  Kind of object oriented adventuring.  :)
		</para>

		<para> The old-style graphical adventures are simply non-existant for
		Linux.  They had architecture dependent graphics hard coded into them, so
		it would be inconvenient (if next to impossible) to write an interpreter
		for Linux.  If you want to play any of these, you're going to have to do
		it on an 8-bit emulator like <command>apple2</command> or
		<command>atari800</command>. </para>

		<para> We don't have many point and click adventures either.  The only
		one I can think of is Hopkins FBI (which happens to be my favorite game
		for Linux).  This is definitely an under-represented class of games,
		which is a reflection of the times.  Most people don't seem to be very
		interested in adventuring any more.
		</para>

	</sect2>



	<sect2><title>Simulation (aka Sims)</title>

		<para> Simulations strive to immerse the player behind the controls of
		something they normally wouldn't have access to.  This could be something
		real like a fighter jet or something imaginary like a mechanized warrior
		combat unit.  In either case, sims strive for realism. </para>
		
		<para> Some sims have little or no strategy.  They simply put you in a
		cockpit to give you the thrill of piloting a plane.  Some of them are
		considerably more complex, and there's often a fine line between sims and
		strats (see the next section).  A good example would be Civilization and
		SimCity 3000 (both by Loki Software).  These days sims and strats are
		nearly indestinguishable, but a long time ago, sims were all real time
		while strats were all turn based.  This is somewhat awkward for modern
		day use, since a game like Warcraft which everyone knows as a
		strat, would be a sim by definition.
		
	</sect2>



	<sect2><title>Strategy (aka Strats)</title>

		<para> Strategy games have their roots in old Avalon type board games like
		Panzer Leader and old war strategy games published by SSI.	Generally, they
		simulate some kind of scenario.	The scenario can be peaceful, like running
		a successful city or illegal drug selling operation (SimCity or DrugWars).
		The scenario can also be total all-out war strategy game like Myth II.	The
		types of games usually take a long time to complete and require a lot of
		brainpower. </para>

		<para> Strats can be further divided into two classes: real time and turn
		based.  Real time strats are based on the concept of you-snooze-you-lose.
		For example, you're managing a city and a fire erupts somewhere.  The more
		time it takes for you mobilize the fire fighters, the more damage the fire
		does.  Turn based strats are more like chess---the computer takes a turn
		and then the player takes a turn. </para>

	</sect2>



	<sect2><title>First Person Shooter (aka FPS)</title>

		<para> What light through yonder window breaks?	It must be the flash of
		the double barreled shotgun.	Linux has no deficiency of FPS!  We have a
		long, twisted and complicated history with FPS games which started when
		ID Games released the code for Doom.	The code base has forked and merged
		numerous times.	Lots of opensource efforts like Hexen, Heretic, Dumb and
		tons of others. </para>

		<para> First person shooters are characterized by two things.	First, you
		pretty much blow up everything you see.	Second, the action takes place in
		&ldquo;first person&rdquo;.	 That is, you are the eyes of the character
		who's doing all the shooting.	You may even see your hands or weapon at
		the bottom of the screen.	Some are set in fantasy (Doom, Hexen), others
		are science fiction (Quake I, Quake II), and some are set in the present
		day `real world' (SoF). </para>

		<para> Just like text adventures, FPS fit the engine/datafile format.	The
		engine refers to the actual game itself (Doom, Quake, Heretic2) and plays
		out the maps and bad guys outlined by the datafile (doom2.wad, pak0.pak,
		etc).  Many FPS games allow people to write their own non-commercial
		datafile.  There are hundreds, even thousands of non-commercial Doom
		datafiles that you can download for free off the net.   Often, companies
		discard their engines and put them into the open source community so we
		can hack and improve them.  However, the original data files are kept
		proprietary.  To this day, you still have to purchase <filename>doom.wad
		</filename>.</para>

	</sect2>



	<sect2><title>Side Scrollers</title>

		<para> Side scrollers are similar to FPS but you view your character as a
		2D figure who runs around the screen shooting at things.	Examples would
		be Abuse for Linux and the original Duke Nukem. </para>

	</sect2>



	<sect2><title>Third Person Shooters</title>

		<para> Again, similar to FPS, but you view your character in third person
		and in 3D.	On modern third person shooters you can usually do some
		really kick-butt maneuvers like Jackie Chan style back flips and side
		rolls.	The canonical example would be Tomb Raider.  On the Linux
		platform, we have Heretic 2 and Heavy Metal FAKK.  </para>

	</sect2>



	<sect2><title>Role Playing Game (aka RPG)</title>

		<para> Anyone who has played games like Dungeons & Dragons or Call of
		Cthulhu knows exactly what an RPG is.	You play a character, sometimes
		more than one, characterized by traits (eg strength, dexterity,
		constitution), skills (eg explosives, basket weaving, mechanics) and
		properties (levels, cash).  As you play, the character becomes more
		powerful and the game adjusts itself accordingly, so instead of fighting
		kobolds, at high levels you start fighting black dragons with
		disintegration rays.	The rewards increase correspondingly.	At low levels
		you might get some gold pieces as a reward for winning a battle.	At high
		levels, you might get a magic sword or a kick-butt assault rifle. </para>

		<para> RPG's generally have a quest with a well defined ending.  In
		nethack you need to retrieve the amulet of Yendor for your god.	In Ultima
		II, you destroy the evil sorceress Minax.	At some point, your character
		becomes powerful enough that you can &ldquo;go for it&rdquo; and try to
		complete the quest. </para>

		<para> The canonical RPG on Linux is Rogue<footnote><para>Interesting
		tidbit: The ncurses library can be traced back to the screen handling
		routines that were written for Rogue!</para></footnote> and its infinite
		variants like Zangband and Nethack (which has infinite variants itself).
		Some of them are quite complicated and are great feats of programming.
		There seems to be a deficiency of commercial RPGs on Linux.  If you count
		all the rogue variants as being the same, there also seems to deficiency
		of open source RPGs as well.  </para>

	</sect2>

</sect1>





<sect1><title>Libraries</title>

<para> We'll run through the different types of gaming libraries you'll see
under Linux. </para>

	<sect2><title>What is Glide?</title>

		<para> Glide2 is an API plus driver that accesses 3D hardware accelerated
		functions on Voodoo I, II and III cards, based on chipsets manufactured
		by the now defunct 3Dfx.  </para>

		<para> Glide2 is low-level: it supports defining a view point, displaying
		a texture, sending tri's and that's about it.	There are some Glide2
		features which resemble OpenGL, and some which have no counterpart.
		</para>

		<para> A program can ONLY use the special hardware acceleration features
		of these cards by using the Glide2 library in one of two ways: </para>

		<itemizedlist>
			<listitem><para>directly: they're written natively using Glide2</para>
				</listitem>
			<listitem><para>indirectly: they use Mesa+Glide2 which implements OpenGL
				using Glide2</para></listitem>
		</itemizedlist>

		<para> Examples of games which are written natively using Glide2 are Loki
		Software's Myth 2, Descent 3, Unreal Tournament, Rune and Deus Ex.	 The
		vast majority of games used Glide2 indirectly by using Glide2 enabled
		Mesa (they also have OpenGL ports).  </para>

		<para> Glide2 is no longer proprietary.  3dfx has opened up the
		specifications and source code to the open source community.
		Glide2 was ported to Linux by Daryll Strauss.  Also, since Glide2
		accesses the video board directly, an application that uses Glide2 will
		either need to be root or setuid root.  A way around this was to create
		the kernel 3dfx module.  This module (and the corresponding device
		/dev/3dfx) allowed Glide2 hardware acceleration for non-root users of
		non-setuid applications.</para>

		<para> Glide2 is also a dead issue.	It's only implemented on XFree86 3.3
		(most people are using 4.0 these days) and is used only by Voodoo I, II
		and III cards.  It's a sure bet that no more games will be written with
		Glide2. </para>

		<para> Now what about Glide3?  First of all, Glide3 is not a direct API.
		It exists only to support DRI on Voodoo III, IV and V boards under
		XFree86 4.0.	None of the games which use Glide2 to render will work
		under Glide3.	Typically, if the user's system supports Glide2 as a
		rendering option, it will perform better.	However, that is becoming a
		less-common configuration these days. </para>

		<screen>
			Glide	X Ver	Cards Supported		Notes
				2		3.3.*	Voodoo I, II, III	Uses the 3dfx device for non-root access.
				3		4.*.*	Voodoo III, IV, V	Is used by DRI on 3dfx graphics boards.
		</screen>

		<para> There are games that are written to make use of Glide2 directly
		(as opposed to indirectly using Glide2 by using Glide2 enabled Mesa).
		Myth2 is an example of a game written directly with Glide2, although it
		can also render in OpenGL (see next question).	Quake3 is an example of
		an OpenGL game that can use glide2 by using Glide2 enabled Mesa.  </para>

	</sect2>



	<sect2><title>What is OpenGL?</title>

		<para> OpenGL is a high level graphics programming API originally
		developed by SGI based on their previous proprietary Irix GL, and became
		in industry standard several years ago.	It is defined and maintained by
		the Architectural Revision Board (ARB), an organization that includes
		members as SGI, IBM, DEC, and Microsoft.	OpenGL provides a powerful,
		complete and generic feature set for 2D and 3D graphics operations.
		</para>

		<para> There are 3 parts to OpenGL and its canonical extensions: </para>

		<itemizedlist>

			<listitem><para>GL: The OpenGL core calls</para></listitem>

			<listitem><para>GLU: The utility calls</para></listitem>

			<listitem><para>GLUT: Utility tools for system-independent window event
			handling (mouse motion/click detection, keyboard strokes, program quit
			signal handling, etc.).	Also has some UI stuff that should have been
			included in GLUI.</para></listitem>

		</itemizedlist>

		<para> OpenGL is not only an API, it's also an implementation, written by
		SGI.  The implementation tries to use hardware acceleration for various
		graphics operations whenever available, which depends on what videocard
		you have in you computer.	If hardware acceleration is not possible for a
		specific task, OpenGL falls back on software rendering.	This means that
		when you get OpenGL from SGI, if you want any kind of hardware
		acceleration at all, it must be OpenGL written and compiled specifically
		for some graphics card.	Otherwise, all you'll get is software rendering.
		The same thing is true for OpenGL clones, like Mesa.  </para>

		<para> OpenGL is the open source equivalent to Direct3D (a component of
		DirectX).  The important difference being that since OpenGL is open (and
		DirectX is closed), games written in OpenGL are much easier to port to
		Linux while games written using DirectX at this point in time are
		impossible to port to Linux.	In fact, if you start from scratch, it's
		almost trivial to write a game which will compile under the Linux and
		Win32 platform.  </para>

	</sect2>


	<sect2><title>What is Mesa?</title>

		<para> Mesa is a free implementation of the OpenGL API, designed and
		written by Brian Paul.	While it's not officially certified, it is an
		almost fully compliant OpenGL implementation conforming to the ARB
		specifications.  It's reported that Mesa is even faster than SGI's own
		OpenGL implementation.  </para>

		<para> Just like OpenGL, Mesa makes use of hardware acceleration whenever
		possible.  This means that there are different &ldquo;versions&rdquo; or
		&ldquo;builds&rdquo; of mesa depending on what kind of video card you
		have.	If you have a Voodoo I, II or III card, you're supposed to use
		&ldquo;mesa+glide2&rdquo; (written by David Bucciarelli) which is the
		mesa implementation of opengl that uses glide as a backend to render
		certain graphical operations.  </para>

	</sect2>


	<sect2><title>What is DRI?</title>

		<para> Graphics rendering has 3 players: the client application (like
		Quake 3), the X server and the hardware (the graphics card).	Previously,
		client applications were prohibited from writing directly to hardware,
		and there was a good reason for this.	A program that is allowed to
		directly write to hardware can crash the system in any number of ways.
		Rather than trusting programmers to write totally bug free, cooperative
		programs that access hardware, Linux simply disallowed it.	However, that
		changed with X 4.0 with Direct Rendering Infrastructure (DRI).	Loosely,
		the direct rendering infrastructure allows X clients to write 3D
		rendering information directly to the video card in a safe and
		cooperative manner.  </para>

		<para> DRI gets the X server out of the way so the 3D driver (Mesa or
		OpenGL) can talk directly to the hardware.	This speeds things up.	The
		3D rendering information doesn't even have to be hardware accelerated.
		On a technical note, this has a number of virtues.  </para>

		<itemizedlist>

			<listitem><para>Vertex data doesn't have to be encoded/decoded via GLX.
			</para></listitem>

			<listitem><para>Graphics data doesn't have to be sent over a socket to
			the X server.</para></listitem>

			<listitem><para>On single processor machines the CPU doesn't have to
			change context between X and its client to render the graphics.</para>
			</listitem>

		</itemizedlist>

	</sect2>


	<sect2><title>What is GLX?</title>

		<para> GLX is the X extension used by OpenGL programs, it is the glue
		between the platform independent OpenGL and platform dependent X.  </para>

	</sect2>


	<sect2><title>What is Utah GLX?</title>

		<para> Utah-GLX is the precursor to DRI.	It makes some different design
		decisions, regarding separation of data and methods of accessing the
		video card.	(For instance, it relies on root privileges rather than
		creating the kernel infrastructure necessary for secure access).	It
		provides support for (at this time) a couple cards which are not
		well-supported in DRI.	Particularly, the ATI Rage Pro family, S3 Virge
		(although anyone using this for gaming is, well, nuts), and an open
		source TNT/TNT2 driver (which is very incomplete).  The TNT/TNT2 driver
		is based on reverse-engineering of the obfuscated source code release of
		the X 3.3 drivers by nVidia.	However, they're really incomplete, and
		effectively, unusable.  </para>

		<para> As a side note, until the G400 stuff is *really* fixed in DRI,
		it's also the better G400 support&mdash;but hopefully that will not be an
		issue by the time this HOWTO is published.  </para>

	</sect2>


	<sect2><title>What is xlib?</title> 

		<para> Every once in awhile you'll see some sicko (said with respect)
		write a game in xlib, otherwise I wouldn't even mention xlib here.	xlib
		is a set of C libraries which comprise of the lowest level of programming
		for XFree86.  Any graphics programming in X ultimately makes use of the
			xlib library.  </para>

		<para> It's not an understatement to say that xlib is arcane and
		complicated.	I'd say it's the most difficult and time consuming
		programming endeavor there is.	A program that simply connects to an X
		server, puts up a window and does absolutely nothing else could be a 40
		line program with arcane and very long-named functions.	Because of this,
		there are lots of libraries which hide the details of xlib programming.
		Some of these libraries focus on drawing in windows (like SDL).	Other
		libraries are more concerned with widgets within windows (eg pulldown
		menus, radio buttons and text boxes); these types of libraries are
		appropriately named widget sets.	Gtk is the canonical widget set on
		Linux, but there are many others like fltk (a small widget set for use
		with C++), Xaw and Qt (the widget set of KDE).	You might have heard of
		Motif; that's what Netscape uses.	Motif used to be king of the unix
		world, but was VERY expensive to license.	The Open Group opened up
		Motif's license, but it was too little too late.	Lesstif (a Motif
		clone), Gtk and Qt were the supreme widget sets.  </para>

	</sect2>


	<sect2><title>What is SDL?</title>

		<para> SDL (Simple DirectMedia Layer) is a library by Loki Software's Sam
		Lantiga (graduate of UCD, yeah!!).	It's actually a meta-library, meaning
		that not only is it a graphics library which hides the details of xlib
		programming, it provides an easy interface for sound, music and event
		handling.	It's LGPL'd and provides joystick and OpenGL support as well.
		The 40 line arcane program I mentioned in the xlib section can easily be
		written in 6 lines of straightforward code using SDL.  </para>

		<para> The most striking part of SDL is that it's a cross platform
		library.  Except for a few details about header files and compiling, a
		program written in SDL will compile under Linux, *BSD, Windows*, MacOS
		and BeOS.  There are SDL extentions written by various people to do
		things like handle any graphics format you care to mention, play mpeg
		movies, display truetype fonts, sprite handling and just about everything
		under the sun.	Clearly, SDL is an example of what all graphics libraries
		should strive for.	The one deficiency is a lack of documentation (sigh),
		but I understand an SDL book is on its way.	If you're a game programmer,
		do the rest of the world a favor and use SDL.  </para>

		<para> Sam had an ulterior motive for writing such a cool library.	He's
		the lead programmer for Loki Software, which has used SDL in all of its
		games except for Quake3.  </para>

	</sect2>


	<sect2><title>What is GGI?</title>

		<para> GGI is seemingly now-defucnt project which headed for implementing
		graphics abstraction layer uniformly to lower code duplication, ease
		graphics hardware support in one place and bring higher stability and
		portability, also replacing svgalib, fb, and X servers dealing directly
		with hardware.  </para>

		<para> GGI was supposed to have a kernel module inserted into the Linux
		source code but Linus thought their code wasn't ready for production
		kernels.  There was brief talk about making *BSD their main platform.
		It's been ages since I've heard anything about GGI.  </para>

	</sect2>


	<sect2><title>What is SVGAlib?	Frame buffer?	Console?</title>

		<para> In case nobody told you, the console is the dark non-graphical
		screen you look at when your computer first boots up (and you don't have
		have xdm or gdm running).	This is opposed to the X environment which has
		all sorts of GUI things like xterms.	It's a common misconception that X
		means graphics and console means &ldquo;no graphics&rdquo;.	 There are
		certainly graphics on the console&mdash;they are extremely fullscreen,
		extremely fast, and extremely compelling.  </para>

		<para> SVGAlib is a graphics library that lets you draw graphics on the
		the console.	There are many games that use SVGAlib, and I happen to be a
		big fan of this library and of graphical console games in general.
		SVGAlib gets a small rap on the knuckes because executables need to be
		run by root or be setuid, but the library only needs to run as root when
		the application first starts.	It releases rootly status immediately.
		</para>

		<para> Frame buffers are like the console, but they're implemented as a
		graphics mode rather than a text mode.	Why would you want to simulate
		text mode from a graphical environment?	This allows us to run graphical
		things, like postscript viewers from the console environment.	It also
		allows us to pick and choose not only what font size we want our console
		to be, but what font we want console text to be!	Imagine having a
		console font of Comic Sans MS?	There is a good Frame Buffer howto
		available from LDP.  </para>

	</sect2>


	<sect2><title>What is OpenAL?</title>

		<para> OpenAL aims to be for sound what OpenGL is for graphics.	Jointly
		developed by Loki Software and Creative Labs, it sets out to be a vendor
		neutral and cross platform API for audio.	It is licensed LGPL and the specs
		can be had for free from the OpenAL website.  </para>

	</sect2>

</sect1>




<sect1><title>Definitions: Video Card and 3D Terminology</title>

<para>We'll cover some terminology that you'll see when reading about games in
general.  This stuff prolly isn't crucial to actually getting a game working,
but will help when deciding what hardware is best for you.</para>


	<sect2><title>T&amp;L: Texture and Lighting</title>

		<para> The T&amp;L instruction set on a video card allws it to proces all
		the texture and lighting effects in a video game,  as oppposed to
		transferring them to be processed by the CPU.  This obviously increases
		the speed of the game.  Not many games use T&amp;L yet, but one notable
		exception is Quake3. </para>

	</sect2>


	<sect2><title>FSAA: Full Screen Anti-Aliasing</title>

		<para> FSAA is "Full Screen Anti-Aliasing".  Anti-aliasing is an artist's
		technique for rendering an image, scaling it to a larger resolution and
		then rescaling it back down to the smaller resolution.  This has the
		effect of eliminating the "jaggies"; random pixels that make curved
		surfaces look uncurved or broken.  FSAA dramatically improves a game's
		visuals but can degrade overall performance by lowering the framerate
		since the video card has to render multiple images for every task.
		</para>

	</sect2>

</sect1>






<sect1><title>XFree86 and You</title>

	<para> If you're going to game under X, it's crucial that you know a bit
	about X.  I think the "X Window User HOWTO", and especially "man
	XF86Config" should be *required* reading.  Don't short change yourself.
	Read them.  They have an extremely high "information to space" ratio.
	Many problems can be fixed easily if you know your way around the
	XF86Config (or XF86Config-4) file. </para>


	<sect2><title>Getting information about your X system</title>


		<sect3><title>Probeonly</title>

		<para> There are many ways to get information about your X system.  A
		popular method is using probeonly.  From a console (and without X already
		running), type: </para>

		<screen>X -probeonly 2> X.out</screen>

		<para> Yes, that's a single dash; so much for standards.   The output of
		X goes to stderr, so we have to redirect stderr with "2>" to a file named
		X.out.  This file pretty much has everything there is to know about X.
		Go ahead and look at it.  It's chock full of useful information.  It's
		crucial that you know the difference between the different the various
		markers: </para>

	<screen>
    (--) probed              (**) from config file    (==) default setting
    (++) from command line   (!!) notice              (II) informational
    (WW) warning             (EE) error               (??) unknown.
	</screen>

		<para> Here's an example of what useful information I can glean from my
		output: </para>


		<para>I'm running at 16 bpp color:</para>
		
		<screen>(**) TDFX(0): Depth 16, (--) framebuffer bpp 16</screen>

    <para>X has detected what my videocard chipset and videoram are:</para>

			<screen>
      (--) Chipset 3dfx Voodoo5 found
      (--) TDFX(0): VideoRAM: 32768 kByte Mapping 65536 kByte
			</screen>

		<para> As I said, it's all here.   Sometimes it's hard to find what
		you're looking for.  Also, if X is already running, you'll have to kill
		it first, and sometimes you don't want to have to do this.  There are
		other ways of getting information about X, but I don't think any of them
		have the wealth of knowledge that this method gives.  We'll cover them
		shortly.  </para>

		<para> On Debian (and perhaps other distros?) the output of startx goes
		to the file /var/log/Xfree86.0.log, so you don't have to do the
		"-probeonly" business.  </para>

		</sect3>


		<sect3><title>Getting info about your setup: xvidtune</title>

		<para> xvidtune is your friend when your X screen is shifted a little bit
		too far to the right, or if the vertical length is too small to fit on
		your monitor.  However, it's a great diagnostic tool also.  It'll give
		you: </para>

	<itemizedlist>
	<listitem><para>the hsync/vsync range specified in your XFree86Config file
		</para></listitem>
  <listitem><para>the 4 horizontal and 4 vertical numbers which defines your
		videomode (the 1st horizontal/vertical numbers gives the screen resolution).
		These 8 numbers will tell you which modeline your X uses.  See the XFree86
		Video Modetiming Howto for more information.</para></listitem>
	<listitem><para>the "dot clock" your videocard is running at.</para>
		</listitem>
	</itemizedlist>

	</sect3>


		<sect3><title>Getting info about your setup: xwininfo</title>

		<para> xwininfo tells you all sorts of information about X windows.  And
		actually, your "background" or "root" window is considered a window too.
		So when xwininfo asks you to click on the window you want the information
		on, click on your background.  It'll tell you things like: </para>

		<segmentedlist>
		<seglistitem><seg>Screen resolution</seg><seg>Width and Height</seg>
			</seglistitem>
		<seglistitem><seg>color bpp        </seg><seg>Depth           </seg>
			</seglistitem>
		</segmentedlist>

		<para> and a few other things which are interesting but not immediately
		relevent to our subject, like "Window Gravity State" which tells where
		new windows tend to be placed by the window manager.  </para>

		</sect3>


		<sect3><title>Other sources of information</title>

		<para> xdpyinfo gives cool stuff, like X version and loaded extensions
		(invaluable when trying to see what's missing, like GLX, DRI,
		XFree86-VidMode, etc.).  </para>

		</sect3>


		<sect3><title>Getting information about your 3D system</title>

		<para> glxinfo gives lots of useful information about OpenGL (whether
		direct rendering is being used or not, the currently installed versions
		of glx and mesa), vendor/renderer strings, the GL library files being
		used and more.  </para>

		</sect3>

	</sect2>

</sect1>







<sect1><title>Various Topics</title>


	<sect2><title>Memory Type Register Ranges</title>

	<para> Starting with Pentium class processors and including Athlon, K6-2
	and other CPUs, there are Memory Type Register Ranges (MTRR) which control
	how the processor accesses ranges of memory locations.  Basically, it turns
	many smaller separate writes to the video card into a single write (a
	burst).  This increases efficiency in writing to the video card and can
	speed up your graphics by 250% or more.  </para>

	<para> See /usr/src/linux/Documentation/mtrr.txt for details.  Note that
	since this file was written, XFree86 has been patched to automatically
	detect your video RAM base address and size and set up the MTRRs.  </para>

	</sect2>


	<sect2><title>Milking performance from your system for all it's worth</title>

	<itemizedlist>
	<listitem><para>If for some reason you're using X 3.3, follow the instructions
		given by mtrr.txt (see section 5.1) to set up your MTRRs.  X 4.0 does this
		automatically for you.</para></listitem>
  <listitem><para>Don't run a window manager (wm).  Some wm's like twm don't
		take up much CPU cycles, but still rob you of performance.  Some window
		managers like enlightenment will definitely produce a noticeable slow down.
		To run a game without a wm, you modify .xinitrc in your home directory.
		Here is what my .xinitrc looks like:</para>

		<screen>
    #quake3 +set r_gldriver libGR.so.1
    #/usr/local/games/SinDemo/Sin
    #exec ut
    #lsdldoom -server 2
    #exec tribes2
    exec /usr/bin/enlightenment
		</screen>

		<para> This file tells X what client to run upon starting.  Usually this is
		your wm, and/or a desktop manager (GNOME or KDE).  Comment out the lines
		containing a wm and desktop manager with a pound sign (#) and place your
		game on a new line with any command line arguments you want to pass.  If
		the game is not located in your $PATH, give its full path name.  Note that
		this is for people who use `startx' to start X.  </para>

		 <para> I never use things like gdm or run-level 5 (so I'm not positive
		 here), but I suspect that if you do, you'll need to do things a bit
		 differently.  My best guess is to go to single user mode (run-level 1)
		 by: </para>

		<screen>telinit 1</screen>

    <para>then edit .xinitrc, then go back to run-level 5 by</para>

		<screen>telinit 5</screen>

		<para> Then when you stop playing, go to run-level 1, modify .xinitrc
		then go back to run-level 5.  I don't use this stuff, so I'm not sure,
		but you may need to kill gdm.  I'd appreciate some feedback on
		this.</para>

	<para>Kill all not-essential processes.  Of course you'll have to do this
	as root.  A better way to do this than typing "ps ax", getting ntpd's pid,
	and sending it a SIGKILL (with kill -9) is to make use of pidof:</para>

	<screen> # kill -9 `pidof ntpd`</screen>

	<para> However, an even better alternative is to use the startup scripts on
	your system.  On Debian, the startup scripts for run-level 2 are located in
	/etc/rc2.d/.  You can kill a service in an orderly manner by sending its
	startup scrip the `stop' command:</para>

	<screen>
	# cd /etc/rc2.d
  # ./ntpd stop
	</screen>

	<para> Another (radical) option is to simply put yourself in single-user
	mode with </para>

	<screen> # telinit 1</screen>

	<para> This will even get rid of getty; your system will be running nothing
	which is absolutely crucial to its operation.  You'll have something like
	10 processes running.  The downside is that you'll have to play the game as
	root.  But your process table will be a ghost town, and all that extra CPU
	cycle will go straight to your game.  </para></listitem> </itemizedlist>

	</sect2>


	<sect2><title>About libraries on Linux</title>

	<para> A common problem you'll see in gaming is a library file not being
	found.  They're kind of mysterious and have funny names, so we'll go over
	libraries on Linux for a bit.  There are two types of libraries, static and
	dynamic.  </para>

	<para> Static libraries are only used when you compile programs.  They
	contain code which gets inserted (linked) into the program being compiled
	at compile time.  If you've ever used the -l option when compiling a
	program under gcc, you've used static libraries whether you realized it or
	not.  When you compile a program with -lm (for the math library) or -lSDL
	(for the SDL library), gcc includes a file called libm.a and libSDL.a.  Add
	a "lib" to the front and a ".a" to the end and that's how you get the file
	name of the static library from what gcc knows the library as.  </para>
	
	<para> The .a files are really an archive of a bunch of .o (object) files
	archived together, in a manner similar to how you archive files using tar.
	If you want to see what functions the .a file provides the object code for,
	you can use the nm command: </para>

	<screen>
	% nm /usr/lib/libm.a
	...
	e_atan2.o:
	00000000 T __ieee754_atan2

	e_atanh.o:
	00000000 T __ieee754_atanh
	00000000 r half
	00000010 r limit
	00000018 r ln2_2
	00000008 r one
	...
	</screen>

	<para> Now where does gcc look for these files?  It looks for them in
	standard system directories plus any directories you specify with the -L
	option.  </para>

	<para> The other type of library is a dynamic library, also called a
	"shared library" .  Dynamic libraries provide code for a running
	application -- code gets linked into the executable at run time (as opposed
	to compile time, as is with the case of .a files).  They are analagous to
	the .dll's used by the evil empire.  The program responsible for linking
	code "on the fly" is called /etc/ld.so, and the dynamic libraries
	themselves usually end with ".so", like: </para>

	<screen>
	/usr/lib/libSDL-1.2.so.0.0.0
	/lib/libncurses.so.4
	</screen>

	<para> Where does the system look for these files?  There's a file
	/etc/ld.so.conf that has a list of directories that contain dynamic library
	files.  If you add libraries to your system, you must update this file.
	Changes don't take place immediately; ld.so actually uses a cached version
	of this file, /etc/ld.so.cache.  To get changes in ld.so.conf into
	ld.so.cache, you need to run "ldconfig" which recaches the contents of the
	ld.so.conf file.  </para>

	</sect2>

</sect1>




<sect1><title>When Bad Things Happen To Good People</title>

<para> Of course we can't cover every bad thing that happens, but I'll
outline some items of common sense.  </para>

<para> There are two types of Bad Things:  random and repeatable.  It's very
difficult to diagnose or fix random problems that you don't have any control
over when they happen or not.  However, if the problem is repeatable "it
happens when I press the left arrow key twice", then you're in business.
</para>


	<sect2><title>RTFM!</title>

	<para> Read the ... friendly manual.  The `manual' can take on a few forms.
	For open source games there's the readme files that come with the game.
	Commercial games will have a printed manual and maybe some readme files on
	the CD the game came on.  Don't forget the game's website.  The game's
	author has probably seen people with your exact same problem many times
	over and might put information specific to that game on the website.  A
	prime example of this is Loki Software's online FAQs.  </para>


	<para> If you hate to RTFM, at least get into the habit of grepping for
	things rather than not RTFMing at all.  So if your game isn't networking
	correctly, you can always "grep network *".  It's better than not looking
	at the FM at all.  But do make the attempt to read the docs; people who
	only want to be spoon-fed solutions are better off with a Microsoft product
	than Linux.  </para>

	</sect2>


	<sect2><title>Look For Updates and Patches</title>

	<para> If you're playing an opensource game that you compiled, make sure
	you have the newest version by checking the game's website.  If your game
	came from a distro make sure there's not an update rpm/deb for the game.
	</para>

	<para> Commercial game companies like Loki release patches for their games.
	Often a game will have MANY patches (Myth2) and some games are very
	problematic without them (Heretic2).  You should check the game's website
	for patches whether you have a problem running the game or not!  </para>

	<para> By the way, Loki now has an automatic utility that searches for
	lokigames on your hard drive and automatically updates them.  Kudos to
	them, this was a great idea!  Check out http://updates.lokigames.com.
	</para>

	</sect2>


	<sect2><title>Newsgroups</title>

	<para> If you don't know what netnews/newsgroups/nntp/usenet is, then this
	is definitely worth 30 minutes of your time to learn about.  Install a
	newsreader.  I prefer console tools more, so I use tin, but slrn is popular
	too.  Netscape has a nice graphical "point and click" newsreader too.
	</para>

	<para> For instance, here's how to connect to Loki's news server: </para>

	<itemizedlist>
	<listitem><para>* tin -g news.lokigames.com</para></listitem>

	<listitem><para>Most newsreaders will connect to the newserver held in the
		environment variable NNTPSERVER.  You can set it with:</para>

				<screen>
        $ export NNTPSERVER=news.lokigames.com
        $ tin -r
				</screen>
	</listitem>

	<listitem><para>Most newsreaders also look for the file /etc/nntpserver for
		the news server to connect to.</para></listitem>
	</itemizedlist>

	</sect2>



	<sect2><title>Google</title>

	<para> Every post made to usenet gets archived at this website.  The
	archive used used to be called deja (www.deja.com) but it was bought by
	google.  Most people still know the archive by "deja", so I'll call it that
	for now.  </para>

	<para> You are not a true Linux user until you use deja to fix a problem.
	It's almost an absolute certainty that whatever problem you have with Linux
	(whether gaming related or not) has already been asked about on deja.
	Moreover, chances are very good it has been answered.  Not once, not twice,
	but many times over.  If you don't understand the first response you see
	(or if it doesn't work), then you'll almost certainly have many other
	replies to read and try out.  Deja should be one of your first reactions to
	any problem.  </para>

	<para> Go straight to the advanced search and point your browser to: </para>

	<blockquote><para>
	<systemitem role="url">http://groups.google.com/advanced_group_search
	</systemitem>
	</para></blockquote>

	<para> It's easy to use.  For example, if my problem was that Quake III
	crashed everytime Lucy jumps, I would enter on the "Find messages with all
	of the words" textbox:</para>

	<screen>linux quake3 crash lucy jumps</screen>

	<para> or if you can't get sound to work on Unreal Tournament: </para>

	<screen>linux UT sound problem</screen>
	
	<para> you may want to include your soundcard in the search.  There are
	fields for which newsgroup you want to narrow your search to.  Take the
	time to read and understand what each field means.  I promise you.  You
	won't be disappointed with this service.  Use it, and you'll be a much
	happier person.  </para>

	</sect2>


	<sect2><title>Debugging: call traces and core files</title>

	<para> This is generally not something you'll do for commercial games.  For
	open source games, you can help the author by giving a corefile or stack
	trace.  Very quickly, a core file (aka core dump) is a file that holds the
	"state" of the program at the moment it crashes.  It holds valuable clues
	for the programmer to the nature of the crash -- what caused it and what
	the program was doing when it happened.  If you want to learn more about
	core files, I have a nice gdb tutorial at http://www.dirac.org/linux.</para>

	<para> At the *very* least, the author will be interested in the call stack
	when the game crashed.  Here is how you can get the call stack at
	barf-time: </para>

	<para> Sometimes distros set up their OS so that core files (which are
	mainly useful to programmers) aren't generated.  The first step is to make
	your system allow unlimited coresizes: </para>

	<screen> ulimit -c unlimited </screen>

	<para> You will now have to recompile the program and pass the -g option to
	gcc (explaining this is beyond the scope of this document).  Now, run the
	game and do whatever you did to crash the program and dump a core again.
	Run the debugger with the core file as the 2nd argument: </para>

	<screen>$ gdb CoolGameExecutable core</screen>

	<para> And at the (gdb) prompt, type "backtrace".  You'll see something
	like: </para>

	<screen>
	#0 printf (format=0x80484a4 "z is %d.\n") at printf.c:30
	#1 0x8048431 in display (z=5) at try1.c:11
	#2 0x8048406 in main () at try1.c:6
	</screen>

	<para> It may be quite long, but use your mouse to cut and paste this
	information into a file.  Email the author and tell him: </para>

	<orderedlist numeration="arabic">
  <listitem><para>The game's name</para></listitem>
  <listitem><para>Any error message that appears on the screen when the game
		crashes.</para></listitem>
  <listitem><para>What causes the crash and whether it's a repeatable crash or
		not.</para></listitem>
  <listitem><para>The call stack</para></listitem>
	</orderedlist>

	<para> If you have good bandwidth, ask the author if he would like the core
	file that his program dumped.  If he says yes, then send it.  Remember to
	ask first, because core files can get very, very big.  </para>

	</sect2>


	<sect2><title>Saved Games</title>

	<para> If your game allows for saved games, then sending the author a copy
	of the saved game is very important because it will help the tech reproduce
	whatever is going wrong.  For commercial games, this option is more
	fruitful than sending a core file or call stack since commercial games
	can't be recompiled to include debugging information.  Again, you should
	definitely ask before sending a save game file because they tend to get
	long, but a company like Loki Software has lots of bandwidth.  Mike
	Phillips from Loki Software mentioned that sending in saved games to Loki
	is definitely a good thing.  </para>

	<para> Needless to say, this only applies if your game crashes reproducably
	at a certain point.  If the game segfaults every time you run it, or is
	incredibly slow, a saved game file won't be of much help.  </para>

	</sect2>



<sect2><title>What to do when a file or library isn't being found
         (better living through strace)</title>

	<para> Sometimes you'll see error messages that indicate a file wasn't
	found.  The file could be a library: </para>
	
	<screen>
	% ./exult 
	./exult: error while loading shared libraries: libSDL-1.2.so.0: cannot
	load shared object file: No such file or directory
	</screen>
  
	<para> or it could be some kind of data file, like a wad or map file:
	</para>
	
	<screen>
	% qf-client-sdl  
	IP address 192.168.0.2:27001 UDP Initialized Error: W_LoadWadFile:
	couldn't load gfx.wad
	</screen>
		
	<para> Suppose gfx.wad is already on my system, but couldn't be found
	because it isn't in the right directory.  Then where IS the right
	directory?  Wouldn't it be helpful to know where these programs looked for
	the missing files?  </para>

	<para>
  This is where strace shines.  strace tells you what system calls are being
  made, with what arguments, and what their return values are.  In my `Kernel
  Module Programming Guide' (due to be released to LDP soon), I outline
  everything you may want to know about strace.  But here's a brief outline
  using the canonical example of what strace looks like.  Give the command:
  </para>
	
	<screen>strace -o ./LS_LOG /bin/ls</screen>

	<para> The -o option sends strace's output to a file; here, LS_LOG.  The
	last argument to strace is the program we're inspecting, here, "ls".  Look
	at the contents of LS_LOG.  Pretty impressive, eh?  Here is a typical line:
	</para>
	
	<screen> open(".", O_RDONLY|O_NONBLOCK|0x18000)  = 4 </screen>

	<para> We used the open() system call to open "." with various arguments,
	and "4" is the return value of the call.   What does this have to do with
	files not being found?  </para>

	<para> Suppose I want to watch the StateOfMind demo because I can't ever
	seem to get enough of it.  One day I try to run it and something bad
	happens: </para>

	<screen>
	% ./mind.i86_linux.glibc2.1 
	Loading & massaging...
	Error:Can't open data file 'mind.dat'.
	</screen>
  
	<para> Let's use strace to find out where the program was looking for the
	data file. </para>
	
	<screen>
	strace ./mind.i86_linux.glibc2.1 2> ./StateOfMind_LOG
	</screen>
  
	<para> Pulling out vim (because vim rocks) and searching for all occurances
	of "mind.dat", I find the following lines: </para>
	
	<screen> open("/usr/share/mind.dat",O_RDONLY) = -1 ENOENT (No such file)
	write(2, "Error:", 6Error:)   = 6 write(2, "Can\'t open data file
	\'mind.dat\'."..., ) = 33 </screen>
  
	<para> We see that it was looking for mind.dat in only one directory.
	Clearly, mind.dat isn't in /usr/share.   Now we can try to locate mind.dat
	and move it into /usr/share.  </para>

	<para> This method works for libraries too.  Suppose the library
	libmp3.so.2 is in /usr/local/include but your new game "Kill-Metallica"
	can't find it.  You can use strace to determine where Kill-Metallica was
	looking for the library and make a symlink of
	/usr/local/include/libmp3.so.2 to wherever Kill-Metallica was looking for
	the library file.  </para>

	<para> strace is a very powerful utility.  When diagnosing why things
	aren't being found, it's your best ally, and is even faster than looking at
	source code.  As a last note, you can't look up information in source code
	of commercial games from Lokisoft or Tribsoft.  But you can still use
	strace with them!  </para>

	</sect2>


	<sect2><title>Hosed consoles</title>

	<para> Sometimes a game will exit abnormally and your console will get
	`hosed'.  There are a few definitions of a hosed console.  The text
	characters could look like gibberish.  Your normally nice black screen
	could look like a quasi-graphics screen.  When you press
	<keysym>ENTER</keysym>, a newline doesn't get echo'ed to the screen.
	Sometimes, certain keys of the keyboard won't respond.  Logging out and
	back in won't work, but there are a few things that will: </para>

	<itemizedlist>
	<listitem><para> At the prompt, type "reset".  This should clear up many
		problems, including consoles hosed by an SVGAlib or ncurses based
		game.</para></listitem>
	
	<listitem><para> Try running the game again and exiting normally.  Once I
		had to kill Quake III in a hurry, so I gave it the 3 fingered salute.  The
		console was hosed with a quasi-graphics screen.  Running Quake III and
		exiting normally fixed the problem.</para></listitem>

	<listitem><para> The commands deallocvt and openvt will work for most of
		the other problems you'll have.  `deallocvt N' kills terminal N entirely,
		so that Alt-FN doesn't even work anymore.  "openvt -c N" starts it back
		up.</para></listitem>

	<listitem><para>If certain keys on your keyboard don't work, be creative.
		If you want to reboot but the `o' key doesn't work, try using halt.  One
		method I've come up with is typing a command at the prompt and using
		characters on the screen with mouse cut/paste.  For example, you can type
		"ps ax", and you're sure to have an `h', `a', `l' and a `t' somewhere on
		the screen.  you can use the mouse to cut and paste the word
		"halt".</para></listitem>

	<listitem><para>Lastly, the most regrettable option is a reboot.  If you
		can, an orderly shutdown is preferable; use "halt" or "shutdown".  If you
		can't, try ssh'ing (you don't use telnet, do you?) from another machine.
		That sometimes works when your console is very badly hosed.  In the worst
		case scenario, hit the reset or power switch.</para></listitem>
	</itemizedlist>

	<para> Note that if you use a journalling filesystem like Reiserfs or xfs,
	hitting the power switch isn't all that bad.  You're still supposed to
	shutdown in an orderly fasion, but the filesystem integrity will be
	maintained.  You won't see an fsck for the partitions that use the
	journalling filesystem.  </para>

	</sect2>

</sect1>




<sect1><title>Hardware</title>


	<sect2><title>Which video card is the best?</title>

	<para> If you're using Linux, you must be smart enough to know that there
	isn't a plain answer to this question.  There seem to be 3 choices for
	hardware accelerated 3D these days: </para>

	<orderedlist numeration="arabic">
	<listitem><para>3dfx:   Voodoo cards</para></listitem>
	<listitem><para>Nvidia: GeForce</para></listitem>
	<listitem><para>ATI:    Radeon</para></listitem>
	</orderedlist>

	<para> The FPS king of the hill is the GeForce, but that's at low color
	depth, lower resolution.  At higher color depth, higher resolution, the
	Radeon is king.  However, the GeForce gets slightly better visuals than the
	Radeon, although this might change once the Radeon DRI driver adds support
	for T&amp;L.  </para>

	<para> The other factor is principle.  For various reasons, Nvidia's openGL
	drivers are proprietary and closed source--you can only get them in binary
	form.  ATI and 3dfx are open source.  Personally, I think a lot can be said
	for that.  </para>

	</sect2>


	<sect2><title>Which sound card is best?</title>

	<para> Now that Linux is beginning to mature, this question isn't as
	crucial as it used to be.  Once upon a time, soundcards without onboard
	MIDI chips (most PCI sound cards) didn't do MIDI.  This was mostly a
	problem for things like xdoom or lxdoom using musserv.  These days we have
	MIDI emulators like Timidity which don't require hardware MIDI support.
	Frankly, I've had many cards and I can't tell the difference between any of
	them.  </para>

	<para> Your decision should be based on what will be the easiest to
	configure.  Redhat's sndconfig isn't perfect; I saw it identify a Creative
	PCI-128 as a Soundblaster Live.  If you already have a card and it works
	well, that's good enough.  If it doesn't work well, you're probably having
	other problems like an IRQ conflict.  If you're in the market to buy a
	sound card, get something that will take you a second to configure.  PCI
	cards are easier to deal with than ISA when an IRQ conflict raises its ugly
	head.  </para>

	<para> A more relevent issue is speakers, but even here the difference is
	slight.  I've had expensive Altec Lansing speakers perform only slightly
	better than el-cheapo speakers.  You get what you pay for with speakers,
	but don't expect a huge difference.  You'll want to get something with a
	separate sub-woofer; this does make a difference at a cost of extra power
	and connector wires (perfect application for Bluetooth or 802.11b
	technology).  </para>

	</sect2>

</sect1>


<sect1><title>Miscellaneous Problems</title>

	<sect2><title>Hardware Acceleration Problems</title>

	<para> XFree86 4.0 provides a more centralized and self-contained approach
	to video.  Much of the funkyness like kernel modules for non-root access of
	video boards is, thankfully, gone.  Solving problems is a MUCH easier task
	these days.  </para>

		<sect3><title>Hardware acceleration isn't working at all</title>

		<para> If you're getting like 1 fps, then for some reason, your system
		isn't using hardware 3D acceleration.  There's one of two things that can
		be going on. </para>

		<orderedlist numeration="arabic">
    <listitem><para>Your 3D system is misconfigured (more likely)</para>
			</listitem>
    <listitem><para>Game X is misconfigured (less likely)</para></listitem>
		</orderedlist>

		<para> The first step is to figure out which one is happening. </para>

		<orderedlist numeration="arabic">
		<listitem><para>If you have X 4.0 (X 3.* users procede directly to step 2),
			look at the the output of X -probeonly.  You'll see: </para>

			<screen> (II) XXXXXX: direct rendering enabled </screen>

			<para> or </para>

			<screen> (II) XXXXXX: direct rendering disabled </screen>

			<para> Where XXXXXXX depends on which video card you have.  If direct
			rendering is disabled, then your X set up is definitely faulty.  Your
			game is not at fault.  You need to figure out why DRI is disabled.  The
			most important tool for you to use at this point is the `DRI Users
			Guide'.  It is an excellently written document that gives you step by
			step information on how to get DRI set up correctly on your machine.  A
			copy is kept at <systemitem role="url">
			http://www.xfree86.org/4.0/DRI.html</systemitem>.</para>

			<para> Note that if you pass this test, your system is CAPABLE of
			direct rendering.  Your libraries can still be wrong.  So procede to
			step 2. </para>
		</listitem>

		<listitem><para> There is a program called gears which comes with the
			"mesademos" package.  You can get mesademos with debian (apt-get install
			mesademos) or you can hunt for the rpm on rpmfind.net.  You can also
			download and compile the source yourself from the mesa homepage. </para>

			<para> Running gears will show some gears turning.  The xterm from
			which you run gears will read "X frames in Y seconds = X/Y FPS".  You
			can compare your system to the list of benchmarks below.  The best way
			to do this is to kill all non-critical processes first.  There's no
			need to run it as root.  </para>

			<screen>
			CPU TYPE     VIDEO CARD     X VERSION    AVERAGE FPS
			</screen>

			<para> Compiling Mesa and DRI modules yourself can increase your FPS by
			15 FPS; quite a performance boost!  So if your number is, say, about 20
			FPS slower than a comparable machine, chances are that gears is falling
			back on software rendering.  In other words, your graphics card isn't
			3D accelerating graphics. </para>

			<para>More important than FPS is having a constant FPS for small and
			large windows.  If hardware acceleration is working, the FPS for gears
			should be nearly independent of window size.  If it's not, then you're
			not getting hardware acceleration. </para>
		</listitem>
		</orderedlist>

		</sect3>

	</sect2>


	<sect2><title>Hardware acceleration works for root, but not for
	non-root</title>

	<para> If the following lines don't appear in XFConfig-4, put them
	there:</para>

	<screen>
     Section "DRI"
             Mode 0666
     EndSection
	</screen>

	<para> This allows all non-root users to use DRI.  For the paranoid, it's
	possible to restrict DRI to only a few non-root users.  See the DRI User
	Guide.  </para>


		<sect3><title>Voodoo specific slowness</title>

		<para> Under X3, Voodoo acceleration only takes place ONLY at 16bpp color
		and fails silently if you try to start X in 32bpp color.  Under X4,
		acceleration takes place in 16bpp and 24bpp color, but X will fail to
		start if you use a color depth that the Voodoo card can't handle.
		</para>

		<para> Also, under X3, Voodoo boards needed the 3dfx kernel module and
		/dev/3dfx device file for non-root hardware acceleration.  Neither the
		module nor the device file is used under X4.  </para>

		</sect3>

	</sect2>


	<sect2><title>Why isn't my sound working?</title>

	<para> First of all, it's probably not the game, it's probably your setup.
	AFAIK, there are 3 options to getting a sound card configured under Linux:
	the free OSS sound drivers that come with the Linux kernel, the Alsa
	drivers and the commercial OSS sound drivers.  Personally, I prefer the
	free OSS drivers, but many people swear by Alsa.  The commercial OSS
	drivers are good when you're having trouble getting your sound card to work
	by free methods.  Don't discount them; they're very cheap (like 10 or 20
	bucks), support bleeding edge sound cards and take a lot of guesswork out
	of the configuring process.</para>

	<para> There are 4 things that can go wrong with your sound system: </para>

	<orderedlist numeration="arabic">
  <listitem><para>Shared interrupt</para></listitem>
	<listitem><para>Misconfigured driver</para></listitem>
	<listitem><para>Something's already accessing the sound card</para></listitem>
	<listitem><para>You're using the wrong driver </para></listitem>
	</orderedlist>


		<sect3><title>Shared interrupt</title>

		<para> The first thing to do is to figure out if you have an IRQ
		conflict.  ISA cards can't share interrupts.  PCI cards can share
		interrupts, but certain types of high bandwidth cards simply don't like
		to share.  These cards include network cards and sound cards.  To find
		out whether you have a conflict, do a "cat /proc/interrupts".  Output on
		my system is: </para>

		<screen>
    # cat /proc/interrupts
               CPU0       CPU1
      0:   24185341          0          XT-PIC  timer
      1:     224714          0          XT-PIC  keyboard
      2:          0          0          XT-PIC  cascade
      5:    2478476          0          XT-PIC  soundblaster
      5:     325924          0          XT-PIC  eth0
     11:     131326          0          XT-PIC  aic7xxx
     12:    2457456          0          XT-PIC  PS/2 Mouse
     14:     556955          0          XT-PIC  ide0
    NMI:          0          0
    LOC:   24186046   24186026
    ERR:       1353
		</screen>

		<para> The second column is there because I have 2 CPU's in this machine
		(called SMP) if you have one CPU (called UP, or uniprocessor), you'll
		have only 1 CPU column.  The numbers on the left are the assigned IRQ's
		and hte strings to the right indicate what device was assigned that IRQ.
		You can see I have an IRQ conflict between the soundcard (soundblaster)
		and the network card (eth0).  They both share IRQ 5.  Actually, I cooked
		this example up because I wanted to show you what an IRQ conflict looks
		like.  But if I did have this conflict, neither my network nor my sound
		would work.  </para>

		<para> If my sound card is PCI, the preferred way of fixing this would be
		to simply move one of the cards to a different slot and hope the BIOS
		sorts things out.  A more advanced way of fixing this would be to go into
		BIOS and assign IRQ's to specific slots.  Modern BIOS'es can do this.
		</para>

		<para> If your card is ISA and you have a IRQ conflict, I'm embarrased to
		admit that I don't know what to do.  Maybe some kind soul will donate a
		detailed outline about how to use isapnp and pnpdump to this HOWTO.
		</para>

		</sect3>


		<sect3><title> Misconfigured driver </title>

		<para> Sometimes, a card is hardwired to use a certain IRQ.  You'll see
		this on ISA cards only.  Alternatively, some ISA cards can be set to use
		a specific IRQ using jumpers on the card itself.  With these types of
		cards, you need to pass the correct IRQ and memory access, "I/O port", to
		the driver.  </para>

		<para> This is a sound card specific issue, and beyond the scope of this
		HOWTO.  (I should write about how to pass info to the driver).  </para>

		</sect3>


		<sect3><title>Something is already accessing your sound card</title>

		<para> Perhaps an application is already accessing your soundcard.  For
		example, maybe you have an MP3 player that's paused?  If something is
		already accessing your card, other applications won't be able to.  Even
		though it was written to share the card between applications, I've found
		that esd (the enlightenment sound daemon) sometimes doesn't work
		correctly.  The best tool to use here is lsof, which shows which
		processes are accessing a file.  Your sound card is represented by
		/dev/dsp.  Right now, I'm listening to an MP3 (not a Metallica MP3, of
		course...) with mp3blaster.  </para>

		<screen>
    # lsof /dev/dsp
    COMMAND    PID USER   FD   TYPE DEVICE SIZE   NODE NAME
    mp3blaste 1108    p    6w   CHR   14,3      662302 /dev/dsp
		</screen>

		<para> fuser is similar; but it lets you send a signal to any process
		accessing the device file.  </para>

		<screen>
    # fuser -vk /dev/dsp
    
                         USER        PID ACCESS COMMAND
    /dev/dsp             root       1225 f....  mp3blaster
                         root       1282 f....  mp3blaster
		</screen>

		<para> After issuing this command, mp3blaster was killed with SIGKILL.
		See the man pages for lsof and fuser; they're very useful.  Oh, you'll
		want to run them as root since you'll be asking for information from
		processes that may be owned by root. </para>

		</sect3>


		<sect3><title>You're using the wrong driver (or no driver)</title>

		<para> There are only two ways to configure your card: </para>

		<orderedlist numeration="arabic">
		<listitem><para>
			Support must be compiled directly into the kernel
			</para></listitem>
		<listitem><para>
			You must have the correct driver loaded into memory
			</para></listitem>
		</orderedlist>

		<para> You can find out which driver your sound card is using by doing
		"lsmod" or looking at the output of "dmesg".  Since sound is crucial for
		me, I always compile sound into my kernels.  If you don't have a driver
		loaded, you need to figure out what's been compiled into your kernel.
		That's not so straight forward.  Your best bet is to compile your kernel.
		BTW, let me say that compiling your own kernel is the first step towards
		proficiency with Linux.  It's painful the first time you do it, but once
		you do it correctly, it becomes very easy down the right, especially if
		you keep all your old .config files and make use of things like "make
		oldconfig".  See the Kernel HOWTO for details.  </para>

		<para> If you haven't compiled the kernel yourself, there is an
		overwhelmingly good chance that your system is set up to load sound
		drivers as modules.  That's the way distros do things.  Have everything
		under the sun compiled as a module and try to load them all.  So if you
		don't see your sound card's driver with lsmod, your card probably isn't
		configured yet.  </para>

		</sect3>

	</sect2>

</sect1>




<sect1><title>Websites</title>

	<sect2><title>Meta Gaming websites</title>

	<variablelist>

  <varlistentry><term>The Linux Game Tome: <systemitem role="url">
		www.happypenguin.org</systemitem></term><listitem><para>About the games
		themselves.</para>
		</listitem></varlistentry>

  <varlistentry><term><systemitem role="url">
		www.linuxgames.com</systemitem></term><listitem><para>Linux gaming news
		</para></listitem></varlistentry>

  <varlistentry><term><systemitem role="url">
		www.holarse.net</systemitem></term><listitem><para>Linux meta gaming site
		for German speaking folk.</para>
		</listitem></varlistentry>
	</variablelist>

	</sect2>


	<sect2><title>Commercial Linux Game Websites</title>

		<sect3><title> Where to buy commercial games </title>

		<variablelist>
	  <varlistentry><term>Tux Games:<systemitem role="url">www.tuxgames.com
			</systemitem></term><listitem><para> Your one stop shop for buying any
			commercial Linux game (software vendors like Tribsoft and Loki have
			online shops at their websites too).</para></listitem></varlistentry>

		<varlistentry><term>ebgames:<systemitem role="url">www.ebgames.com
			</systemitem> </term><listitem><para> They've got the best prices for
			Linux games I've ever seen.</para></listitem></varlistentry>

		<varlistentry><term><systemitem role="url">Loki-Software:
			http://www.lokigames.com/orders/</systemitem></term><listitem><para> Loki
			maintains an online ordering system for their games (they no longer sell
			Quake 3).</para></listitem></varlistentry>
		</variablelist>

		</sect3>


		<sect3><title> Who is releasing games for Linux </title>

		<variablelist>

		<varlistentry><term>Loki Software:<systemitem role="url">www.lokigames.com
			</systemitem> </term><listitem><para> As the company that brought
			quake3 to Linux, Loki is the father of Linux gaming.  They were the
			first and have, by far, the most titles available.  Loki ports games to
			Linux, mostly using the SDL library.  They have so many games (I own
			most of them ;) ) that I won't even try to describe them all.
			</para></listitem> </varlistentry>

		<varlistentry><term>Tribsoft:<systemitem role="url">www.tribsoft.com
			</systemitem></term><listitem><para> Currently they only have Jagged
			Alliance 2, but are coming out with Europai Universalis, Majesty and
			Unfinished Business.</para>

			<para> Jagged Alliance 2 is a cross between an rpg and a strat.  You
			play a mercenary hired to take over a 3rd world country from a ruthless
			dictator.  The game has some stability issues, and Tribsoft never
			replied to my bug reports.  However, ja2 is very addictive and nicely
			done.  It's clearly the most complicated game I've ever seen. </para>
			</listitem> </varlistentry>

		<varlistentry><term>Hopkins FBI:<systemitem role="url">www.hopkinsfbi.com
			</systemitem></term><listitem><para> This is my favorite game.  More
			violent than Quake.  More nudity than Hustler.  More camp than
			Liberacce.  It's a comic book on your monitor.  If anyone knows why the
			author didn't pursue Hopkins II, please tell me! </para></listitem>
			</varlistentry>

		<varlistentry><term>Terminus:<systemitem role="url">
			www.vvisions.com/terminus/index2.html</systemitem></term><listitem><para>
			I bought it but haven't played it yet.  I'm still working on Myth2.
			</para></listitem> </varlistentry>

		<varlistentry><term>Phantom EFX:<systemitem role="url">www.phantomefx.com
			</systemitem></term><listitem><para>They offer Reel Deal Slots.  I
			played the demo; it was very nicely done!  I'm not much for
			poker/card/gambling games, but this was impressive.  In the future,
			they'll be offering Reel Deal Casino and Casino Tycon.
			</para></listitem> </varlistentry>

		<varlistentry><term>Theocracy:<systemitem role="url">www.theocracy.com
			</systemitem></term><listitem><para> A realtime strat where you play an
			Aztec leader by Ubisoft.  You'd never know this game has a Linux port.
			In 10 minutes of surfing, I just barely found any references to this
			game being available on Linux.  Linux dollars don't mean much here.
			Not even a mention on happypenguin.org!  </para></listitem>
			</varlistentry>

		<varlistentry><term>Hyperion Software:<systemitem role="url">
			http://www.hyperion-software.com</systemitem></term><listitem><para>
			This company has ported Shogo: Mobile Armor Division (an anime inspired
			Robotech based FPS).  They're also in the process of porting SiN, a
			very cool looking FPS; looks similar to SoF.  The demo is awesome, but
			I heard the project might be stalled.  They've ignored all my emails.
			</para></listitem> </varlistentry>
	
		</variablelist>

		</sect3>

	</sect2>


	<sect2><title>Specific Websites Of Note</title>

	<variablelist><title>First Person Shooters</title>
	<varlistentry><term><systemitem role="url">www.linuxquake.com</systemitem>
		</term><listitem><para>Linux meta-site for first person shooters
		</para></listitem></varlistentry>
  <varlistentry><term><systemitem role="url">planetquake.com/linux</systemitem>
		</term><listitem><para>Linux meta-site for first person shooters
		</para></listitem></varlistentry>
	<varlistentry><term><systemitem role="url">www.quakeforge.net</systemitem>
		</term><listitem><para>Linux Quake I effort
		</para></listitem></varlistentry>
  <varlistentry><term><systemitem role="url">lhl.linuxgames.com</systemitem>
		</term><listitem><para>Half-life on Linux
		</para></listitem></varlistentry>
	</variablelist>

	<variablelist><title>Three main Doom efforts</title>
		<varlistentry><term><systemitem role="url">prboom.sourceforge.net
			</systemitem></term><listitem><para>A GPL cross platform Doom engine
			</para></listitem></varlistentry>
    <varlistentry><term><systemitem role="url">www.doomlegacy.com
			</systemitem></term><listitem><para>A GPL cross platform Doom engine
			</para></listitem></varlistentry>
    <varlistentry><term><systemitem role="url">zdoom.notgod.com
			</systemitem></term><listitem><para>Non-GPL Doom engine (source available)
			</para></listitem></varlistentry>
	</variablelist>

	<variablelist><title>Interactive Fiction</title>
  <varlistentry><term><systemitem role="url">www.msadams.com</systemitem>
		</term><listitem><para>Scott Adam's mebsite
			</para></listitem></varlistentry>
  <varlistentry><term><systemitem role="url">www.cfug.org/infocom</systemitem>
		</term><listitem><para>Infocom on Linux website
			</para></listitem></varlistentry>
  <varlistentry><term><systemitem role="url">www.if-legends.org</systemitem>
		</term><listitem><para>Very cool interactive fiction site
		</para></listitem></varlistentry>
	</variablelist>

	</sect2>


	<sect2><title>Other websites</title>

	<variablelist>

	<varlistentry><term><systemitem role="url">www.dri.sourceforge.net
		</systemitem></term><listitem><para>
		DRI's homesite; see question 2.4.  If you're having problems with hardware
		acceleration, the DRI User Guide is mandatory reading.
		</para></listitem></varlistentry>

	<varlistentry><term><systemitem role="url">www.mesa3d.org
		</systemitem></term><listitem><para>
		Mesa homesite; see question 2.3.
		</para></listitem></varlistentry>

	<varlistentry><term><systemitem role="url">www.xfree86.org
		</systemitem></term><listitem><para>
		XFree86.org site
		</para></listitem></varlistentry>

  <varlistentry><term><systemitem role="url">www.libsdl.org
		</systemitem></term><listitem><para>
		SDL's Homepage; see question 2.8.
		</para></listitem></varlistentry>

  <varlistentry><term><systemitem role="url">www.openal.org
		</systemitem></term><listitem><para>
		OpenAL's website; see question 2.11.
		</para></listitem></varlistentry>

  <varlistentry><term><systemitem role="url">www.ggi-project.org
		</systemitem></term><listitem><para>
		GGI's homepage; see question 2.9.
		</para></listitem></varlistentry>

	</variablelist>

	<para> It's generally easier to get native code working, but for software
	which which will never be ported, there's always emulation.  </para>

	<variablelist>

  <varlistentry><term><systemitem role="url">www.dosemu.org
		</systemitem></term><listitem><para>
		dosemu's website.  dosemu emulates DOS and some win32 applications.
		</para></listitem></varlistentry>

  <varlistentry><term><systemitem role="url">www.winehq.org
		</systemitem></term><listitem><para>
		wine's website.  Emulates win32 applications.
		</para></listitem></varlistentry>

	<varlistentry><term><systemitem role="url">www.transgaming.com
		</systemitem></term><listitem><para>
		These people are implementing DirectX within Wine's framework.  They have
		an interesting business model.  Their code will, at first, be commercial.
		They'll release code every so often under the open-source wine license.
		</para></listitem></varlistentry>

	</variablelist>

	</sect2>

</sect1>

</article>

