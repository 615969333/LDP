<!DOCTYPE Article PUBLIC "-//OASIS//DTD DocBook V3.1//EN" [
 <!ENTITY phtindex SYSTEM "index.sgml">
 <!ENTITY printerlist SYSTEM "printers.sgml">
]>


<Article id="index">
 <ArtHeader>
  <Title>The Linux Printing HOWTO</Title>
  <AUTHOR>
   <FirstName>Grant</FirstName> 
   <SurName>Taylor</SurName>
   <affiliation>
    <address>
     <email>gtaylor+pht@picante.com</email>
    </address>
   </affiliation>
  </AUTHOR>
  <PubDate>Version $Revision$, $Date$</PubDate>
  <Abstract>
   <Para>
     This is the Linux Printing HOWTO, a collection of information on
     how to generate, preview, print and fax anything under Linux (and
     other Unices in general).
   </Para>
  </Abstract>
 </ArtHeader>

 <Sect1 id="howto-intro">
  <Title>Introduction</Title>

  <Para>
    The Printing HOWTO should contain everything you need to know to
    help you set up printing services on your Linux box(en).  As life
    would have it, it's a bit more complicated than in the
    point-and-click world of Microsoft and Apple, but it's also a bit
    more flexible and certainly easier to administer for large LANs.
  </Para>

  <Para>
    This document is structured so that most people will only need to
    read the first half or so.  Most of the more obscure and
    situation-dependent information in here is in the last half, and
    can be easily located in the Table of Contents, whereas most of
    the information through section 8 or 9 is probably needed by most
    people.
  </Para>

  <Para>
    If you find this document or the <ulink
    url="http://www.linuxprinting.org/">LinuxPrinting.org</ulink>
    website useful, consider buying something through my referral
    association with buy.com or outpost.com; please use the links on
    the <ulink
    url="http://www.linuxprinting.org/suggested.html">suggested
    printers page</ulink> so that your purchase can be credited to
    LinuxPrinting.org.
  </Para>

  <Para>
    Since version 3.x is a complete rewrite, some information from
    previous editions has been lost.  This is by design, as the
    previous HOWTOs were so large as to be 60 typeset pages, and had
    the narrative flow of a dead turtle.  If you do not find your
    answers here, you are encouraged to a) look on the <ULink
    URL="http://www.linuxprinting.org/">LinuxPrinting.org website</ULink>
    and b) drop me a note saying what ought to be here but isn't.
  </Para>

  <Para>
    The <ULink URL="http://www.linuxprinting.org/">LinuxPrinting.org
    website</ULink > is a good place to find the latest version; it is
    also, of course, distributed from Metalab (<Literal
    remap="tt">metalab.unc.edu</Literal>) and your friendly local LDP
    mirror.
  </Para>

 <Sect2 id="howto-hist">
  <Title>History</Title>

  <Para>
    This is the fourth generation of the Printing HOWTO.  The history
    of the PHT may be chronicled thusly:

    <OrderedList>
     <ListItem>
      <Para>
        I wrote the printing-howto in 1992 in response to too many
        printing questions in comp.os.linux, and posted it.  This
        predated the HOWTO project by a few months and was the first
        FAQlet called a `howto'.  This edition was in plain ascii.
      </Para>
     </ListItem>

     <ListItem>
      <Para>
       After joining the HOWTO project, the Printing-HOWTO was merged
       with an Lpd FAQ by Brian McCauley <Literal
       remap="tt">&lt;B.A.McCauley@bham.ac.uk&#62;</Literal>; we
       continued to co-author the PHT for two years or so.  At some
       point we incorporated the work of Karl Auer <Literal
       remap="tt">&lt;Karl.Auer@anu.edu.au&#62;</Literal>.  This
       generation of the PHT was in TeXinfo, and available in PS,
       HTML, Ascii, and Info.
      </Para>
     </ListItem>

     <ListItem>
      <Para>
       After letting the PHT rot and decay for over a year, and an
       unsuccessful attempt at getting someone else to maintain it,
       this rewrite happened.  This generation of the PHT is written
       in SGML using the LinuxDoc DTD and the SGML-Tools-1 package.
       Beginning with version 3.27, it incorporates a summary of a
       companion printer support database; before 3.27 there was never
       a printer compatibility list in this HOWTO (!).
      </Para>
     </ListItem>

     <ListItem>
      <Para>
       In mid-January, 2000, I found out about the PDQ print
       "spooler".  PDQ provides a printing mechanism so much better
       than lpd ever did that I spent several hours playing with it,
       rewrote parts of this HOWTO, and bumped the version number of
       the document to 4.
      </Para>
     </ListItem>

     <ListItem>
      <Para>
       In mid-2000, I moved my printing website to <literal
       remap="tt">www.linuxprinting.org</literal>, and began offering
       more powerful configuration tools there.  I also converted the
       HOWTO to DocBook, and initiated coverage of CUPS, LPRng, and
       GPR/libppd.
      </Para>
     </ListItem>

    </OrderedList>
   </Para>

  </Sect2>

  <Sect2 id="howto-copy">
   <Title>Copyright</Title>
   <Para>
    This document is Copyright (c) 1992-2000 by Grant Taylor.  Feel
    free to copy and redistribute this document according to the terms
    of the GNU General Public License, revision 2 or later.
   </Para>
  </Sect2>

 </Sect1>

 <Sect1 id="quickstart">
  <Title>Quick Start</Title>

  <Para>
   The quickest way to get started is simply to use the setup tools
   provided by your vendor.  Assuming that this includes support for
   your driver, and assuming that your vendor shipped the driver for
   your printer, then it should be easy to get a basic setup going
   this way.  For information on vendor-provided setup tools, see
   <xref linkend="vendors">.
  </Para>

  <Para>
   If your vendor's tool doesn't work out, you should
   figure out if your printer is supposed to work at all.  Consult the
   printer compatibility listings in <xref
   linkend="printer-compat-list"> as well as the online version
   described there.
  </Para>

  <Para>
   If your printer is known to work with a driver, check that you have
   that driver, and install if it not.  Typically you will be able to
   find a contributed Ghostscript package including newer Ghostscript
   code and assorted third-party drivers.  If not, you can compile it
   yourself; the process is not trivial, but it is well documented.
   See <xref linkend="ghostscript"> for more information on
   Ghostscript.
  </Para>

  <Para>
   After installing the proper driver, attempt again to configure your
   printer with your vendor's tools.  If that fails, select a
   suitable third party tool from those described in <xref
   linkend="setup">.  If that also fails, you'll need to construct
   your own setup; again see <xref linkend="setup">.
  </Para>

  <Para>
   If you're still stuck, you've got a little troubleshooting to do.
   It's probably best to read most of this document first to get a
   feel for how things are supposed to work; then you'll be in a
   better position to debug.
  </Para>

 </Sect1>

 <Sect1 id="how">
  <Title>How to print</Title>

  <Para>
   You actually use a different command to print depending on which
   spooling software you use. 
  </Para>

  <Sect2 id="pdqintro">
   <indexterm><primary>PDQ</primary><secondary>usage</secondary></indexterm>
   <Title>With PDQ</Title>

   <Para>
    Most systems today ship with lpd, so this section won't apply.
    That said, I now recommend that people install and use PDQ in most
    cases instead of (or in addition to) lpd.  PDQ just has much
    better support for printer options and such.
   </Para>

   <Para>
    With PDQ, instead of the lpr command, you use the command <ULink
    URL="http://feynman.tam.uiuc.edu/pdq/man/pdq.1.html" >pdq</ULink >
    or <ULink URL="http://feynman.tam.uiuc.edu/pdq/man/xpdq.1.html"
    >xpdq</ULink >.  Both work much like the traditional lpr in that
    they will print the files you specify, or stdin if no files are
    given.
   </Para>

   <Sect3 id="xpdq-intro">
    <indexterm><primary>xpdq</primary><secondary>usage</secondary></indexterm>
    <indexterm><primary>xpdq</primary><seealso>PDQ</seealso></indexterm>
    <Title>Xpdq</Title>

    <Para>
     Xpdq is an X Windows application that shows a list of available
     printers and a summary of the print queue (including current and
     historical jobs).  There are two options under the File menu, one
     to print specific files, and one to print stdin.  You can set
     whatever options are defined in your printer driver from the
     Driver Options dialog; typically there will be duplex,
     resolution, paper type and size settings, and so forth.
    </Para>
   </Sect3>

   <Sect3 id="pdq-intro">
    <Title>Pdq</Title>

    <Para>
     The PDQ system's command-line printing command is simply called
     <command>pdq</command>.  It can be used in place of the lpr
     command in most situations; it accepts the <Literal
     remap="tt">-P</Literal> printer specification argument.  Like
     lpr, it prints either the listed file(s) or stdin.
    </Para>

    <Para>
     Printer options can be controlled with the <Literal
     remap="tt">-o</Literal> and <Literal remap="tt">-a</Literal>
     options.
    </Para>
   </Sect3>

  </Sect2>

  <Sect2 id="with-lpd-and-lpr">
   <indexterm><primary>lpr</primary><secondary>usage</secondary></indexterm>
   <Title>With LPD and the lpr command</Title>

   <Para>
    If you've already got lpd setup to print to your printer, or your
    system administrator already did so, or your vendor did so for
    you, then all you need to do is learn how to use the lpr command.
    The <ULink
    URL="http://metalab.unc.edu/LDP/HOWTO/Printing-Usage-HOWTO.html"
    >Printing Usage HOWTO</ULink > covers this, and a few other queue
    manipulation commands you should probably know.  Or just read the
    lpr(1) man page.
   </Para>

   <Para>
    In a nutshell, you specify the queue name with <literal
    remap="tt">-P</literal>, and specify a filename to print a file,
    or nothing to print from stdin.  Driver options are traditionally
    not controllable from lpr, but various systems accept certain
    options with <literal remap="tt">-o</literal>, <literal
    remap="tt">-Z</literal>, or <literal remap="tt">-J</literal>.
   </Para>

   <Para>
    If, however, you have a new system or new printer, then you'll
    have to set up printing services one way or another before you can
    print.  Read on!
   </Para>
  </Sect2>

  <Sect2 id="how-with-gui-tools">
   <Title>GUI Printing Tools</Title>

   <Para>
    Most spooling systems alone offer only a rather basic command-line
    interface.  Rather than use <command>lpr</command> directly, you
    may wish to obtain and use a front-end interface.  These generally
    let you fiddle with various printing options (the printer, paper
    types, collation, n-up, etc) in an easy-to-use graphical way.
    Some may have other features, as well.
   </Para>

   <SimpleSect id="gpr-intro">
    <Title>GPR</Title>
    <Para>
     <ulink url="http://www.compumetric.com/linux.html">GPR</ulink>,
     by Thomas Hubbell, uses code from CUPS to filter Postscript jobs
     and offer easy user control over job options.  Some options (like
     n-way printing, page selection, etc) are implemented directly by
     GPR, while most others are implemented by the printer or by the
     spooler's filter system.  
    </Para>

    <Para>
     GPR works with LPD or LPRng; or can be compiled specifically for
     use with VA Linux's modified LPD.  When compiled normally, it
     uses VA's libppd directly to produce printer-specific
     PostScript which it will then submit to the lpr command.  When
     compiled for VA's LPD, it will submit your unmodified job
     PostScript to the lpr command, along with the set of job options
     you specify.  This is arguably the better route, since it allows
     the Postscript to be redirected to a different printer by the
     spooler when appropriate; unfortunately it required VA's special
     LPD, which is not in wide circulation yet (although it is of
     course trivial to install).
    </Para>

    <Para>
     To use GPR, first select a
     printer (by LPD queue name) and check that GPR has loaded the
     proper PPD file.  If it hasn't, you'll need to specify the PPD
     filename, and specify your printer's options in the Printer
     Configuration dialog (you get this dialog by pressing the Printer
     Configuration button; it contains assorted printer setup options
     defined by the PPD).
    </Para>

    <Para>
     Once you've configured your printer in GPR, you can print jobs by
     specifying the filename and selecting the proper options from the
     `Common' and `Advanced' tabbed panels.  The `Common' options are
     implemented directly by GPR for all printers, while the
     `Advanced' options are defined by the PPD file for your printer.
     You can see these option panels in <xref
     linkend="snapshot-gpr-common"> and <xref
     linkend="snapshot-gpr-printer">.
    </Para>

    <Figure id="snapshot-gpr-main">
     <title>GPR Main Options</title>
     <graphic fileref="snapshot-gpr-main" scale="60"></graphic>
    </Figure>

    <Figure id="snapshot-gpr-common">
     <title>GPR Common Options</title>
     <graphic fileref="snapshot-gpr-common" scale="60"></graphic>
    </Figure>

    <Figure id="snapshot-gpr-printer">
     <title>GPR Printer Options</title>
     <graphic fileref="snapshot-gpr-printer" scale="60"></graphic>
    </Figure>
   </SimpleSect>


   <SimpleSect id="xpp-sect">
    <Title>XPP</Title>
    <indexterm><primary>XPP</primary></indexterm>

    <Para>
     If you use CUPS as your spooler, you can use the program
     <command><ulink
     url="http://www.phy.uni-bayreuth.de/till/xpp/">XPP</ulink
     ></command > (see <xref linkend="snapshot-xpp-main">).
    </Para>

    <Para>
     To print with XPP, simply run the xpp program, and specify a file
     (or nothing, if you're using xpp in place of lpr to print from
     stdin).  Then select a printer from the list of configured
     printers, and select any options you'd like to apply from the
     various tabbed panels.  See <xref linkend="snapshot-xpp-options">
     for an example options panel highlighting the standard CUPS
     options.
    </Para>

    <Para>
     You can save your selected printer and all the options with the
     `Save Settings' button.
    </Para>     

    <figure id="snapshot-xpp-main">
     <title>XPP Main Window</title>
     <graphic fileref="snapshot-xpp-main" scale="60"></graphic>
    </figure>

    <figure id="snapshot-xpp-options">
     <title>CUPS/XPP Options Window</title>
     <graphic fileref="snapshot-xpp-options" scale="60"></graphic>
    </figure>

   </SimpleSect>

   <SimpleSect>
    <Title>XPDQ</Title>
    <Para>
     PDQ can be easily configured to print to queues controlled by
     most spooling systems, and PDQ's configuration syntax offers a
     very easy way to define arbitrary filtering and user options for
     print jobs.  So you can thus use <command>xpdq</command> as a
     front-end to LPD printing with great success.
    </Para>

    <Para>
     For more information, see <xref linkend="pdq-which-spooler">.
    </Para>
   </SimpleSect>

  </Sect2>

 </Sect1>

 <Sect1 id="kernel">
  <indexterm>
   <primary>ports</primary>
  </indexterm>
   
  <Title>Kernel printer devices</Title>

  <indexterm>
   <primary>drivers</primary>
   <secondary>port</secondary>
   <seealso>ports</seealso>
  </indexterm>

  <Para>
   There are two completely different device drivers for the parallel
   port; which one you are using depends on your kernel version (which
   you can find out with the command <Literal remap="tt">uname
   -a</Literal>).  The driver changed in Linux 2.1.33; essentially all
   current systems will be running kernel 2.2 or later, so you'll
   probably want to skip ahead to the parport driver section.
  </Para>

  <Para>
   A few details are the same for both styles of driver.  Most
   notably, many people have found that Linux will not detect their
   parallel port unless they disable "Plug and Play" in their PC BIOS.
   (This is no surprise; the track record for PnP of non-PCI devices
   with Windows and elsewhere has been something of a disaster).
  </Para>

  <Sect2 id="old-lp-device">
   <indexterm>
    <primary>ports</primary>
    <secondary>parallel</secondary>
   </indexterm>

   <Title>The lp device (kernels &lt;=2.1.32)</Title>

   <Para>
    The Linux kernel (&lt;=2.1.32), assuming you have compiled in or
    loaded the lp device (the output of <Literal remap="tt">cat
    /proc/devices</Literal> should include the device lp if it is
    loaded), provides one or more of <Emphasis>/dev/lp0</Emphasis>,
    <Emphasis>/dev/lp1</Emphasis>, and <Emphasis>/dev/lp2</Emphasis>.
    These are NOT assigned dynamically, rather, each corresponds to a
    specific hardware I/O address.  This means that your first printer
    may be <Emphasis>lp0</Emphasis> or <Emphasis>lp1</Emphasis>
    depending on your hardware.  Just try both.
   </Para>

   <Para>
    A few users have reported that their bidirectional lp ports aren't
    detected if they use an older unidirectional printer cable.  Check
    that you've got a decent cable.
   </Para>

   <Para>
    One cannot run the plip and lp drivers at the same time on any
    given port (under 2.0, anyway).  You can, however, have one or the
    other driver loaded at any given time either manually, or by
    kerneld with version 2.x (and later 1.3.x) kernels.  By carefully
    setting the interrupts and such, you can supposedly run plip on
    one port and lp on the other.  One person did so by editing the
    drivers; I eagerly await a success report of someone doing so with
    only a clever command line.
   </Para>

   <Para>
    There is a little utility called <Literal remap="tt"><ULink
    URL="http://www.linuxprinting.org/man/tunelp.8.html">tunelp</ULink
    ></Literal> floating about with which you, as root, can tune the
    Linux 2.0 lp device's interrupt usage, polling rate, and other
    options.
   </Para>

   <Para>
    When the lp driver is built into the kernel, the kernel will
    accept an <Literal remap="tt">lp=</Literal> option to set
    interrupts and io addresses:

<Screen>
When the lp driver is built in to the kernel, you may use the
LILO/LOADLIN command line to set the port addresses and interrupts
that the driver will use.

Syntax:      lp=port0[,irq0[,port1[,irq1[,port2[,irq2]]]]]

For example:   lp=0x378,0   or   lp=0x278,5,0x378,7 **

Note that if this feature is used, you must specify *all* the ports
you want considered, there are no defaults.  You can disable a
built-in driver with lp=0.
</Screen>

   </Para>

   <Para>
    When loaded as a module, it is possible to specify io addresses
    and interrupt lines on the insmod command line (or in
    <Emphasis>/etc/conf.modules</Emphasis> so as to affect kerneld)
    using the usual module argument syntax.  The parameters are
    <Literal remap="tt">io=port0,port1,port2</Literal> and <Literal
    remap="tt">irq=irq0,irq1,irq2</Literal>.  Read ye the man page for
    <Emphasis><ULink
    URL="http://www.linuxprinting.org/man/insmod.1.html"
    >insmod</ULink ></Emphasis> for more information on this.
   </Para>

   <Para>
    **For those of you who (like me) can never find the standard port
    numbers when you need them, they are as in the second example
    above.  The other port (<Emphasis>lp0</Emphasis>) is at 0x3bc.
    I've no idea what interrupt it usually uses.
   </Para>

   <Para>
    The source code for the Linux 2.0 parallel port driver is in
    /usr/src/linux/drivers/char/lp.c.
   </Para>

  </Sect2>

  <Sect2 id="new-parport-device">
   <indexterm>
    <primary>ports</primary>
    <secondary>parallel</secondary>
   </indexterm>
   <Title>The parport device (kernels &gt;= 2.1.33)</Title>

   <Para>
    Beginning with kernel 2.1.33 (and available as a patch for kernel
    2.0.30), the lp device is merely a client of the new parport
    device.  The addition of the parport device corrects a number of
    the problems that plague the old lp device driver - it can share
    the port with other drivers, it dynamically assigns available
    parallel ports to device numbers rather than enforcing a fixed
    correspondence between I/O addresses and port numbers, and so
    forth.
   </Para>

   <Para>
    The advent of the parport device has enabled a whole flock of new
    parallel-port drivers for things like Zip drives, Backpack CD-ROMs
    and disks, and so forth.  Some of these are also available in
    versions for 2.0 kernels; look around on the web.
   </Para>

   <Para>
    The main difference that you will notice, so far as printing goes,
    is that parport-based kernels dynamically assign lp devices to
    parallel ports.  So what was lp1 under Linux 2.0 may well be lp0
    under Linux 2.2.  Be sure to check this if you upgrade from an
    lp-driver kernel to a parport-driver kernel.
   </Para>

   <Para>
    The most popular problems with this device seems to stem from
    misconfiguration:
    <VariableList>
     <VarListEntry>
      <Term>The Distribution</Term>
      <ListItem>
       <Para>Some Linux distributions don't ship with a properly setup
        /etc/modules.conf (or /etc/conf.modules), so the driver isn't
        loaded properly when you need it to be.  With a recent
        modutils, the proper magical lines from modules.conf seem to
        be:

<Screen>
  alias /dev/printers lp             # only for devfs?
  alias /dev/lp*      lp             # only for devfs?
  alias parport_lowlevel parport_pc  # missing in Red Hat 6.0-6.1
</Screen>

       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>The BIOS</Term>
      <ListItem>
       <Para>Many PC BIOSes will make the parallel port into a
        Plug-and-Play device.  This just adds needless complexity to a
        perfectly simple device that is nearly always present; turn
        off the PnP setting for your parallel prot ("LPT1" in many
        BIOSes) if your parallel port isn't detected by the Linux
        driver.  The correct setting is often called "legacy", "ISA",
        or "0x378", but probably not "disabled".
       </Para>
      </ListItem
     </VarListEntry>
    </VariableList>
   </Para>

   <Para>
    You can also read the  <ULink
    URL="http://people.redhat.com/twaugh/parport/html/parportguide.html"
    >parport documentation</ULink > in your kernel sources, or
    look at the <ULink
    URL="http://people.redhat.com/twaugh/parport/" >parport web
    site</ULink >.
   </Para>

  </Sect2>

  <Sect2 id="serial-devices">
   <indexterm>
    <primary>ports</primary>
    <secondary>serial</secondary>
   </indexterm>
   <Title>Serial devices</Title>

   <Para>
    Serial devices are usually called something like
    <Emphasis>/dev/ttyS1</Emphasis> under Linux.  The utility <Literal
    remap="tt"><ULink
    URL="http://www.linuxprinting.org/man/stty.1.html"
    >stty</ULink ></Literal> will allow you to interactively view or
    set the settings for a serial port; <Literal remap="tt"><ULink
    URL="http://www.linuxprinting.org/man/setserial.8.html"
    >setserial</ULink ></Literal> will allow you to control a few
    extended attributes and configure IRQs and I/O addresses for
    non-standard ports.  Further discussion of serial ports under
    Linux may be found in the <ULink
    URL="http://metalab.unc.edu/mdw/HOWTO/Serial-HOWTO.html"
    >Serial-HOWTO</ULink >.
   </Para>

   <Para>
    When using a slow serial printer with flow control, you may find
    that some of your print jobs get truncated.  This may be due to
    the serial port, whose default behavior is to purge any
    untransmitted characters from its buffer 30 seconds after the port
    device is closed.  The buffer can hold up to 4096 characters, and
    if your printer uses flow control and is slow enough that it can't
    accept all the data from the buffer within 30 seconds after
    printing software has closed the serial port, the tail end of the
    buffer's contents will be lost.  If the command <Literal
    remap="tt">cat file &gt; /dev/ttyS2</Literal> produces complete
    printouts for short files but truncated ones for longer files, you
    may have this condition.
   </Para>

   <Para>
    The 30 second interval can be adjusted through the
    "closing&lowbar;wait" commandline option of setserial (version
    2.12 and later).  A machine's serial ports are usually initialized
    by a call to setserial in the rc.serial boot file.  The call for
    the printing serial port can be modified to set the
    closing&lowbar;wait at the same time as it sets that port's other
    parameters.
   </Para>
  </Sect2>

  <Sect2 id="usb-devices">
   <indexterm>
    <primary>ports</primary>
    <secondary>USB</secondary>
   </indexterm>
   <Title>USB Devices</Title>

   <Para>
    I don't have any USB devices to play with, so all I can offer are
    pointers.  Once set up, you end up with the device file
    <filename>/dev/usb/lp0</filename>, much as you do with parallel
    ports, which will work fine in printcap or as a PDQ local-port
    device.
   </Para>

   <Para>
    USB is documented at the <ulink
    url="http://www.linux-usb.org/">Linux USB Website</ulink>.
   </Para>

  </Sect2>

 </Sect1>

 <Sect1 id="printers">
  <Title>Supported Printers</Title>

  <Para>
   The Linux kernel will let you speak with any printer that you can
   plug into a serial, parallel, or usb port, plus any printer on the
   network, but this alone is insufficient; you must also be able to
   generate data that the printer will understand.  Primary among the
   incompatible printers are those referred to as "Windows" or "GDI"
   printers.  They are called this because all or part of the printer
   control language and the design details of the printing mechanism
   are not documented.  Typically the vendor will provide a Windows
   driver and happily sell only to Windows users; this is why they are
   called Winprinters.  In some cases the vendor also provides drivers
   for NT, OS/2, or other operating systems.
  </Para>

  <indexterm><primary>winprinters</primary></indexterm>

  <Para>
   Many of these printers <Emphasis>do not work</Emphasis> with Linux.
   A few of them do, and some of them only work a little bit (usually
   because someone has reverse engineered the details needed to write
   a driver).  See the printer support list below for details on
   specific printers.
  </Para>

  <Para>
   A few printers are in-between.  Some of NEC's models, for example,
   implement a simple form of the standard printer language PCL that
   allows PCL-speaking software to print at up to 300dpi, but only NEC
   knows how to get the full 600dpi out of these printers.
  </Para>

  <Para>
   Note that if you already have one of these Winprinters, there are
   roundabout ways to get Linux to print to one, but they're rather
   awkward.  See <xref linkend="winprinters"> in this
   document for more discussion of Windows-only printers.
  </Para>

  <Sect2 id="supported-printers-postscript">
   <indexterm><primary>Postscript</primary></indexterm>
   <indexterm><primary>Postscript</primary>
              <secondary>printers</secondary></indexterm>
   <Title>Postscript</Title>

   <Para>
    As for what printers <Emphasis>do</Emphasis> work with Linux, the
    best choice is to buy a printer with native PostScript support
    <emphasis>in firmware</emphasis>.  Nearly all Unix software that
    produces printable output produces it in PostScript, so obviously
    it'd be nice to get a printer that supports PostScript directly.
    Unfortunately, PostScript support is scarce outside the laser
    printer domain, and is sometimes a costly add-on.
   </Para>

   <Para>
    Unix software, and the publishing industry in general, have
    standardized upon Postscript as the printer control language of
    choice.  This happened for several reasons:
    <VariableList>

     <VarListEntry>
      <Term>Timing</Term>
      <ListItem>
       <Para>Postscript arrived as part of the Apple Laserwriter, a
        perfect companion to the Macintosh, the system largely
        responsible for the desktop publishing revolution of the 80s.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry id="pdf-description">
      <indexterm>
       <primary>PDF</primary>
      </indexterm>
      <Term>It's device-independent</Term>
      <ListItem>
       <Para>Postscript programs can be run to generate output on a
        pixel screen, a vector screen, a fax machine, or almost any
        sort of printer mechanism, without the original program
        needing to be changed.  Postscript output will look the same
        on any Postscript device, at least within the limits of the
        device's capabilities.  Before the creation of PDF, people
        exchanged complex documents online as Postscript files.  The
        only reason this standard didn't "stick" was because Windows
        machines didn't usually include a Postscript previewer, so
        Adobe specified hyperlinks and compression for Postscript,
        called the result PDF, distributed previewers for it, and
        invented a market for their "distiller" tools (the
        functionality of which is also provided by ghostscript's
        ps2pdf and pdf2ps programs).
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>It's a real programming language</Term>
      <ListItem>
       <Para>Postscript is a complete programming language; you can
        write software to do most anything in it.  This is mostly
        useful for defining subroutines at the start of your program
        to reproduce complex things over and over throughout your
        document, like a logo or a big "DRAFT" in the background.  But
        there's no reason you couldn't compute &pgr; in a Postscript
        program.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>It's open</Term>
      <ListItem>
       <Para>Postscript is fully specified in a publically available
        series of books (which you can find at any good bookstore).
        Although Adobe invented it and provides the dominant
        commercial implementation, other vendors like Aladdin produce
        independently coded implementations as well.
       </Para>
      </ListItem>
     </VarListEntry>
    </VariableList>
   </Para>
  </Sect2>

  <Sect2 id="non-ps-printers">
   <Title>Non-Postscript</Title>

   <Para>
    Failing the (larger) budget necessary to buy a Postscript printer,
    you can use any printer supported by Ghostscript, the free
    Postscript interpreter used in lieu of actual printer Postscript
    support.  Note that most Linux distributions can only ship a
    somewhat outdated version of Ghostscript due to the license.
    Fortunately, there is usually a prepackaged up to date Ghostscript
    made available in each distribution's contrib area.  
   </Para>

   <Para>
    Adobe now has a new printer language called "PrintGear".  I think
    it's a greatly simplified binary format language with some
    Postscript heritage but no Postscript compatibility.  And I
    haven't heard of Ghostscript supporting it.  But some PrintGear
    printers seem to support another language like PCL, and these
    printers will work with Linux (iff the PCL is implemented in the
    printer and not in a Windows driver).
   </Para>

   <Para>
    Similarly, Adobe offers a host-based Postscript implementation
    called <ProductName>PressReady</ProductName>.  This works much
    like Ghostscript does to provide Postscript support for a
    non-Postscript printer, but has the disadvantage that it runs only
    on Windows.
  </Sect2>

  <Sect2 id="what-printers-work">
   <indexterm><primary>printers</primary>
              <secondary>buying</secondary></indexterm>
   <Title>What printers work?</Title>
   <Para>
    If you want to buy a printer, you can look in several places to
    see if it will work.  The cooperatively maintained Printing HOWTO
    printer <ULink URL="http://www.linuxprinting.org/database.html"
    >database</ULink > aims to be a comprehensive listing of the state
    of Linux printer support.  A summary of it is below; be sure to
    check online for more details and information on what driver(s) to
    use.
   </Para>

   <Para>
    Ghostscript's <ULink
    URL="http://www.cs.wisc.edu/~ghost/printer.html" >printer
    compatibility page</ULink > has a list of some working printers,
    as well as links to other pages.
   </Para>

   <Para>
    <ULink URL="http://www.deja.com/usenet/">Dejanews</ULink >
    contains hundreds of "it works" and "it doesn't work"
    testimonials.  Try all three, and when you're done, check that
    your printer is present and correct in the <ULink
    URL="http://www.linuxprinting.org/database.html" >database</ULink
    >, so that it will be listed properly in this document in the
    future.
   </Para>

   <Para>
    If you're lazy, I keep a short list of <ulink
    url="http://www.linuxprinting.org/suggested.html">suggested
    printers</ulink> on my website.  These center around color inkjets and
    low-cost laser devices; fully compatible mid-range and high-end
    devices are much easier to find.  You can even help support this
    document and the website by buying from buy.com or outpost.com
    through me.
   </Para>

   <Sect3 id="printer-compat-list">
    <indexterm>
     <primary>drivers</primary>
     <secondary>printer</secondary>
    </indexterm>
    <Title>Printer compatibility list</Title>

    <Para>
     This section is a summary of the <ulink
     url="http://www.linuxprinting.org/database.html" >online
     database</ulink>.  The online version includes device
     specifications, notes, driver information, user-maintained
     documentation, manufacturer web pages, and interface scripts for
     using drivers with several print spooling systems (including LPR,
     LPRng, PDQ, and CUPS).  The online version of this list is also
     interactive; people can and do add printers all the time, so be
     sure to check it as well.  Finally, if your printer isn't listed,
     add it!
    </Para>

    <Para>
     Note that this listing is not gospel; people sometimes add
     incorrect information, which I eventually weed out.  Entries I
     have not sanity-checked are marked with an asterisk (*).  Verify
     from Dejanews that a printer works for someone before buying it
     based on this list.  If you can find no information in Dejanews,
     mail me and I'll put you in contact with the person who added the
     printer.
    </Para>

    <Para>
     Printers here are categorized into three types:
     <VariableList>
      <VarListEntry>
       <Term>Perfectly</Term>

       <ListItem>
        <Para>Perfect printers work perfectly - you can print to the full
         ability of the printer, including color, full resolution, etc.
         In a few cases printers with undocumented "resolution
         enhancement" modes that don't work are listed as perfect;
         generally the difference in print quality is small enough that
         it isn't worth worrying about.
        </Para>
       </ListItem>
      </VarListEntry>

      <VarListEntry>
       <Term>Mostly</Term>

       <ListItem>
        <Para>You can print fine, but there may be minor limitations of one
         sort or another in either printing or other features.
        </Para>
       </ListItem>
      </VarListEntry>

      <VarListEntry>
       <Term>Partially</Term>

       <ListItem>
        <Para>You can print, but maybe not in color, or only at a poor
         resolution.  See the online listing for information on the
         limitation.
        </Para>
       </ListItem>
      </VarListEntry>

      <VarListEntry>
       <Term>Paperweight</Term>

       <ListItem>
        <Para>You can't print a darned thing; typically this will be due to
         lack of a driver and/or documentation on how to write one.
         Paperweights occasionally get "promoted", either when someone
         discovers that an existing driver works, or when someone
         creates a new driver, but you shouldn't count on this
         happening.
        </Para>
       </ListItem>
      </VarListEntry>
     </VariableList>

     In all cases, since this information is provided by dozens of
     people, none of it is guaranteed to be correct; entries with an
     asterisk (*) are particularly suspect.  The facts, however, should
     be easy to corroborate from the driver web pages and manufacturer
     web sites.
    </Para>

    <Para>
     And without further ado, here is the printer compatibility list:
&printerlist;
     * This entry has not been sanity-checked by me.
    </Para>
   </Sect3>
  </Sect2>

  <Sect2 id="shopping">
   <indexterm><primary>printers</primary>
              <secondary>buying</secondary></indexterm>
   <Title>How to buy a printer</Title>

   <Para>
    It's a bit difficult to select a printer these days; there are many
    models to choose from.  Here are some shopping tips:
    <VariableList>
     <VarListEntry>
      <Term>Cost</Term>
      <ListItem>
       <Para>You get what you pay for.  Most printers under $200-300
        will print reasonably well, but printing costs a lot per page.
        For some printers, it only takes one or two cartridges to add
        up to the cost of a new printer!  Similarly, the cheapest
        printers won't last very long.  The least expensive printers,
        for example, have a MTBF of about three
        <emphasis>months</emphasis>; obviously these are poorly suited
        for heavy use.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>Inkjets</Term>
      <ListItem>
       <Para>Inkjet printheads will clog irreparably over time, so the
        ability to replace the head somehow is a feature.  Inkjet
        printheads are expensive, with integrated head/ink cartridges
        costing ten times (!) what ink-only cartridges go for, so the
        ability to replace the head only when needed is a feature.
        Epson Styluses tend to have fixed heads, and HP DeskJets tend
        to have heads integrated into the cartridges.  Canons have
        three-part cartridges with independently replaceable ink
        tanks; I like this design.  OTOH, the HP cartridges aren't
        enormously more expensive, and HP makes a better overall line;
        Canon is often the third choice from the print quality
        standpoint; and Epson Styluses are the best supported under
        Linux at the moment.  You just can't win.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>Lasers</Term>
      <ListItem>
       <Para>Laser printers consume a drum and toner, plus a little
        toner wiping bar.  The cheapest designs include toner and drum
        together in a big cartridge; these designs cost the most to
        run.  The best designs for large volume take plain toner
        powder or at least separate toner cartridges and drums.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry id="photo-printers-shopping">
      <indexterm>
       <primary>photograph</primary>
       <secondary>printers</secondary>
      </indexterm>
      <indexterm>
       <primary>printers</primary>
       <secondary>photograph</secondary>
      </indexterm>
      <Term>Photography</Term>
      <ListItem>
       <Para>The best color photograph output is from continuous tone
        printers which use a silver halide plus lasers approach to
        produce&mdash;surprise!&mdash;actual photographs.  Since these
        printers cost tens of thousands to buy, <ulink
        url="http://www.ofoto.com">Ofoto.com</ulink> offers
        inexpensive print-by-print jobs.  The results are stunning;
        even the best inkjets don't compare.
       </Para>

       <Para>
        The best affordable photo prints come from the dye-sublimation
        devices like some members of the Alps series (thermal transfer
        of dry ink or dye sublimation).  Unfortunately they have poor
        Linux support (the one report I have speaks of banding and
        grainy pictures), and even then it's unclear if the dye-sub
        option is supported.  
       </Para>

       <Para>
        The more common photo-specialized inkjets usually feature 6
        color CMYKcm printing or even a 7 color CMYKcmy process.  All
        photo-specialized printers are expensive to run; either you
        always run out of blue and have to replace the whole
        cartridge, or the individual color refills for your high-end
        photo printer cost an arm and a leg.  Special papers cost a
        bundle, too; you can expect top-quality photo inkjet output to
        run over a US dollar per page.  See also the section on
        printing photographs later in this document, and the sections
        on color tuning (such as it is) in Ghostscript.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>Speed</Term>
      <ListItem>
       <Para>Speed is proportional to processing power, bandwidth, and
        generally printer cost.  The fastest printers will be networked
        Postscript printers with powerful internal processors.
        Consumer-grade printers will depend partly on Ghostscript's
        rendering speed, which you can affect by having a reasonably
        well-powered machine; full pages of color, in particular, can
        consume large amounts of host memory.  As long as you actually
        <emphasis>have</emphasis> that memory, things should work out
        fine. 
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>Forms</Term>
      <ListItem>
       <Para>If you want to print on multicopy forms, then you need an
        impact printer; many companies still make dot matrix printers,
        most of which emulate traditional Epson models and thus work
        fine.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>Labels</Term>
      <ListItem>
       <Para>There are two supported lines of label printer; look for
        the Dymo-Costar and the Seiko SLP models.  Other models may or
        may not work.  Avery also makes various sizes of stick-on
        labels in 8.5x11 format that you can run through a regular
        printer.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>Plotting</Term>
      <ListItem>
       <Para>Big drafting formats are usually supported these days by
        monster inkjets; HP is a popular choice.  Mid-sized (11x17)
        inkjets are also commonly used for smaller prints.  Much
        plotting of this sort is done with the languages RTL, HP-GL,
        and HP-GL/2, all of which are simple HP proprietary vector
        languages usually generated directly by application software.
       </Para>
      </ListItem>
     </VarListEntry>

    </VariableList>
   </Para>

   <Sect3 id="my-printers">
    <Title>What do I have?</Title>

    <Para>
     I own an HP Deskjet 500, a Lexmark Optra 40, and a Canon
     BJC-4100.  All work perfectly: the HP and Canon are older models,
     well supported by Ghostscript; and the Optra is a more modern
     color inkjet with full Postscript and PCL 5 support (!).
    </Para>

    <Para>
     I also own a Hawking Technology 10/100 Ethernet print server
     (model 7117, actually made by Zero One Technologies in Taiwan);
     this makes it possible to put the printer anywhere with power and
     a network jack, instead of just near a computer.  It's a little
     dongle that attaches to the printer's parallel port and has an
     Ethernet jack on the other side.  The only flaw with this is that
     it doesn't allow bidirectional communication, so I can't arrange
     to be sent email when the ink is low.
    </Para>
   </Sect3>
  </Sect2>
 </Sect1>

 <Sect1 id="spoolers">
  <Title>Spooling software</Title>

  <Para>
   Until recently, the choice for Linux users was simple - everyone
   ran the same old lpd lifted mostly verbatim out of BSD's Net-2
   code.  Even today, most vendors ship this software.  But this is
   beginning to change.  SVR4-like systems including Sun's Solaris
   come with a completely different print spooling package, centered
   around lpsched.
  </Para>

  <Para>
   Today, there are a number of good systems to chose from.  I
   describe them all below; read the descriptions and make your own
   choice.  PDQ is the simplest modern system with a GUI; it is
   suitable for both basic home users and (in a hybrid pdq/lprng
   setup) people in many larger environments.  For business
   environments with mainly networked Postscript printers, a front-end
   program like GPR with LPRng is a good alternative; it handles
   PPD options directly and has a slightly nicer interface.  In other
   cases CUPS is a good option; it too has excellent Postscript
   printer support, and offers IPP support, a web interface, and a
   number of other features.
  </Para>

   <!--FIXME: indexterm-->

  <Sect2 id="lpd-which-spooler">
    <indexterm><primary>LPD</primary>
               <secondary>VA Linux's version</secondary></indexterm>
    <indexterm><primary>VA Linux</primary>
               <secondary>LPD</secondary></indexterm>
   <Title>LPD</Title>

   <Para>
    LPD, the original BSD Unix Line Printer Daemon, has been the
    standard on Unix for years.  It is available for every style of
    Unix, and offers a rather minimal feature set derived from the
    needs of timesharing-era computing.  Despite this somewhat
    peculiar history, it is still useful today as a basic print
    spooler.  To be really useful with modern printer, a good deal of
    extra work is needed in the form of companion filter scripts and
    front-end programs.  But these exist, and it does all work.
   </Para>

   <Para>
    LPD is also the name given to the network printing protocol by
    <ulink url="http://www.ietf.org/rfc/rfc1179.txt">RFC
    1179</ulink>.  This network protocol is spoken not only by
    the LPD daemon itself, but by essentially every networked print
    server, networked printer, and every other print spooler out
    there; LPD is the least common denominator of standards-based
    network printing.
   </Para>

   <Para>
    LPRng (see <xref linkend="lprng-which-spooler">) is a far better
    implementation of the basic LPD design than the regular one; if
    you must use LPD, consider using LPRng instead.  There is far less
    voodoo involved in making it do what you want, and what voodoo
    there is is well documented.
   </Para>

   <Para>
    There are a large number of LPD sources floating around in the
    world.  Arguably, some strain of BSD Unix is probably the official
    owner, but everyone implements changes willy-nilly, and they all
    cross-pollinate in unknown ways, such that it is difficult to say
    with certainty exactly which LPD you might have.  Of the readily
    available LPDs, VA Linux offers one with a few minor modifications
    that make the user interface much more flexible.  The <ulink
    url="http://sourceforge.net/project/?group_id=3800">SourceForge
    LPD</ulink> supports command-line option specification with a
    <option>-o</option> flag; options are then passed through to
    filters.  This is similar to the features offered by a number of
    traditional Unix vendors, and similar to (although incompatible
    with) LPRng's <option>-z</option> option mechanism.
   </Para>

   <SimpleSect id="lpd-front-ends">
    <Title>LPD front-ends</Title>
 
    <Para>
     If you go with LPD, the best way to use it is via a front-end.
     There are several to chose from; GPR (see <xref
     linkend="how-with-gui-tools">) and XPDQ (see <xref
     linkend="pdq-which-spooler">) are perhaps the two best.  Others
     exist; tell me about them.
    </Para>

   </SimpleSect>

  </Sect2>


  <Sect2 id="pdq-which-spooler">
   <indexterm><primary>PDQ</primary></indexterm>
   <indexterm><primary>spoolers</primary><secondary>PDQ</secondary></indexterm>
   <indexterm><primary>xpdq</primary></indexterm>
   <Title>PDQ</Title>

   <Para>
    <ULink URL="http://feynman.tam.uiuc.edu/pdq/" >PDQ</ULink > is a
    non-daemon-centric print system which has a built-in, and
    sensible, driver configuration syntax.  This includes the ability
    to declare printing options, and a GUI or command line tool for
    users to specify these options with; users get a nice dialog box
    in which to specify resolution, duplexing, paper type, etc (see
    <xref linkend="snapshot-xpdq-options">).
   </Para>

   <figure>
    <title>XPDQ Main Window</title>
    <graphic fileref="snapshot-xpdq-main" scale="60"></graphic>
   </figure>

   <Para>
    Running all of the filters as the user has a number of advantages:
    the security problems possible from Postscript are mostly gone,
    multi-file LaTeX jobs can be printed effectively as dvi files, and
    so forth.
   </Para>

   <Para>
    This is what I now use; I've written driver spec files for my
    printers, and there are several included with the distribution, so
    there are plenty of examples to base yours on.  I've also written
    a few tools to automate driver spec generation to help the rest of
    you.
   </Para>

   <Para>
    PDQ is not without flaws: most notably it processes the entire job
    before sending it to the printer.  This means that, for large
    jobs, PDQ may simply be impractical&mdash;you can end up with
    hundreds of megs being copied back and forth on your disk.  Even
    worse, for slow drivers like the better quality inkjet drivers,
    the job will not start printing until Ghostscript and the driver
    have finished processing.  This may be many minutes after submission.
   </Para>

   <Para>
    If you have many users, many printers, or anything else complex
    going on, I recommend using PDQ as a front-end to LPD-protocol
    based network printing (you can print via the lpd protocol to the
    local machine).  In most such situations, rather than using the
    traditional BSD lpd as the back-end, I recommend LPRng:
   </Para>

   <figure id="snapshot-xpdq-options">
    <title>XPDQ Driver Options Window</title>
    <graphic fileref="snapshot-xpdq-options" scale="60"></graphic>
   </figure>

  </Sect2>

  <Sect2 id="lprng-which-spooler">
   <indexterm><primary>LPRng</primary></indexterm>
   <indexterm><primary>spoolers</primary>
              <secondary>LPRng</secondary></indexterm>
   <Title>LPRng</Title>

   <Para>
    Some Linux vendors (including Caldera) provide LPRng, a far less
    ancient LPD print spooling implementation.  LPRng is far easier to
    administer for large installations (read: more than one printer,
    any serial printers, or any peculiar non-lpd network printers) and
    has a less frightfully haphazard codebase than does stock lpd.  It
    can even honestly claim to be secure - there are no SUID binaries,
    and it supports authentication via PGP or Kerberos.
   </Para>

   <Para>
    LPRng also includes some example setups for common network
    printers - HP LaserJets, mainly, that include some accounting
    abilities.  If you'd like more information on LPRng, check out the
    <ULink URL="http://www.astart.com/lprng/LPRng.html" >LPRng Web
    Page</ULink>.  LPRng uses more or less the same basic filter model
    as does BSD lpd, so the <ulink
    url="http://www.linuxprinting.org/lpd-doc.html">LPD
    support</ulink> offered by my website applies to LPRng as well.
    This can help you effectively use free software drivers for many
    printers.
   </Para>

   <Para>
    LPRng is distributed under either the GPL or an Artistic license.
   </Para>
  </Sect2>

  <Sect2 id="ppr-which-spooler">
   <indexterm><primary>PPR</primary></indexterm>
   <indexterm><primary>spoolers</primary><secondary>PPR</secondary></indexterm>
   <Title>PPR</Title>

   <Para>
    <ULink URL="http://ppr.trincoll.edu/" >PPR</ULink > is a
    Postscript-centric spooler which includes a rudimentary Postscript
    parsing ability from which it derives several nice features.  It
    includes good accounting capabilities, good support for Appletalk,
    SMB, and LPD clients, and much better error handling than lpd.
    PPR, like every other spooler here, can call Ghostscript to handle
    non-Postscript printers.
   </Para>

   <Para>
    I only recently found out about PPR; I don't know of anyone who
    has tried it.  It was written by, and is in use at, Trinity
    College.  The license is BSD-style; free for all use but credit is
    due.
   </Para>

   <Para>
    According to the documentation, it's somewhat experimental.
    Malformed Postscript jobs won't print; instead they bounce, and
    it's up to the user to fix the Postscript.  This may make it
    unsuitable for some environments, although most users generate
    Postscript with a small handful of well-characterized Postscript
    generators, so it probably wouldn't be that big an issue.
   </Para>
  </Sect2>

  <Sect2 id="cups-which-spooler">
   <indexterm><primary>CUPS</primary></indexterm>
   <indexterm><primary>CUPS</primary>
              <secondary>XPP</secondary><see>XPP</see></indexterm>
   <indexterm><primary>spoolers</primary>
              <secondary>CUPS</secondary></indexterm>
   <indexterm><primary>XPP</primary></indexterm>
   <Title>CUPS</Title>

   <Para>
    <indexterm><primary>IPP</primary></indexterm>
    <indexterm><primary>Internet Printing Protocol</primary>
               <see>IPP</see></indexterm>
    One interesting newcomer on the scene is <ulink
    url="http://www.cups.org/">CUPS</ulink>, an implementation of the
    Internet Printing Protocol (IPP), an HTTP-like RFC standard
    replacement protocol for the venerable (and klunky) LPD protocol.
    The implementation of CUPS has been driven by Michael Sweet of
    Easy Software Products; CUPS is distributed under the GPL.
   </Para>

   <Para id="cups-home-environ">
   <indexterm><primary>environment</primary>
              <secondary>home</secondary></indexterm>
    I've finally done some work with CUPS, and it does 
    work as advertised.  There are a number of very good features in
    it, including sensible option handling; web, gui, and command-line
    interfaces; and a mime-based filtering system with strong support
    for Postscript.  Since it is so new, however, it does have a
    number of quirks, and it is hard to recommend for large or secure
    installations at this time (as of version 1.1).  It is a fine
    solution, however, for smaller installations or especially larger
    installatons with trusted users.
   </Para>

   <Para>
    Like other systems, CUPS can be used with most existing drivers.
    Unfortunately, it's a bit tricky to configure an arbitrary driver
    for use with CUPS&mdash;at least if you want all the options to
    work&mdash;so it's best to find a preexisting PPD file and filter
    script to make your driver go.  There are at least four sets of
    drivers which you can use with CUPS:
    <VariableList>
     <VarListEntry>
      <Term><ulink 
                url="http://www.linuxprinting.org/cups-doc.html"
                >CUPS-O-Matic</ulink></Term>
      <ListItem>
       <Para>My web-based CUPS-O-Matic system can generate a suitable
	PPD for use with any printer driver that has full details
	entered in the Linux Printing Database.  The PPD gets used
	together with a backend script named
	<command>cupsomatic</command>.  CUPS-O-Matic uses free
	software drivers.  At the moment I am concentrating on
	correctness rather than completeness, so rather few drivers
	are in fact supported.  This will change over time.
       </Para>
      </ListItem>
     </Varlistentry>

     <Varlistentry>
      <Term><ulink 
                url="http://cups.sourceforge.net/">CUPS Drivers
                 and KUPS</ulink></Term>
      <ListItem>
       <Para>The CUPS Drivers project is accumulating PPD files
	useable with either Postscript printers or the backend filter
	<command>ps2gs2raw</command>.  These PPD files use free
	software drivers.  KUPS is a companion setup program.
       </Para>
      </ListItem>
     </Varlistentry>

     <Varlistentry>
      <Term>Postscript PPDs</Term>
      <ListItem>
       <Para>CUPS can use vendor-supplied PPD files for Postscript
	printers directly.  Often these come with the Windows drivers
	for a printer, or can be found on the printer vendor's
	website.  <ulink
	url="http://www.adobe.com/products/printerdrivers/winppd.html"
	>Adobe</ulink> also distributes PPD files for many Postscript
	printers.
       </Para>
      </ListItem>
     </Varlistentry>

     <Varlistentry>
      <Term>ESP Print Pro</Term>
      <ListItem>
       <Para><ulink url="http://www.easysw.com/">Easy Software Products,
	Inc.</ulink> sells CUPS bundled with a collection of
	proprietary drivers.  Although they are not free software,
	they do drive many common printers.  The bundle is somewhat
	expensive measured against the price of a single supported
	printer, but it certainly has a place.  These drivers are
	reputedly not terribly good, but they are somewhat
	comprehensive, and even mediocre quality is preferable to a
	paperweight. 
       </Para>
      </ListItem>
     </Varlistentry>
    </VariableList>
   </Para>

   <Para>
    The third-party program <command><ulink
    url="http://www.phy.uni-bayreuth.de/till/xpp/">XPP</ulink
    ></command > (see <xref linkend="snapshot-xpp-main">) offers a
    very nice graphical interface to the user functionality of CUPS,
    including an marvelous interface to print-time options (shown in
    <xref linkend="snapshot-xpp-options">).  For information on using
    XPP, see <xref linkend="xpp-sect">.
   </Para>

  </Sect2>
 </Sect1>

 <Sect1 id="background">
  <indexterm><primary>spoolers</primary></indexterm>
  <Title>How it all works</Title>

  <Para>
   In order to get printing working well, you need to understand how your 
   spooling software works.  All systems work in essentially the same
   way, although the exact order might vary a bit, and some systems
   skip a step or two:

   <Figure id="spool-illustration">
    <title>Spooling Illustration</title>
    <graphic fileref="spool-illustration" scale="80"></graphic>
   </Figure>

   <OrderedList>
    <ListItem>
     <SimPara>The user submits a job along with his selection of options.  The
      job data is usually, but not always, Postscript.
     </SimPara>
    </ListItem>

    <ListItem>
     <SimPara>The spooling system copies the job and the options over the
      network in the general direction of the printer.
     </SimPara>
    </ListItem>

    <ListItem>
     <SimPara>The spooling system waits for the printer to be available.
     </SimPara>
    </ListItem>

    <indexterm><primary>filtering</primary></indexterm>
    <ListItem id="background-filtering">
     <SimPara>The spooling system applies the user's selected options to the
      job, and translates the job data into the printer's native
      language, which is usually not Postscript.  This step is called
      <emphasis>filtering</emphasis>; most of the work in setting
      things up lies in getting the proper filtering to happen.
     </SimPara>
    </ListItem>

    <ListItem>
     <SimPara>The job is done.  The spooling system will usually do assorted
      cleanup things at this point.  If there was an error along the
      way, the spooler will usually notify the user somehow (for
      example, by email).
     </SimPara>
    </ListItem>
   </OrderedList>
  </Para>


  <Sect2 id="pdq-overview">
   <indexterm><primary>PDQ</primary>
              <secondary>overview</secondary></indexterm>
   <Title>PDQ</Title>

   <Para>
    Pdq stands for "Print, Don't Queue", and the way it works reflects
    this design.  The following sequence of events happens when you
    use PDQ to print:
    <ItemizedList>
     <ListItem>
      <Para>You run pdq or xpdq, specifying a file.
      </Para>
     </ListItem>

     <ListItem>
      <Para>You specify a printer.
      </Para>
     </ListItem>

     <ListItem>
      <Para>You specify the settings for the various options and arguments
       defined in the printer's PDQ driver file (duplex, copies, print
       quality, and so forth).
      </Para>
     </ListItem>

     <ListItem>
      <Para>PDQ analyzes the contents of what you printed, and follows the
       instructions in the PDQ driver file which tell it how to
       process your data for this printer with your options.
      </Para>
     </ListItem>

     <ListItem>
      <Para>PDQ sends the processed data to the printer according to the
       interface defined for that printer (straight to
       <filename>/dev/lp0</filename>, or to an LPD daemon on the
       network, over the network to an Apple or Microsoft system, or
       even to a fax machine).
      </Para>
     </ListItem>

     <ListItem>
      <Para>If PDQ can't send the data to the printer right away, it spawns
       a background process to wait and try again until it succeeds or
       hits a time limit.
      </Para>
     </ListItem>
    </ItemizedList>
    At all times during this process, and afterwards, the state of each
    print job can be seen and inspected using xpdq.  Jobs that failed are
    shown in red and can be resent.
   </Para>
  </Sect2>

  <Sect2 id="lpd-overview">
   <Title>LPD</Title>
   <indexterm><primary>LPD</primary></indexterm>

   <Para>
    Lpd stands for Line Printer Daemon, and refers in different
    contexts to both the daemon and the whole collection of programs
    which run print spooling.  These are:
    <VariableList>
     <VarListEntry>
      <Term>
       <command><ULink
       URL="http://www.linuxprinting.org/man/lpd.8.html" >lpd</ULink></command>
      </Term>
      <ListItem>
       <Para>The spooling daemon.  One of these runs to control everything
        on a machine, AND one is run per printer while the printer is
        printing.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry id="lpr-in-lpd-overview">
      <indexterm><primary>lpr</primary></indexterm>
      <indexterm><primary>LPD</primary><secondary>lpr</secondary></indexterm>
      <Term><command><ULink 
            URL="http://www.linuxprinting.org/man/lpr.1.html">lpr</ULink></command>
      </Term>
      <ListItem>
       <Para>The user spooling command.  Lpr contacts lpd
        and injects a new print job into the spool.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry id="lpq-in-lpd">
      <indexterm><primary>lpq</primary></indexterm>
      <indexterm><primary>LPD</primary><secondary>lpq</secondary></indexterm>
      <Term>
       <command><ULink URL="http://www.linuxprinting.org/man/lpq.1.html"
       >lpq</ULink></command>
      </Term>
      <ListItem>
       <Para>Lists the jobs in a print queue.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry id="lpc-in-lpd">
      <indexterm><primary>lpc</primary></indexterm>
      <indexterm><primary>LPD</primary><secondary>lpc</secondary></indexterm>
      <Term><command><ULink
            URL="http://www.linuxprinting.org/man/lpc.8.html"
            >lpc</ULink></command>
      </Term>
      <ListItem>
       <Para>The Lpd system control command.  With lpc you can stop, start,
        reorder, etc, the print queues.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry id="lprm-in-lpd">
      <indexterm><primary>lprm</primary></indexterm>
      <indexterm><primary>LPD</primary><secondary>lprm</secondary></indexterm>
      <Term><command><ULink URL="http://www.linuxprinting.org/man/lprm.1.html"
            >lprm</ULink></command>
      </Term>
      <ListItem>
       <Para><command>lprm</command> removes a job from the print spool.
       </Para>
      </ListItem>
     </VarListEntry>
    </VariableList>
   </Para>

   <Para>
    So how does it fit together?  The following things happen:

    <OrderedList>
     <ListItem>
      <SimPara>At boot time, <command>lpd</command> is run.  It waits for
       connections and manages printer queues.
      <SimPara>
     </ListItem>

     <ListItem>
      <SimPara>A user submits a job with the <command>lpr</command> command
       or, alternatively, with an lpr front-end like GPR, PDQ, etc.
       <command>Lpr</command> contacts <command>lpd</command> over the
       network and submits both the user's data file (containing the
       print data) and a control file (containing user options).
      <SimPara>
     </ListItem>

     <ListItem>
      <SimPara>When the printer becomes available, the main
       <command>lpd</command> spawns a child <command>lpd</command> to
       handle the print job.
      </SimPara>
     </ListItem>

     <ListItem>
      <SimPara>The child <command>lpd</command> executes the appropriate
       filter(s) (as specified in the <option>if</option> attribute in
       <filename>/etc/printcap</filename>) for this job and sends the
       resulting data on to the printer.
      </SimPara>
     </ListItem>

    </OrderedList>
   </Para>

   <Para>
    The lp system was originally designed when most printers were line
    printers - that is, people mostly printed plain ascii.  By placing
    all sorts of magic in the <option>if</option> filter, modern
    printing needs can be met with <command>lpd</command> (well, more
    or less; many other systems do a better job).
   </Para>

   <Para>
    There are many programs useful for writing LPD filters.  Among
    them are:
    <VariableList>
     <VarListEntry>
      <Term><command>gs</command></Term>
      <ListItem>
       <Para>Ghostscript is a host-based Postscript interpreter (aka a
        Raster Image Processor or RIP).  It accepts Postscript and
        produces output in various printer languages or a number of
        graphics formats.  Ghostscript is covered in <xref
        linkend="ghostscript">.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term><command>ppdfilt</command></Term>
      <ListItem>
       <Para><command><ulink
        url="http://sourceforge.net/project/?group_id=1658"
        >ppdfilt</ulink ></command> is a standalone version of a CUPS
        component.  It filters Postscript, executing a few basic
        transformations on it (n-up printing, multiple copies, etc)
        and adding in user option statements according to a Postscript
        Printer Definition (PPD) file usually included with Postscript
        printers.
       </Para>
       <Para>
        <command>ppdfilt</command> is best used together with an
        option-accepting LPD system (like the VA Linux LPD, or LPRng)
        and a filter script which parses user-provided options into
        the equivalent <command>ppdfilt</command> command.  VA Linux
        and HP provide a modified rhs-printfilters package which does
        exactly this; it produces nice results if you have a
        Postscript printer.  See <xref
        linkend="lpd-for-postscript-printers"> for information on
        this system.
       </Para>

      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term><command>ps2ps</command></Term>
      <ListItem>
       <Para><command>ps2ps</command> is a utility script included
        with Ghostscript.  It filters Postscript into more streamlined
        Postscript, possibly at a lower Language Level.  This is
        useful if you have an older Postscript printer; most modern
        software produces modern Postscript.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term><command>mpage</command></Term>
      <ListItem>
       <Para><command>mpage</command> is a utility which accepts
        text or Postscript, and generates n-up output&mdash;that is,
        output with several page images on each piece of paper.  There
        are actually several programs which do this, including
        <command>enscript</command>, <command>nenscript</command>, and
        <command>a2ps</command>.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term><command>a2ps</command></Term>
      <ListItem>
       <Para><command>a2ps</command>, aka any-to-ps, is a program which
        accepts a variety of file types and converts them to
        Postscript for printing.
       </Para>
      </ListItem>
     </VarListEntry>
    </VariableList>   
   </Para>
  </Sect2>
 </Sect1>

 <Sect1 id="setup">
  <Title>How to set things up</Title>

  <Para>
   For common configurations, you can probably ignore this section
   entirely - instead, you should jump straight to <xref
   linkend="vendors"> below, or better yet, your vendor's
   documentation.  Most Linux distributions supply one or more
   "idiot-proof" tools to do everything described here for common
   printers.
  </Para>

  <Para>
   If your vendor's tool doesn't work out for you, or you'd like the
   ability to interactively control printing options when you print,
   then you should use some other system.  PDQ is a good choice; it
   provides very good functionality and is easy to setup.  APS Filter
   is another good system; it configures LPD queues and filters very
   easily on most any sort of Unix system.
  </Para>

  <Para>
   You can also use the printing system interfaces from the <ulink
   url="http://www.linuxprinting.org/">Linux Printing Website</ulink>
   to connect many free drivers into several spooling systems.  Once
   this project is complete, these interfaces will offer the best
   functionality: all styles of free software drivers are supported,
   user-settable options are available, and most common spooling
   systems are supported.
  </Para>

  <Sect2 id="pdq-config">
   <indexterm><primary>PDQ</primary>
              <secondary>configuration</secondary></indexterm>
   <indexterm><primary>configuration</primary>
              <secondary>PDQ</secondary></indexterm>
   <Title>Configuring PDQ</Title>

   <Para>
    PDQ can be configured by either the superuser or by a joeuser.
    Root's changes are made to <filename>/etc/printrc</filename>, and
    affect everyone, while joeuser can only modify his personal
    <filename>.printrc</filename>.  Everything applies to both types
    of configuration.
   </Para>

   <Para>
    If PDQ is not available prepackaged for your distribution, you
    should obtain the source distribution from the <ULink
    URL="http://feynman.tam.uiuc.edu/pdq/" >PDQ web page</ULink > and
    compile it yourself.  It is an easy compile, but you must first be
    sure to have installed the various GTK development library
    packages, the C library development package, the gcc compiler,
    make, and possibly a few other development things.
   </Para>

   <Sect3 id="pdq-drivers-interfaces">
    <Title>Drivers and Interfaces</Title>

    <Para>
     PDQ lets users select a printer to print to.  A printer is
     defined in PDQ as the combination of a "driver" and an
     "interface".  Both drivers and interfaces are, in fact, merely
     snippets of text in the PDQ configuration file.
    </Para>

    <Para>
     A PDQ interface says everything about how to ship data out to a
     printer.  The most common interfaces, which are predefined in the
     PDQ distribution's example printrc file, are:
     <VariableList>
      <VarListEntry>
       <Term>local-port</Term>
       <ListItem>
        <Para>A local port interface speaks to a parallel or serial
         port on the machine PDQ is running on.  Using this interface,
         PDQ can print directly to your parallel port.  Note that if
         you have a multiuser system this can cause confusion, and if
         you have a network the local-port interface will only apply
         to one system.  In those cases, you can define a raw
         unfiltered lpd queue for the port and print to the system's
         lpd daemon exactly the same way from all systems and accounts
         without any troubles.  This interface has a device name
         argument; the typical value would be
         <filename>/dev/lp0</filename>.
        </Para>
       </ListItem>
      </VarListEntry>

      <VarListEntry>
       <Term>bsd-lpd</Term>
       <ListItem>
        <Para>A bsd lpd interface speaks over the network to an LPD
         daemon or LPD-speaking networked printer.  PDQ supports job
         submission, cancellation, and queries to LPD interfaces.
         This interface has hostname and queuename arguments.
        </Para>
       </ListItem>
      </VarListEntry>

      <VarListEntry id="pdq-config-apple">
       <indexterm><primary>PDQ</primary>
                  <secondary>appletalk</secondary></indexterm>
       <Term>appletalk</Term>
       <ListItem>
        <Para>The appletalk interface allows you to print to printers
         over the Appletalk network; if you have a printer plugged
         into your Mac this is the way to go.  This interface needs to
         have the Netatalk package installed to work.
        </Para>
       </ListItem>
      </VarListEntry>
     </VariableList>
    </Para>

    <Para>
     A PDQ driver says everything about how to massage print data into
     a format that a particular printer can handle.  For Postscript
     printers, this will include conversion from ascii into
     Postscript; for non-Postscript printers this will include
     conversion from Postscript into the printer's language with
     Ghostscript.
    </Para>
  
    <Para>
     If one of PDQ's included driver specifications doesn't fit your
     printer, then read the section below on how to write your own.
    </Para>
   </Sect3>

   <Sect3 id="defining-printers-in-pdq">
    <Title>Defining Printers</Title>

    <Para>
     To define a printer in PDQ:
     <ItemizedList>
      <ListItem>
       <Para>First check that you've got suitable driver and interface
        declarations in the system or your personal printrc.
       </Para>
      </ListItem>

      <ListItem>
       <Para>If you want to define the printer in
        <filename>/etc/printrc</filename> (for all users), then su to
        root.
       </Para>
      </ListItem>

      <ListItem>
       <Para>Run <command>xpdq</command>, and select Printer-&gt;Add
        printer.  This "wizard" will walk you through the selection of
        a driver and interface.
       </Para>
      </ListItem>
     </ItemizedList>
     That's really all there is to it; most of the work lies in
     finding or creating a suitable driver specification if you can't
     find one premade.
    </Para>
   </Sect3>

   <Sect3 id="pdq-drivers-tutorial">
    <indexterm><primary>PDQ</primary>
               <secondary>creating drivers</secondary></indexterm>
    <indexterm><primary>PDQ</primary>
               <secondary>finding drivers</secondary></indexterm>
    <Title>Creating a PDQ Driver Declaration</Title>

    <Para>
     Here I'll walk through an example of how to make a PDQ driver
     declaration.  Before you try that, though, there are several
     places to look for existing driver specs:
     <ItemizedList>
      <ListItem>
       <Para>PDQ itself comes with a collection of prewritten driver
        files.
       </Para>
      </ListItem>

      <ListItem>
       <Para>The Linux Printing Website's <ULink
        URL="http://www.linuxprinting.org/database.html"
        >database</ULink > includes a program called "<ulink
        url="http://www.linuxprinting.org/pdq-doc.html">PDQ-O-Matic</ulink>"
        which will generate a PDQ specification from the information
        in the database.  Assuming that the database contains the
        proper information for your printer and driver, this is the
        best path if you have a non-Postscript printer.
       </Para>
      </ListItem>

      <ListItem>
       <Para>I've written a tool called <command><ulink
        url="http://www.picante.com/~gtaylor/download/printing/"
        >ppdtopdq</ulink ></command> which takes a Postscript Printer
        Definition file and converts it into a PDQ driver
        specification, with about 75% success.  This is an option if
        you have a Postscript printer.
       </Para>
      </ListItem>
     </ItemizedList>
    </Para>

    <Para>
     There are several places to look for the information needed to
     write your own PDQ driver:
     <ItemizedList>
      <ListItem>
       <Para>The PDQ driver specification syntax is quite rich, and is
        fully documented in the <ULink
        URL="http://feynman.tam.uiuc.edu/pdq/man/printrc.5.html"
        >printrc(5)</ULink > man page.
       </Para>
      </ListItem>

      <ListItem>
       <Para>
        The PDQ distribution includes a few example files.  Look in
        particular at the Epson Stylus file, which demonstrates the
        structure of the definition for a Ghostscript-driven printer.
       </Para>
      </ListItem>

      <ListItem>
       <Para>The <ULink URL="http://www.linuxprinting.org/database.html"
        >Printing HOWTO Database</ULink > includes raw Linux driver
        information for over 600 printers.  This will tell you what
        options to give Ghostscript, or what extra program to
        run on the Ghostscript output.
       </Para>
      </ListItem>
     </ItemizedList>
    </Para>

    <Para>
     If you have to create your own driver specification, or if you
     enhance one from the PDQ distribution or one of the PDQ driver
     generator programs mentioned above, please share your creation
     with the world!  Send it to me (<Literal
     remap="tt">gtaylor+pht@picante.com</Literal>), and I'll make sure
     that it gets found by future PDQ users with your type of printer.
    </Para>

    <Para>
     Now, let's walk through the writing of a driver specification for
     a printer listed in the Printing HOWTO's database as working, but
     for which you can't find a PDQ driver spec.  I'll use the Canon
     BJC-210 as the example printer.
    </Para>

    <Para>
     First, we look at the <ULink
     URL="http://www.linuxprinting.org/show_printer.cgi?recnum=58752"
     >database entry</ULink > for this printer.  Note that it is
     supported "perfectly", so we can expect to get comparable results
     (or better) to Windows users.  The important information is in
     two places in the entry:
     <VariableList>
      <VarListEntry>
       <Term>Notes</Term>
       <ListItem>
        <Para>The human-readable notes will often contain useful
         information.  For some printers, there is a More Info link,
         which usually refers to a web page run by a user with this
         printer, or to the driver's home page.
        </Para>
       </ListItem>
      </VarListEntry>

      <VarListEntry>
       <Term>Driver List</Term>
       <ListItem>
        <Para>Most printers have a list of drivers that are known to work.
         This is the most important part.  You can follow the driver
         links to a driver-specific page, which will often have more
         information about how to execute the driver, as well as a
         link to the driver's web page, if it has one.
        </Para>
       </ListItem>
      </VarListEntry>
     </VariableList>
     A PDQ driver spec has two logical functions: user interaction,
     and print job processing. These are represented in the file in
     three places:
     <VariableList>
      <VarListEntry>
       <Term>Option Declarations</Term>
       <ListItem>
        <Para>These define what options the user can set, and declare PDQ
         variables for later parts of the driver to use.
        </Para>
       </ListItem>
      </VarListEntry>

      <VarListEntry>
       <Term>Language Filters</Term>
       <ListItem>
        <Para>These process the print job from whatever format it arrived
         in (typically Postscript or ASCII) into a language the
         printer can understand (for example, PCL).  Option values are
         available here, as well as in the output filter.
        </Para>
       </ListItem>
      </VarListEntry>

      <VarListEntry>
       <Term>Output Filter</Term>
       <ListItem>
        <Para>This final filter bundles up the printer data regardless of
         input type; often printer options are set here.
        </Para>
       </ListItem>
      </VarListEntry>
     </VariableList>
     Let's work on each of these for a Canon BJC-210:
    </Para>

    <Sect4 id="pdq-driver-options">
     <Title>Options</Title>

     <Para>
      The driver list for this printer includes the bj200 and bjc600
      drivers, both of which are Ghostscript style drivers.  The notes
      suggest that we use the bj200 for black-and-white printing.
     </Para>

     <Para>
      So, as far as the user is concerned, the BJC-210 supports one
      useful option: the user should pick color or black-and-white.
      Let's declare that as choice option called "MODE":
<Screen>
option {
  var = "MODE"
  desc = "Print Mode"
  # default_choice "Color"    # uncomment to default to color
  choice "BW" {
    # The value part assigns to the variable MODE whatever you 
    # want. Here we'll assign the text that varies between the 
    # two Ghostscript option sets for the two modes.
    value = "bj200"
    help = "Fast black printing with the black cartridge."
    desc = "Black-only"
  }
  choice "Color" {
    value = "bjc600"
    help = "Full-color printing."
    desc = "Color"
  }
}
</Screen>

      With the above choice declarations, the user will see a Color or
      BW choice in the driver options dialog when he prints from xpdq.
      In the command-line pdq tool, he may specify
      <option>-oBW</option> or <option>-oColor</option>.  The default
      can be set from xpdq, or declared above with the
      <option>default&lowbar;choice</option> keyword.
     </Para>
    </Sect4>

    <Sect4 id="pdq-filter-tutorial">
     <indexterm><primary>filtering</primary>
                <secondary>PDQ</secondary></indexterm>
     <indexterm><primary>PDQ</primary>
                <secondary>filtering</secondary></indexterm>
     <Title>Language Filtering</Title>

     <Para>
      PDQ normally identifies its input with the
      <command>file(1)</command> command.  For each type returned by
      <command>file</command> that you want to handle, you provide a
      <function>language&lowbar;driver</function> clause.  The clause
      consists mostly of a script to process the printjob language, in
      any (!) scripting language you wish (the default is the usual
      Bourne shell).
     </Para>

     <Para>
      In our case, we want to print Postscript and ASCII on our
      BJC-210.  This needs two language drivers: one to run
      Ghostscript for Postscript jobs, and one to add carriage returns
      to ASCII jobs:

<programlisting>
<![CDATA[
# The first language_driver in the file that matches what file(1) 
# says is what gets used.
language_driver ps {
  # file(1) returns "PostScript document text conforming at..."
  filetype_regx = "postscript"
  convert_exec = { 
    gs -sDEVICE=$MODE -r360x360 \     # gs options from the database
       -q -dNOPAUSE -dBATCH -dSAFER \ # the "usual" Ghostscript options
       -sOutputFile=$OUTPUT $INPUT    # process INPUT into file OUTPUT

    # Those last two lines will often be the same for gs-supported
    # printers.  The gs... line, however, will be different for each
    # printer.      
  }
}

# We declare text after postscript, because the command "file" will
# often describe a postscript file as text (which it is).
language_driver text {
  # No filetype_regx; we match the driver's name: "text"
  convert_exec = {#!/usr/bin/perl
     # a Perl program, just because we can!
     my ($in, $out) = ($ENV{'INPUT'}, $ENV{'OUTPUT'});
     open INPUT, "$in";
     open OUTPUT, ">$out";
     while(<INPUT>) {
        chomp;
        print OUTPUT, "$_\r\n";
     }
  }
}
]]>
</programlisting>

     </Para>

     <Para>
      That's it!  While other printers may need output filtering (as
      described in the next section), the above clauses are it for the
      BJC-210.  We just wrap them all up in a named
      <function>driver</function> clause:
<programlisting>
<![CDATA[
driver canon-bjc210-0.1 {
  option {
    var = "MODE"
    desc = "Print Mode"
    # default_choice "Color"    # uncomment to default to color
    choice "BW" {
      # The value part assigns to the variable MODE whatever you 
      # want. Here we'll assign the text that varies between the 
      # two Ghostscript option sets for the two modes.
      value = "bj200"
      help = "Fast black printing with the black cartridge."
      desc = "Black-only"
    }
    choice "Color" {
      value = "bjc600"
      help = "Full-color printing."
      desc = "Color"
    }
  }

  # The first language_driver in the file that matches what file(1) 
  # says is what gets used.
  language_driver ps {
    # file(1) returns "PostScript document text conforming at..."
    filetype_regx = "postscript"
    convert_exec = { 
      gs -sDEVICE=$MODE -r360x360 \     # gs options from the database
         -q -dNOPAUSE -dBATCH -dSAFER \ # the "usual" Ghostscript options
         -sOutputFile=$OUTPUT $INPUT    # process INPUT into file OUTPUT

      # Those last two lines will often be the same for gs-supported
      # printers.  The gs... line, however, will be different for each
      # printer.      
    }
  }

  # We declare text after postscript, because the command "file" will
  # often describe a postscript file as text (which it is).
  language_driver text {
    # No filetype_regx; we match the driver's name: "text"
    convert_exec = {#!/usr/bin/perl
       # a Perl program, just because we can!
       my ($in, $out) = ($ENV{'INPUT'}, $ENV{'OUTPUT'});
       open INPUT, "$in";
       open OUTPUT, ">$out";
       while(<INPUT>) {
          chomp;
          print OUTPUT, "$_\r\n";
       }
    }
  }
}
]]>
</programlisting>

     </Para>

    </Sect4>

    <Sect4 id="pdq-output-filter">
     <Title>Output Filtering</Title>

     <Para>
      If you want to prepend or append something to all printjobs, or
      do some sort of transformation on all the data of all types,
      then it belongs in the <function>filter&lowbar;exec</function>
      clause.  Our little Canon doesn't require such a clause, but
      just to have an example, here's a simple illustration showing
      how to support duplexing and resolution choice on a Laserjet or
      clone that speaks PJL:
<programlisting>
<![CDATA[
driver generic-ljet4-with-duplex-0.1 {
  # First, two option clauses for the user-selectable things:
  option {
    var = "DUPLEX_MODE"
    desc = "Duplex Mode"
    default_choice = "SIMPLEX"
    choice "SIMPLEX" {
      value = "OFF"
      desc = "One-sided prints"
    }
    choice "DUPLEX" {
      value = "ON"
      desc = "Two-sided prints"
    }
  }

  option { 
    var = "GS_RES"
    desc = "Resolution"
    default_choice = "DPI600"
    choice "DPI300" {
      value = "-r300x300"
      desc = "300 dpi" 
    }
    choice "DPI600" {
      value = "-r600x600"
      desc = "600 dpi" 
    }
  }

  # Now, we handle Postscript input with Ghostscript's ljet4 driver:
  language_driver ps {
    filetype_regx = "postscript"
    convert_exec = { 
       gs -sDEVICE=ljet4 $GS_RES \
          -q -dNOPAUSE -dBATCH -dSAFER \
          -sOutputFile=$OUTPUT $INPUT
    }
  }

  # Finally, we wrap the job in PJL commands:
  filter_exec {
    # requires echo with escape code ability...
    echo -ne '\33%-12345X' > $OUTPUT

    echo "@PJL SET DUPLEX=$DUPLEX_MODE"    >> $OUTPUT
    # You can add additional @PJL commands like the above line here.
    # Be sure to always append (>>) to the output file!

    cat $INPUT >> $OUTPUT
    echo -ne '\33%-12345X' >> $OUTPUT
  }
}
]]>
</programlisting>

     </Para>
    </Sect4>
   </Sect3>
  </Sect2>

  <Sect2 id="lpd-config-tutorial">
   <indexterm><primary>LPD</primary>
              <secondary>configuration</secondary></indexterm>
   <indexterm><primary>configuration</primary>
              <secondary>LPD</secondary></indexterm>
   <Title>Configuring LPD</Title>

   <Para>
    Most Linux systems ship with LPD.  This section describes a very
    basic setup for LPD; further sections detail the creation of
    complex filters and network configuration.
   </Para>

   <Sect3 id="basic-lpd-configuration">
    <Title>Basic LPD configuration</Title>

    <Para>
     The minimal setup for lpd results in a system that can queue
     files and print them.  It will not pay any attention to wether or
     not your printer will understand them, and will probably not let
     you produce attractive output.  But we have to start somewhere.
    </Para>

    <Para>
     To add a print queue to lpd, you must add an entry in
     <filename>/etc/printcap</filename>, and make the new spool
     directory under <filename>/var/spool/lpd</filename>.
    </Para>

    <Para>
     An entry in <filename>/etc/printcap</filename> looks like:
<programlisting>
<![CDATA[
# LOCAL djet500
lp|dj|deskjet:\
        :sd=/var/spool/lpd/dj:\
        :mx#0:\
        :lp=/dev/lp0:\
        :sh:
]]>
</programlisting>
     This defines a spool called <Emphasis>lp</Emphasis>,
     <Emphasis>dj</Emphasis>, or <Emphasis>deskjet</Emphasis>, spooled
     in the directory <filename>/var/spool/lpd/dj</filename>, with no
     per-job maximum size limit, which prints to the device
     <filename>/dev/lp0</filename>, and which does not have a banner
     page (with the name of the person who printed, etc) added to the
     front of the print job.
    </Para>

    <Para>
     Go now and read the man page for <filename><ULink
     URL="http://www.linuxprinting.org/man/printcap.5.html"
     >printcap</ULink ></filename>.
    </Para>

    <Para>
     The above looks very simple, but there a catch - unless I send in
     files a DeskJet 500 can understand, this DeskJet will print
     strange things.  For example, sending an ordinary Unix text file
     to a deskjet results in literally interpreted newlines, and gets
     me:
<Screen>
This is line one.
                 This is line two.
                                  This is line three.
</Screen>
     ad nauseam.  Printing a PostScript file to this spool would get a
     beautiful listing of the PostScript commands, printed out with
     this "staircase effect", but no useful output.
    </Para>

    <Para id="lpd-filtering-example">
     <indexterm><primary><option>if</option></primary></indexterm>
     <indexterm><primary>LPD</primary>
	       <secondary><option>if</option></secondary></indexterm>
     Clearly more is needed, and this is the purpose of filtering.
     The more observant of you who read the printcap man page might
     have noticed the spool attributes <option>if</option> and
     <option>of</option>.  Well, <option>if</option>, or the
     input filter, is just what we need here.
    </Para>

    <Para>
     If we write a small shell script called <command>filter</command>
     that adds carriage returns before newlines, the staircasing can
     be eliminated.  So we have to add in an <option>if</option>
     line to our printcap entry above:
<programlisting>
<![CDATA[
lp|dj|deskjet:\
        :sd=/var/spool/lpd/dj:\
        :mx#0:\
        :lp=/dev/lp0:\
        :if=/var/spool/lpd/dj/filter:\
        :sh:
]]>
</programlisting>
A simple filter script might be:
<programlisting>
<![CDATA[
#!perl
# The above line should really have the whole path to perl
# This script must be executable: chmod 755 filter
while(<STDIN>){chomp $_; print "$_\r\n";};
# You might also want to end with a form feed: print "\f";
]]>
</programlisting>
     If we were to do the above, we'd have a spool to which we could
     print regular Unix text files and get meaningful results.  (Yes,
     there are four million better ways to write this filter, but few
     so illustrative.  You are encouraged to do this more
     efficiently.)
    </Para>

    <Para>
     The only remaining problem is that printing plain text is really
     not too hot - surely it would be better to be able to print
     PostScript and other formatted or graphic types of output.  Well,
     yes, it would, and it's easy to do.  The method is simply an
     extention of the above linefeed-fixing filter. 
    </Para>

    <Para>
     Such a filter is called a <Emphasis>magic</Emphasis> filter.  It
     plays the same role as the language filters of PDQ.  Don't bother
     writing one yourself unless you print strange things - there are
     a good many written for you already, and most have easy-to-use
     interactive configuration tools.  You should simply select a
     suitable pre-written filter:
     <VariableList id="lpd-filters-available-now">

      <indexterm>
       <primary>LPD</primary>
       <secondary>filters</secondary>
      </indexterm>
      <indexterm>
       <primary>filtering</primary>
       <secondary>LPD</secondary>
      </indexterm>

      <VarListEntry id="lpdomatic-filter-available">
       <indexterm><primary>filters</primary>
                  <secondary>lpdomatic</secondary></indexterm>
       <indexterm><primary>LPD</primary>
                  <secondary>lpdomatic</secondary></indexterm>
       <indexterm><primary>lpdomatic</primary></indexterm>
       <Term>LPD-O-Matic</Term>
       <ListItem>
        <Para><ulink url="http://www.linuxprinting.org/lpd-doc.html"
         >Lpdomatic</ulink> is a filter designed to use data from the Linux

         Printing printer database.  It will soon support essentially
         all free software printer drivers, including regular
         Ghostscript drivers, Uniprint drivers, and the assorted
         filter programs floating around out there.  It works with
         various strains of LPD, including stock BSD, LPRng, and the
         new VA Linux LPD, to allow option selection.
        </Para>
       </ListItem>
      </VarListEntry>      

      <VarListEntry id="apsfilter-available-now">
       <indexterm><primary>filters</primary>
                  <secondary>APS Filter</secondary></indexterm>
       <indexterm><primary>LPD</primary>
                  <secondary>APS Filter</secondary></indexterm>
       <indexterm><primary>APS Filter</primary></indexterm>
       <Term>APS Filter</Term>
       <ListItem>
        <Para><ulink url="http://people.FreeBSD.org/~andreas/apsfilter/"
         >apsfilter</ulink> is a filter designed for use on a wide
                  variety of Unices.  It supports essentially all
                  Ghostscript drivers.  It, too, works with
                  various strains of LPD, including stock BSD and
                  LPRng.  At the moment, this is probably the best
                  third-party system around for non-PostScript
		  printers.
        </Para>
       </ListItem>
      </VarListEntry>      

      <VarListEntry id="rhs-printfilters-available">
       <indexterm><primary>filters</primary>
                  <secondary>rhs-printfilters</secondary></indexterm>
       <indexterm><primary>rhs-printfilters</primary></indexterm>
       <indexterm><primary>LPD</primary>
                  <secondary>rhs-printfilters</secondary></indexterm>
       <Term>RHS-Printfilters</Term>
       <ListItem>
        <Para>RHS-Printfilters is a filter system constructed by Red Hat.
         It shipped beginning, I think, in version 4 of Red Hat Linux,
         as the backend to the easy-to-use
         <command>printtool</command> GUI printer configuration tool.
         Other distributions, including Debian, now ship the
         rhs-printfilters/printool combo as a printing option.  Thus
         this filter system is arguably the most widely deployed one.
        </Para>

        <Para>
         The rhs filter system is built on an ascii database listing
         distributed with it.  This listing supports many Ghostscript
         and Uniprint drivers, but not filter-style drivers.  The
         filters constructed also do not support much in the way of
         user-controllable options at print time.
        </Para>

        <Para>
         The <command>printtool</command> places a configuration file
         named <filename>postscript.cfg</filename> in the spool
         directory.  Inside this Bourne shell-style file, each setting
         is a variable.  In unusual cases, you can make useful changes
         directly to the config file which the printtool won't allow;
         typically this would be the specification of an unusual
         Ghostscript driver, or a PPD filename for the VA
         rhs-printfilters version.
        </Para>

        <Para>
         VA Linux has made some enhancements to the rhs-printfilters
         system under contract from HP.  With the proper versions, it
         is now possible to select options for Postscript printers
         under control of Adobe PPD files.  I cover this system in
         <xref linkend="lpd-for-postscript-printers">.
        </Para>
       </ListItem>
      </VarListEntry>      

     </VariableList>
    </Para>

    <Para>
     There's one catch to such filters: older version of lpd don't run
     the <Emphasis>if</Emphasis> filter for remote printers, while
     most newer ones do (although often with no arguments).  The
     version of LPD shipped with modern Linux and FreeBSD
     distributions does; most commercial unices that still ship LPD
     have a version that does not.  See the section on network
     printing later in this document for more information on this.  If
     you only have locally-connected printers, then this won't affect
     you.
    </Para>
   </Sect3>

   <Sect3 id="lpd-for-postscript-printers">
    <indexterm><primary>PostScript</primary>
               <secondary>printers</secondary></indexterm>
    <indexterm><primary>PostScript</primary>
               <secondary>LPD</secondary></indexterm>
    <indexterm><primary>LPD</primary>
               <secondary>PostScript</secondary></indexterm>
    <indexterm><primary>LPD</primary>
               <secondary>VA Linux's version</secondary></indexterm>
    <indexterm><primary>VA Linux</primary>
               <secondary>LPD</secondary></indexterm>

    <Title>LPD for PostScript Printers</Title>
 
    <Para>
     While most versions of LPD don't gracefully handle PostScript
     (nevermind user options), VA Linux recently modified LPD and Red
     Hat's filtering software to support PostScript printers fairly
     well.  For the moment, this system works only with Red Hat 6.2,
     although the packages could be easily adapted for other
     distributions.
    </Para>

    <SimpleSect>
     <Title>How it works</Title>

     <Para>
      VA's new system uses Postscript Printer Definition, or PPD,
      files.  PPD files are provided by printer manufacturers and
      declare the available options on a printer, along with the
      Postscript code needed to activate them.  With the VA system,
      the normal LPD scheme works a little differently:
      <OrderedList>
       <ListItem>
        <Para>The user can specify options with the <option>-o</option>
         flag.  For example, you might specify <option>-o
         MediaType:Transparency</option> if you were about to print on
         overhead film.  Alternatively, the front-end <ulink
         url="http://www.compumetric.com/linux.html" >GPR</ulink> can
         be used to specify options in a dialog box; you can see
         screenshots of GPR in <xref linkend="gpr-intro">.
        </Para>
       </ListItem>

       <ListItem>
        <Para>LPR passes the options to LPD as an extended attribute in the
         LPD control file.
        </Para>
       </ListItem>

       <ListItem>
        <Para>A modified version of the rhs-printfilters package is given
         the extended options data in an environment variable, and
         uses ppdfilt to add these options to the print data.
        </Para>
       </ListItem>
      </OrderedList>
     </Para>
    </SimpleSect>

    <SimpleSect>
     <Title>Obtaining and Installing</Title>
 
     <Para>
      You can obtain RPM packages, or source tarballs, from the
      project's <ulink url="http://printing.sourceforge.net/" >website
      on SourceForge</ulink >.  For installation details, consult the
      project's <ulink
      url="http://printing.sourceforge.net/gpr-libppd-uhowto.html">installation
      micro-HOWTO</ulink>.   In essence, you need to uninstall the Red
      Hat version of printtool, lpd, and rhs-printfilters entirely,
      and then install the VA versions, plus ppdfilt, gpr, and a few
      other utilities.
     </Para>

     <Para>
      You will also need PPD files for your Postscript printers.
      PPD files are usually fairly easy to find.  VA Linux and HP
      distribute PPD files for many Laserjet models.  Other vendors
      provide PPDs for their own printers, and Adobe distributes
      <ulink
      url="http://www.adobe.com/products/printerdrivers/winppd.html"
      >PPD files</ulink> for many printers.
     </Para>

     <Para>
      At the moment, much of this is a bit difficult to install.  But
      future installation tools will build upon the printer
      configuration library <command>libprinterconf</command>, which
      enables both the autodetection and rhs-printfilter configuration
      of both networked and local printers.
     </Para>

     <Note>
      <Para>It is possible to use GPR alone, without the modified LPD
            or even rhs-printfilters.  GPR can be compiled with
            all the logic needed to massage Postscript jobs directly.
            This may be an easier-to-install option suitable for
            people who never really need to print using lpr
            directly.</Para>
     </Note>
    </SimpleSect>

    <SimpleSect>
     <Title>Controlling Postscript Options</Title>
     <Para>
      Once you've setup VA's Postscript-capable LPD system, you can
      control your printer's options in two ways:

      <VariableList>

       <VarListEntry>
        <Term>With the GUI</Term>
        <ListItem>
         <Para>To use GPR, you first make sure that you've specified the
	  proper PPD file.  Then the printer's options will be
	  available on the `Advanced' panel.  Basic
	  <command>ppdfilt</command> options will be available on the
	  `Common' panel.
         </Para>
        </ListItem>

       </VarListEntry>

       <VarListEntry>
        <Term>With the command line</Term>
        <ListItem>
         <Para>This <command>lpr</command> supports the <option>-o</option>
	  option.  You may specify any option/value pair from your
	  printer's PPD file with <option>-o</option>.  For example,
	  consider this PPD file option clause:
<programlisting>
<![CDATA[
*OpenUI *PrintQuality/Print Quality: PickOne
*DefaultPrintQuality: None
*OrderDependency: 150 AnySetup *PrintQuality
*PrintQuality None/Printer Setting: ""
*PrintQuality Quick/QuickPrint:  "<< /DeviceRenderingInfo ...
*PrintQuality Normal/Normal: "<< /DeviceRenderingInfo << /...
*PrintQuality Pres/Presentation: "<< /DeviceRenderingInfo ...
*PrintQuality Image/1200 Image Quality: "<< /DeviceRenderi...
*CloseUI: *PrintQuality
]]>
</programlisting>
	  For the option <option>PrintQuality</option>, the possible
	  values are <option>Quick</option>, <option>Normal</option>,
	  <option>Pres</option>, or <option>Image</option>.  You might
	  give a command like:
        <screen>
<prompt>%</prompt> <command>lpr</command> <option>-o PrintQuality:Image</option> <option>file.ps</option>
</screen>
         </Para>
        
         <Para>
          There are a number of options common to all printers which
          will work in addition to the ones from your PPD.  These
          include:

          <VariableList>
           <VarListEntry>
            <Term><option>page-ranges</option></Term>
            <ListItem>
             <Para>You can specify a range of pages to print.  For example,
              <option>page-ranges:2-3</option>.
             </Para>
            </ListItem>
           </VarListEntry>

           <VarListEntry>
            <Term><option>page-set</option></Term>
            <ListItem>
             <Para>You can print only odd or even pages.  For example,
              <option>page-set:odd</option>.
             </Para>
            </ListItem>
           </VarListEntry>

           <VarListEntry>
            <Term><option>number-up</option></Term>
            <ListItem>
             <Para>You can print multiple pages on each piece of paper.
              For example, <option>number-up:2</option>.
             </Para>
            </ListItem>
           </VarListEntry>
          </VariableList>

          Other options are detailed in the <command>ppdfilt</command>
          man page.

         </Para>

        </ListItem>



       </VarListEntry>
      </VariableList>

     </Para>
    </SimpleSect>
   </Sect3>

   <Sect3 id="lpd-permissions">
    <indexterm><primary>LPD</primary>
               <secondary>permissions</secondary></indexterm>
    <Title>File Permissions</Title>

    <Para>
     By popular demand, I include below a listing of the permissions
     on interesting files on my system.  There are a number of better
     ways to do this, ideally using only SGID binaries and not making
     everything SUID root, but this is how my system came out of the
     box, and it works for me.  (Quite frankly, if your vendor can't
     even ship a working lpd you're in for a rough ride).
<Screen>
-r-sr-sr-x   1 root     lp    /usr/bin/lpr*
-r-sr-sr-x   1 root     lp    /usr/bin/lprm*
-rwxr--r--   1 root     root  /usr/sbin/lpd*
-r-xr-sr-x   1 root     lp    /usr/sbin/lpc*
drwxrwxr-x   4 root     lp    /var/spool/lpd/
drwxr-xr-x   2 root     lp    /var/spool/lpd/lp/
</Screen>

    </Para>

    <Para>
     Lpd must currently be run as root so that it can bind to the
     low-numbered lp service port.  It should probably become UID
     lp.lp or something after binding, but I don't think it does.
     This is simply one more reason to avoid the stock BSD LPD.
    </Para>

    <Para>
     PDQ uses a different, non-daemon-centric scheme, so it has
     different programs.  The only SUID root programs are the lpd
     interface programs <command>lpd&lowbar;cancel</command>,
     <command>lpd&lowbar;print</command>, and
     <command>lpd&lowbar;status</command>; these are SUID because
     actual Unix print servers require print requests to originate
     from a priviledged port.  If the only printers for which you use
     PDQ's bsd-lpd interface are networked print servers (like the HP
     JetDirect or Lexmark's MarkNet adapters) then you do not need the
     SUID bit on these programs.
    </Para>
   </Sect3>
  </Sect2>

  <Sect2 id="large-installations">
   <indexterm><primary>networks</primary>
              <secondary>large</secondary></indexterm>
   <indexterm><primary>environment</primary>
              <secondary>enterprise</secondary></indexterm>
   <Title>Large Installations</Title>

   <Para>
    Large installations, by which I mean networks including more than
    two printers or hosts, have special needs.  Below are some tips.
    For really large environments, merely distributing printcap/filter
    information becomes a difficult problem; the <ulink
    url="http://ceps.sourceforge.net/">Cisco Enterprise Print
    System</ulink> addresses this and is probably either a good starting
    point or a nearly complete solution, depending on your needs.
    Medium to large environments can be well supported by native LPRng
    features.
    <ItemizedList>
     <ListItem>
      <Para>Each printer should have a single point of control, where an
       administrator can pause, reorder, or redirect the queue.  To
       implement this, have everyone printing to a local server,
       which will then queue jobs and direct them to the proper
       printer.  For large campuses or distributed networks, have one
       server per building or other suitable network subset.
      </Para>
     </ListItem>

     <ListItem>
      <Para>Use LPRng, at least on servers; the BSD LPD is too buggy for
       "real" use.  So is CUPS, at least right now in mid-2000.
       But don't take my word for it&mdash;you should test a number of
       spoolers and see which suits you best.
      </Para>
     </ListItem>

     <ListItem>
      <Para>Client systems should not have unique printing configurations.
       To implement this, use LPRng's extended printcap syntax so
       that you have one printcap to use everywhere.  CEPS provides
       for this by building atop a lightweight distributed database
       instead of traditional printcap files.
      </Para>
     </ListItem>

     <ListItem>
      <Para>Print queues should not be named for make or model; name print
       queues for something sensible like location (floor2&lowbar;nw)
       or capability (color&lowbar;transparency).  Three years from
       now, when a printer breaks, you will be able to replace it
       with a different make or model without causing confusion.
      </Para>
     </ListItem>

     <ListItem>
      <Para>Operate a web page which shows detailed information on each
       printer, including location, capabilities, etc.  Consider
       having it show the queue and include a button to remove jobs
       from the queue.  Complex networked environments are
       unmanagable for users without proper documentation.
      </Para>
     </ListItem>

     <ListItem>
      <Para>On Unix systems, use PDQ or the like to allow selection of
       print job attributes such as duplex or paper size, and to force
       users to run all Ghostscript processing under the proper user
       ID.  If you have all Postscript printers (as is best), you can
       also select from the GPR or XPP front-ends; both are prettier.
      </Para>
     </ListItem>

     <ListItem>
      <Para>On Windows and Apple systems, use either the platform-specific
       drivers <Emphasis>everywhere</Emphasis> (Samba supports the
       Windows automagical driver-download mechanism) or, better, use
       generic Postscript drivers <Emphasis>everywhere</Emphasis>.  Do
       not mix and match; primitive word processors often produce
       different output when the installed printer driver changes;
       users cannot deal with output that vaires depending on the
       particular client/printer pair.
      </Para>
     </ListItem>

     <ListItem>
      <Para>If at all possible, buy a large-volume printer for
       large-volume printing.  If on a budget, use LPRng's multiple
       printers/one queue facility and assign a babysitter; printers
       are complex mechanical devices that will often jam and run out
       of paper in such configurations.
      </Para>
     </ListItem>

     <ListItem id="network-print-servers-in-large">
      <indexterm><primary>networks</primary>
                 <secondary>print servers</secondary></indexterm>
      <Para>Do not feel that printers must be plugged into workstations;
       Ethernet "print servers" now cost under $100.  The ability to
       locate printers anywhere you can network is a big improvement
       over forced location near a host; locate printers in sensible,
       central locations.
      </Para>
     </ListItem>

     <indexterm><primary>npadmin</primary>
                <secondary>uses</secondary></indexterm
     <ListItem>
      <Para>Use any SNMP trap or other monitoring/alert facility available
       to you - someone should be tasked with running around and
       fixing printers with no ink or paper.  Npadmin (see <xref
       linkend="npadmin">) can be used to do some management
       operations with SNMP printers. 
      </Para>
     </ListItem>
    </ItemizedList>
   </Para>
  </Sect2>

  <Sect2 id="accounting">
   <indexterm><primary>accounting</primary></indexterm>
   <indexterm><primary>LPD</primary>
              <secondary>accounting</secondary></indexterm>
   <Title>Accounting</Title>

   <Para>
    Regular LPD provides very little to help you with accounting.  You
    can specify the name of an accounting file in the
    <option>af</option> printcap attribute, but this is merely passed
    as an argument to your <option>if</option> filter.  It's up to you
    to make your <option>if</option> filter write entries to the
    accounting file, and up to you to process the accounting file
    later (the traditional format is mainly useful for line printers,
    and is nontrivial to parse in Perl, so there's no reason to
    preserve it).  Also, if you're using my
    <command>lpdomatic</command> program as your filter, you'll need
    to make changes, since it depends on being given a configuration
    file as the ``accounting'' file name.
   </Para>

   <Para id="gs-accounting">
    <indexterm><primary>Ghostscript</primary>
              <secondary>accounting</secondary></indexterm>
    Ghostscript provides a PageCount operator that you can use to
    count the number of pages in each job; basically you just tack a
    few lines of postscript onto the end of the job to write an
    accounting file entry; for the best example of this see the file
    <filename>unix-lpr.sh</filename> in the Ghostscript source
    distribution.
   </Para>

   <Para>
    Note that the <command>unix-lpr</command> implementation of
    accounting writes to a file from the Ghostscript interpreter, and
    is thus incompatible with the recommended -dSAFER option.  A
    better solution might be to query the printer with a PJL command
    after each job, or to write a postscript snippet that prints the
    pagecount on stdout, where it can be captured without having to
    write to a file.
   </Para>

   <Para id="lprng-accounting">
    <indexterm><primary>LPRng</primary>
              <secondary>accounting</secondary></indexterm>
    The LPRng print spooler includes an HP-specific sample
    implementation of accounting; I assume that it queries the
    printer with PJL.  This technique should work for most PJL,
    Postscript, or SNMP printers with which you have two-way
    communications.
   </Para>

     <indexterm><primary>npadmin</primary>
                <secondary>uses</secondary></indexterm
   <Para>
    If you have a networked printer that supports SNMP, you can use
    the npadmin program to query a pagecount after each job.  This
    should work properly for all print jobs.  See <xref
    linkend="npadmin"> for more information on npadmin.
   </Para>

  </Sect2>
 </Sect1>

 <Sect1 id="vendors">
  <Title>Vendor Solutions</Title>

  <Para>
   This section is, by definition, incomplete.  Feel free to send in
   details of your favourite distribution.  At the moment, I am aware
   of no distribution that supports, or even provides, the software I
   recommend: PDQ.
  </Para>

  <Para>
   There are a number of third-party packages out there designed to
   make printer configuration under Unix easy.  These are covered in
   <xref linkend="setup">; see the subsection there for your
   particular spooling software for pointers.
  </Para>

  <Sect2 id="rhs-filters-come-with-redhat">
   <indexterm><primary>Red Hat</primary></indexterm>
   <indexterm><primary>filters</primary>
              <secondary>rhs-printfilters</secondary></indexterm>
   <Title>Red Hat</Title>

   <Para>
    Red Hat has a GUI printer administration tool called printtool
    which can add remote printers and printers on local devices.  It
    lets you choose a ghostscript-supported printer type and Unix
    device file to print to, then installs a print queue in
    <filename>/etc/printcap</filename> and uses a filter program from
    the rhs-printfilters package to support postscript and other
    common input types.  This solution works fairly well, and is
    trivial to setup for common cases.
   </Para>

   <Para>
    Where Red Hat fails is when you have a printer which isn't
    supported by their standard Ghostscript (which is GNU rather than
    Aladdin Ghostscript, and which supports fewer printers).  Check in
    the printer compatibility list above (or <ULink
    URL="http://www.linuxprinting.org/printer_list.cgi" >online</ULink
    >) if you find that you can't print properly with the stock Red
    Hat software.  If your printer isn't supported by Red Hat's tools,
    you may need to install a contributed verison of Aladdin
    Ghostscript, and will probably also be better off if you use the
    lpdomatic or apsfilter packages, which know all about the printers
    supported by late-model Ghostscripts, and others besides.
   </Para>

   <Para>
    In future versions of Red Hat the printtool will be reimplemented
    to support a larger list of printers and with the intent to
    support an eventual rhs-printfilters replacement (the current
    filter has difficulty with many common printers like some non-PCL
    DeskJets and most Lexmarks).  Some VA Linux-developed PPD features
    may be incorporated, as well.
   </Para>
  </Sect2>

  <Sect2 id="debian-what-comes-with">
   <indexterm><primary>Debian</primary></indexterm>
   <Title>Debian</Title>

   <Para>
    Debian offers a choice between plain LPD, LPRng, or CUPS; LPRng or
    CUPS are probably the better choices.  I believe Debian also
    offers a choice of printer configuration tools; apsfilter version
    5 or later is probably your best bet, since that verison adds
    support for LPRng and Ghostscript's uniprint driver scheme.  Red
    Hat's printtool is also supported, for those who like GUI
    administration tools.
   </Para>
  </Sect2>

  <Sect2 id="suse-what-comes-with">
   <indexterm><primary>SuSE</primary></indexterm>
   <indexterm><primary>APS Filter</primary>
              <secondary>SuSE</secondary></indexterm>
   <indexterm><primary>filters</primary>
              <secondary>APS Filter</secondary></indexterm>
   <Title>SuSE</Title>

   <Para>
    The printing system on SuSE Linux is based on apsfilter, with some
    enhancements; SuSE's apsfilter will recognize all common file
    formats (including HTML, if html2ps is installed).  There are two
    ways to setup printers on SuSE systems:
    <ItemizedList>
     <ListItem>
      <Para>YaST will let you configure "PostScript", "DeskJet" and "Other
       printers", supported by Ghostscript drivers; it's also possible
       to setup HP's GDI printers (DeskJet 710/720, 820, 1000, via the
       "ppa" package).  YaST will provide
       <filename>/etc/printcap</filename> entries for every printer
       ("raw", "ascii", "auto" and "color", if the printer to
       configure is a color printer).  YaST will create spool
       directories and it will arrange apsfilterrc files, where you're
       able to fine tune some settings (Ghostscript preloads, paper
       size, paper orientation, resolution, printer escape sequences,
       etc.).  With YaST it's also possible to setup network printers
       (TCP/IP, Samba, or Novell Netware Printer).
      </Para>
     </ListItem>
     <ListItem>
      <Para>In addition SuSE includes the regular SETUP program from the
       original apsfilter package (with some enhancements); run
       <command>lprsetup</command> to invoke this configuration
       script.  Once you get accustomed to its GUI, you'll be able to
       configure local and network printers.
      </Para>
     </ListItem>
    </ItemizedList>
   </Para>

   <Para>
    The SuSE installation manual explains both of these setup
    procedures.
   </Para>

   <Para>
    Wolf Rogner reported some difficulties with SuSE.  Apparently the
    following bugs may bite:
    <ItemizedList>
     <ListItem>
      <Para>Apsfilter's regular SETUP script is a bit broken, as are the
       KDE setup tools.  Use YaST.  [ Ed: does this still apply?  It's
       been some time sice Wolf's report. ]
      </Para>
     </ListItem>

     <ListItem>
      <Para>For networked printers that need to be fed from Ghostscript,
       you'll need to first uncomment the line
       REMOTE&lowbar;PRINTER="remote" in
       <filename>/etc/apsfilterrc</filename>.  Then run YaST to
       configure the printer and, under Network configurations, set up
       a remote printer queue.
      </Para>
     </ListItem>

     <ListItem>
      <Para>YaST's setup doesn't allow color laser printers, so configure a
       mono printer and then change mono to color everwhere in the
       printcap entry.  You may have to rename the spool directory,
       too.
      </Para>
     </ListItem>
    </ItemizedList>
   </Para>
  </Sect2>

  <Sect2 id="caldera-what-comes-with">
   <indexterm><primary>Caldera</primary></indexterm>
   <indexterm><primary>LPRng</primary>
              <secondary>Caldera</secondary></indexterm>
   <Title>Caldera</Title>

   <Para>Caldera ships LPRng.  I have no idea what sort of setup tools they
    offer.
   </Para>
  </Sect2>


  <Sect2 id="corel-what-comes-with">
   <indexterm><primary>Corel</primary></indexterm>
   <indexterm><primary>Debian</primary>
              <secondary>Corel</secondary></indexterm>
   <Title>Corel</Title>

   <Para>Corel is Debian-based, so all the Debian facts above should still
    apply.  In addition, they've written their own setup
    tool, based on the sysAPS library which in turn uses my database.
    They've certainly done so as part of WordPerfect. 
   </Para>

   <Para>
    Corel operates a printing support newsgroup named <ulink
    url="news://cnews.corel.com/corelsupport.linux.printing"
    >corelsupport.linux.printing</ulink>.  The bulk of the traffic
    appears to be WordPerfect and Corel Linux related.
   </Para>

  </Sect2>

  <Sect2 id="mandrake-what-comes-with">
   <indexterm><primary>Mandrake</primary></indexterm>
   <Title>Mandrake</Title>

   <Para>
    As of version 7.2b1, Mandrake ships with CUPS standard.  The
    program QtCUPS is used to provide a clean GUI administration
    interface.  Till went to some trouble to include as many drivers
    as possible, and they ship CUPS PPD files build with my own
    <ulink
    url="http://www.linuxprinting.org/foomatic.html">foomatic</ulink>
    interface code. 
   </Para>

   <Para>I think Earlier Mandrake versions shipped with the Red Hat
   printtool.</Para>

  </Sect2>

  <Sect2 id="other-dists">
   <Title>Other Distributions</Title>

   <Para>Please send me info on what other distributions do!
   </Para>
  </Sect2>
 </Sect1>

 <Sect1 id="ghostscript">
  <indexterm><primary>Ghostscript</primary></indexterm>
  <indexterm><primary>Postscript</primary>
             <seealso>Ghostscript</seealso></indexterm>
  <Title>Ghostscript.</Title>

  <Para>
   <ULink URL="http://www.cs.wisc.edu/~ghost/">Ghostscript</ULink> is
   an incredibly significant program for Linux printing.  Most
   printing software under Unix generates PostScript, which is
   typically a &dollar;100 option on a printer.  Ghostscript, however,
   is free, and will generate the language of your printer from
   PostScript.  When tied in with your PDQ printer driver declaration
   or <command>lpd</command> input filter, it gives you a virtual
   PostScript printer and simplifies life immensely.
  </Para>

  <Para>
   Ghostscript is available in two forms.  The commercial version of
   Ghostscript, called Aladdin Ghostscript, may be used freely for
   personal use but may not be distributed by commercial entities.  It
   is generally a year or so ahead of the free Ghostscript; at the
   moment, for example, it supports many color inkjets that the older
   Ghostscripts do not and has rather better PDF support.
  </Para>

  <Para>
   The free version of Ghostscript is GNU Ghostscript, and is simply
   an aged version of Aladdin ghostscript.  This somewhat awkward
   arrangement has allowed Aladdin to be a totally self-funded free
   software project; the leading edge versions are done by L Peter and
   a few employees, and are licensed to hardware and software vendors
   for use in commercial products.  Unfortunately, while this scheme
   has provided for L Peter's continued work on Ghostscript for
   years, it has also inhibited the participation of the wider free
   software community.  Driver authors, in particular, find the
   arrangement poor.  L Peter's retirement plans mandate a larger
   community involvement in the project, so he is considering license
   changes, and has established a SourceForge project.
  </Para>

  <Para>
   Whatever you do with <command><ULink
   URL="http://www.linuxprinting.org/man/gs.1.html" >gs</ULink
   ></command>, be very sure to run it with the option for disabling
   file access (<option>-dSAFER</option>).  PostScript is a fully
   functional language, and a bad PostScript program could give you
   quite a headache.
  </Para>

  <Para>
   Speaking of PDF, Adobe's Portable Document Format (at least through
   1.3) is actually little more than organized PostScript in a
   compressed file.  Ghostscript can handle PDF input just as it does
   PostScript.  So you can be the first on your block with a
   PDF-capable printer.
  </Para>

  <Sect2 id="invoking-gs">
   <Title>Invoking Ghostscript</Title>

   <Para>
    Typically, Ghostscript will be run by whatever filter you settle
    upon (I recommend <command>apsfilter</command> or my own
    <command>lpdomatic</command> if your vendor didn't supply anything
    that suits you), but for debugging purposes it is often handy to
    run it directly.
   </Para>

   <Para>
    <command>gs -help</command> will give a brief listing of options
    and available drivers (note that this list is the list of drivers
    compiled in, not the master list of all available drivers).
   </Para>

   <Para>
    You might run gs for testing purposes like: `<command>gs
	  &lt;options&gt; -q -dSAFER -sOutputFile=/dev/lp1
	  test.ps</command>'. 
   </Para>
  </Sect2>

  <Sect2 id="gs-tuning-stuff">
   <indexterm><primary>Ghostscript</primary>
              <secondary>tuning</secondary></indexterm>
   <Title>Ghostscript output tuning</Title>

   <Para>
    There are a number of things one can do if Ghostscript's output is
    not satisfactory (actually, you can do anything you darn well
    please, since you have the source).
   </Para>

   <Para>
    Some of these options, and others are described in the Ghostscript
    User Guide (the file <filename><ulink
    url="http://www.cs.wisc.edu/~ghost/aladdin/doc/Use.htm"
    >Use.htm</ulink></filename> in the Ghostscript distribution;
    possibly installed under <filename>/usr/doc</filename> or
    <filename>/usr/share/doc</filename> on your system) are all
    excellent candidates for driver options in your filter system or
    PDQ driver declaration.
   </Para>

   <Sect3 id="gs-output-loc-size">
    <Title>Output location and size</Title>

    <Para>
     The location, size, and aspect ratio of the image on a page is
     controlled by the printer-specific driver in ghostscript.  If you
     find that your pages are coming out scrunched too short, or too
     long, or too big by a factor of two, you might want to look in
     your driver's source module and adjust whatever parameters jump
     out at you.  Unfortunately, each driver is different, so I can't
     really tell you what to adjust, but most of them are reasonably
     well commented.
    </Para>
   </Sect3>

   <Sect3 id="gsgamma">
    <indexterm><primary>photograph</primary>
               <secondary>gamma</secondary></indexterm>
     
    <Title>Gamma, dotsizes, etc.</Title>

    <Para>
     Most non-laser printers suffer from the fact that their dots are
     rather large. This results in pictures coming out too dark. If
     you experience this problem with an otherwise untunable driver,
     you could use your own transfer function.  Simply create the
     following file in the ghostscript lib-dir and add its name to the
     gs call just before the actual file. You may need to tweak the
     actual values to fit your printer. Lower values result in a
     brighter print.  Especially if your driver uses a Floyd-Steinberg
     algorithm to rasterize colors, lower values ( 0.2 - 0.15 ) are
     probably a good choice.
    </Para>

    <Para>
<Programlisting>
<![CDATA[
%!
%transfer functions for cyan magenta yellow black
{0.3 exp} {0.3 exp} {0.3 exp} {0.3 exp} setcolortransfer
]]>
</Programlisting>
    </Para>

    <Para>
     It is also possible to mend printers that have some kind of
     color fault by tweaking these values. If you do that kind of
     thing, I recommend using the file
     <filename>colorcir.ps</filename>, that comes with ghostscript (in
     the <filename>examples/</filename> subdirectory), as a test page.
    </Para>

    <Para>
     For many of the newer color inkjet drivers, there are
     command-line options, or different upp driver files, which
     implement gamma and other changes to adapt the printer to
     different paper types.  You sould look into this before playing
     with Postscript to fix things.
    </Para>
   </Sect3>

   <Sect3 id="gscolor">

    <Title>Color Printing in Ghostscript</Title>
    <indexterm><primary>photograph</primary>
               <secondary>color</secondary></indexterm>

    <Para>
     Ghostscript's default color dithering is optimized for
     low-resolution devices.  It will dither rather coarsely in an
     attempt to produce 60ppi output (not dpi, ppi - the "apparent"
     color pixels per inch you get after dithering).  This produces
     rather poor output on modern color printers; inkjets with photo
     paper, in particular, are capable of mich finer ppi settings.
    </Para>

    <Para>
     To adjust this, use the Ghostscript option
     <option>-dDITHERPPI=x</option>, where <option>x</option> is the
     value to use.  This may or may not have an effect with all
     drivers; many newer drivers (the Epson Stylus
     <command>stp</command> driver, for example) implement their own
     dithering and pay no attention to this setting.  Some drivers can
     use either the regular Ghostscript or driver-specific dithering
     (the Canon Bubblejet <command>bjc600</command> driver, for
     example).
    </Para>

    <Para>
     Ghostscript's dithering is in fact rather rudimentary.  Many
     things needed for good output on modern printers are simply not
     available in the Ghostscript core.  Various projects to fix this
     situation&mdash;and the free software world does have the
     software to do so ready and waiting&mdash;are hampered by
     Ghostscript's licensing situation and the resulting "cathedral"
     development style.  Beginning at the <ulink
     url="http://www.linuxprinting.org/summit.html">Open Source
     Printing Summit 2000</ulink>, however, all the necessary people are
     talking, so you can expect this situation to improve shortly.
    </Para>

   </Sect3>
  </Sect2>
 </Sect1>

 <Sect1 id="network">
  <indexterm><primary>networks</primary></indexterm>
  <Title>Networks</Title>

  <Para>
   One of the features of most spoolers is that they support printing
   over the network to printers physically connected to a different
   machine, or to the network directly.  With the careful combination
   of filter scripts and assorted utilities, you can print
   transparently to printers on all sorts of networks.
  </Para>

  <Sect2 id="network-to-unix">
   <indexterm><primary>networks</primary>
              <secondary>Unix</secondary></indexterm>
   <indexterm><primary>networks</primary>
              <secondary>LPD</secondary></indexterm>
   <indexterm><primary>LPD</primary>
              <secondary>Unix networks</secondary></indexterm>
   <Title>Printing to a Unix/lpd host</Title>

   <Para>
    To allow remote machines to print to your printer using the LPD
    protocol, you must list the machines in
    <Emphasis>/etc/hosts.equiv</Emphasis> or
    <Emphasis>/etc/hosts.lpd</Emphasis>.  (Note that
    <Emphasis>hosts.equiv</Emphasis> has a host of other effects; be
    sure you know what you are doing if you list any machine there).
    You can allow only certain users on the other machines to print to
    your printer by usign the <Emphasis>rs</Emphasis> attribute; read
    the <Literal remap="tt"><ULink
    URL="http://www.linuxprinting.org/man/lpd.8.html"
    >lpd</ULink ></Literal> man page for information on this.
   </Para>

   <Sect3 id="network-to-unix-with-pdq">
    <indexterm><primary>networks</primary>
               <secondary>PDQ</secondary></indexterm>
    <indexterm><primary>PDQ</primary>
               <secondary>Unix networks</secondary></indexterm>
    <Title>With <Literal remap="tt">pdq</Literal></Title>

    <Para>
     With PDQ, you define a printer with the interface type "bsd-lpd".
     This interface takes arguments for the remote hostname and queue
     name; the printer definition wizard will prompt you for these.
    </Para>
   </Sect3>

   <Sect3 id="network-to-unix-with-lpd">
    <Title>With <Literal remap="tt">lpd</Literal></Title>

    <Para>
     To print to another machine, you make an
     <Emphasis>/etc/printcap</Emphasis> entry like this:
<Screen>
# REMOTE djet500
lp|dj|deskjet:\
        :sd=/var/spool/lpd/dj:\
        :rm=machine.out.there.com:\
        :rp=printername:\
        :sh:
</Screen>
     Note that there is still a spool directory on the local machine
     managed by <Literal remap="tt">lpd</Literal>.  If the remote
     machine is busy or offline, print jobs from the local machine
     wait in the spool area until they can be sent.
    </Para>
   </Sect3>

   <Sect3 id="network-to-unix-with-rlpr">
    <indexterm><primary>rlpr</primary></indexterm>
    <indexterm><primary>networks</primary>
               <secondary>rlpr</secondary></indexterm>

    <Title>With <Literal remap="tt">rlpr</Literal></Title>

    <Para>
     You can also use <Emphasis>rlpr</Emphasis> to send a print job
     directly to a queue on a remote machine without going through the
     hassle of configuring lpd to handle it.  This is mostly useful in
     situations where you print to a variety of printers only
     occasionally.  From the announcement for
     <Emphasis>rlpr</Emphasis>:
    </Para>

    <Para>
     Rlpr uses TCP/IP to send print jobs to lpd servers anywhere on a
     network.
    </Para>

    <Para>
     Unlike lpr, it *does not* require that the remote printers be
     explicitly known to the machine you wish to print from,
     (e.g. through <Emphasis>/etc/printcap</Emphasis>) and thus is
     considerably more flexible and requires less administration.
    </Para>

    <Para>
     rlpr can be used anywhere a traditional lpr might be used, and is
     backwards compatible with traditional BSD lpr.
    </Para>

    <Para>
     The main power gained by rlpr is the power to print remotely
     *from anywhere to anywhere* without regard for how the system you
     wish to print from was configured.  Rlpr can work as a filter
     just like traditional lpr so that clients executing on a remote
     machine like netscape, xemacs, etc, etc can print to your local
     machine with little effort.
    </Para>

    <Para>
     Rlpr is available from <Literal remap="tt"><ULink
     URL="ftp://metalab.unc.edu/pub/Linux/system/printing/"
     >Metalab</ULink ></Literal>.
    </Para>
   </Sect3>
  </Sect2>

  <Sect2 id="network-to-windows">
   <indexterm><primary>networks</primary>
              <secondary>Windows</secondary></indexterm>
   <indexterm><primary>Windows</primary>
              <secondary>printing to</secondary></indexterm>
   <Title>Printing to a Windows or Samba printer</Title>

   <Para>
    There is a Printing to Windows mini-HOWTO out there which has more
    info than there is here.
   </Para>

   <Sect3 id="network-to-windows-with-pdq">
    <indexterm><primary>PDQ</primary>
              <secondary>Windows networks</secondary></indexterm>
    <Title>From PDQ</Title>

    <Para>
     There is not a prebuilt smb interface that I am aware of, but it
     would be fairly easy to create using the model set by the
     Netatalk-based appletalk interface.  Someone please create one
     and submit it for inclusion!
    </Para>

    <Para>
     Read the Windows/LPD section below for more tips on how to do it.
    </Para>
   </Sect3>

   <Sect3 id="network-to-windows-with-lpd">
    <indexterm><primary>LPD</primary>
               <secondary>Windows networks</secondary></indexterm>
    <Title>From LPD</Title>

    <Para>
     It is possible to direct a print queue through the <Literal
     remap="tt"><ULink
     URL="http://www.linuxprinting.org/man/smbclient.1.html"
     >smbclient</ULink ></Literal> program (part of the samba suite)
     to a TCP/IP based SMB print service.  Samba includes a script to
     do this called <Literal remap="tt">smbprint</Literal>.  In short,
     you put a configuration file for the specific printer in question
     in the spool directory, and install the <Literal
     remap="tt">smbprint</Literal> script as the
     <Emphasis>if</Emphasis>.
    </Para>

    <Para>
     The <Emphasis>/etc/printcap</Emphasis> entry goes like this:
<Screen>
lp|remote-smbprinter:\
    :sh:\
    :lp=/dev/null:\
    :sd=/var/spool/lpd/lp:\
    :if=/usr/local/sbin/smbprint:
</Screen>
    </Para>

    <Para>
     You should read the documentation inside the <Literal
     remap="tt">smbprint</Literal> script for more information on how
     to set this up.
    </Para>

    <Para>
     You can also use <Literal remap="tt">smbclient</Literal> to
     submit a file directly to an SMB printing service without
     involving <Literal remap="tt">lpd</Literal>.  See the man page.
    </Para>
   </Sect3>
  </Sect2>

  <Sect2 id="network-to-netware">
   <Title>Printing to a NetWare Printer</Title>
   <indexterm><primary>networks</primary>
              <secondary>Netware</secondary></indexterm>
   <indexterm><primary>PDQ</primary>
              <secondary>Netware networks</secondary></indexterm>
    <indexterm><primary>Netware</primary>
               <secondary>printing to</secondary></indexterm>
   <Para>
    The ncpfs suite includes a utility called <Literal
    remap="tt">nprint</Literal> which provides the same functionality
    as <Literal remap="tt">smbprint</Literal> but for NetWare.  You
    can get ncpfs from <ULink
    URL="ftp://metalab.unc.edu/pub/Linux/system/filesystems/ncpfs/"
    >Metalab</ULink >.  From the LSM entry for version 0.16:
   </Para>

   <Para>
    <QUOTE>
     With ncpfs you can mount volumes of your netware server under
     Linux. You can also print to netware print queues and spool
     netware print queues to the Linux printing system. You need
     kernel 1.2.x or 1.3.54 and above. ncpfs does NOT work with any
     1.3.x kernel below 1.3.54.
    </QUOTE>
   </Para>

   <Sect3 id="network-to-netware-with-lpd">
    <indexterm><primary>LPD</primary>
               <secondary>Netware networks</secondary></indexterm>
    <Title>From LPD</Title>

    <Para>
     To make <Literal remap="tt">nprint</Literal> work via lpd, you
     write a little shell script to print stdin on the NetWare
     printer, and install that as the <Emphasis>if</Emphasis> for an
     lpd print queue.  You'll get something like:
<Screen>
sub2|remote-NWprinter:\
        :sh:\
        :lp=/dev/null:\
        :sd=/var/spool/lpd/sub2:\
        :if=/var/spool/lpd/nprint-script:
</Screen>

     The <Literal remap="tt">nprint-script</Literal> might look
     approximately like:
<Screen>
#! /bin/sh
# You should try the guest account with no password first!
/usr/local/bin/nprint -S net -U name -P passwd -q printq-name -
</Screen>

    </Para>
   </Sect3>
  </Sect2>

  <Sect2 id="network-to-apple">
    <indexterm><primary>networks</primary>
               <secondary>Apple</secondary></indexterm>
    <indexterm><primary>Apple</primary>
               <secondary>printing to</secondary></indexterm>
   <Title>Printing to an EtherTalk (Apple) printer</Title>

   <Para>
    The netatalk package includes something like <Literal
    remap="tt">nprint</Literal> and <Literal
    remap="tt">smbclient</Literal>.  Others have documented the
    procedure for printing to and from an Apple network far better
    than I ever will; see the <ULink
    URL="http://thehamptons.com/anders/netatalk/" >Linux
    Netatalk-HOWTO</ULink >.
   </Para>

   <Sect3 id="network-to-apple-from-pdq">
    <Title>From PDQ</Title>
    <indexterm><primary>PDQ</primary>
               <secondary>Apple networks</secondary></indexterm>

    <Para>
     PDQ includes an interface declaration called "appletalk".  This
     uses the Netatalk package to print to a networked Apple printer.
     Just select this interface in xpdq's "Add printer" wizard.
    </Para>
   </Sect3>
  </Sect2>

  <Sect2 id="networked-printers">
   <indexterm><primary>networks</primary>
              <secondary>network printers</secondary></indexterm>
   <indexterm><primary>networks</primary>
              <secondary>print servers</secondary></indexterm>
   <Title>Printing to a networked printer</Title>

   <indexterm><primary>LPD</primary>
              <secondary>network printers</secondary></indexterm>
   <indexterm><primary>PDQ</primary>
              <secondary>network printers</secondary></indexterm>
   <Para>
    Many printers come with an ethernet interface which you can print
    to directly, typically using the LPD protocol.  You should
    follow the instructions that came with your printer or its network
    adaptor, but in general, such printers are "running" lpd, and
    provide one or more queues which you can print to.  An HP, for
    example, might work with a printcap like:
<Screen>
lj-5|remote-hplj:\
        :sh:\
        :sd=/var/spool/lpd/lj-5:\
        :rm=printer.name.com:\
        :rp=raw:
</Screen>
    or, using the PDQ bsd-lpd interface arguments of
    REMOTE&lowbar;HOST=printer.name.com and QUEUE=raw.
   </Para>

   <Para>
    HP Laserjet printers with JetDirect interfaces generally support
    two built in lpd queues - "raw" which accepts PCL (and possibly
    Postscript) and "text" which accepts straight ascii (and copes
    automatically with the staircase effect).  If you've got a
    JetDirect Plus3 three-port box, the queues are named "raw1",
    "text2", and so forth.
   </Para>

   <Para>
    Note that the ISS company has identified an assortment of denial
    of service attacks which hang HP Jetdirect interfaces.  Most of
    these have been addressed beginning in Fall 98.  These sorts of
    problems are common in embedded code; few appliance-style devices
    should be exposed to general Internet traffic.
   </Para>

   <indexterm><primary>environment</primary>
              <secondary>enterprise</secondary></indexterm>
   <Para>
    In a large scale environment, especially a large environment where
    some printers do not support PostScript, it may be useful to
    establish a dedicated print server to which all machines print and
    on which all ghostscript jobs are run.  This will allow the queue
    to be paused or reordered using the topq and lprm commands.
   </Para>

   <Para>
    This also allows your Linux box to act as a spool server for the
    printer so that your network users can complete their print jobs
    quickly and get on with things without waiting for the printer to
    print any other job that someone else has sent.  This is suggested
    too if you have unfixable older HP Jetdirects; it reduces the
    likelihood of the printers wedging.
   </Para>

   <Para>
    To do this, set up a queue on your linux box that points at the
    ethernet equipped HP LJ (as above). Now set up all the clients on
    your LAN to point at the Linux queue (eg lj-5 in the example
    above).
   </Para>

   <Para>
    Some HP network printers apparently don't heed the banner page
    setting sent by clients; you can turn off their internally
    generated banner page by telnetting to the printer, hitting return
    twice, typing "banner: 0" followed by "quit".  There are other
    settings you can change this way, as well; type "?" to see a list.
   </Para>

   <Para>
    The full range of settings can be controlled with HP's <ULink
    URL="http://www.hp.com/go/webjetadmin" >webJetAdmin</ULink >
    software.  This package runs as a daemon, and accepts http
    requests on a designated port.  It serves up forms and Java
    applets which can control HP printers on the network.  In theory,
    it can also control Unix print queues, but it does so using the
    rexec service, which is completely unsecure.  I don't advise using
    that feature.
   </Para>

   <Sect3 id="networked-printers-appsocket">
    <indexterm><primary>AppSocket protocol</primary></indexterm>
    <indexterm><primary>networks</primary>
               <secondary>AppSocket protocol</secondary></indexterm>
    <indexterm><primary>HP</primary>
               <secondary>JetDirect</secondary></indexterm>
    <Title>To AppSocket Devices</Title>

    <indexterm><primary>LPRng</primary>
               <secondary>AppSocket protocol</secondary></indexterm>
    <Para>
     Some printers (and printer networking "black boxes") support only
     a cheesy little non-protocol involving plain TCP connections;
     this is sometimes called the "AppSocket" protocol.  Notable in
     this category are early-model JetDirect (including some
     JetDirectEx) cards.  Basically, to print to the printer, you must
     open a TCP connection to the printer on a specified port
     (typically 9100, or 9100, 9101 and 9102 for three-port boxes) and
     stuff your print job into it.  LPRng has built-in support for
     stuffing print jobs into random TCP ports, but with BSD lpd it's
     not so easy.  The best thing is probably to obtain and use the
     little utility called netcat.
    </Para>

    <Para id="networked-printers-from-spoolers">
    <indexterm><primary>PDQ</primary>
               <secondary>AppSocket protocol</secondary></indexterm>
    <indexterm><primary>LPD</primary>
               <secondary>AppSocket protocol</secondary></indexterm>

     A netcat-using PDQ interface would look something like this:
<programlisting>
<![CDATA[
interface tcp-port-0.1 {

   help "This is one of the first interfaces supported by standalone
         network printers and print servers.  The device simply
         listens for a TCP connection on a certain port, and sends
         data from any connection to the printer.\nThis interface
         requires the netcat program (\"nc\")."

   required_args "REMOTE_HOST"

   argument { 
      var = "REMOTE_HOST"
      desc = "Remote host"
      help = "This is IP name or number of the print server."
   }

   argument { 
      var = "REMOTE_PORT"
      def_value = "9100"
      desc = "Remote port"
      help = "This is the TCP port number on the print server that the
              print job should be sent to.  Most JetDirect cards, and
              clones, accept jobs on port 9100 (or 9101 for port 2,
              etc)."
   }

   requires "nc"

   send_exec { cat $OUTPUT | nc $REMOTE_HOST $REMOTE_PORT }
 
}
]]>
</Programlisting>

    </Para>

    <Para>
     Failing that, it can be implemented, among other ways, in Perl
     using the program below.  For better performance, use the
     program netcat ("nc"), which does much the same thing in a
     general purpose way.  Most distributions should have netcat
     available in prepackaged form.
    </Para>

    <Para>
<programlisting>
<![CDATA[
#!/usr/bin/perl
# Thanks to Dan McLaughlin for writing the original version of this
# script (And to Jim W. Jones for sitting next to Dan when writing me
# for help ;)

$fileName = @ARGV[0];

open(IN,"$fileName") || die "Can't open file $fileName";

$dpi300     = "\x1B*t300R";
$dosCr      = "\x1B&k3G";
$ends = "\x0A";

$port =  9100 unless $port;
$them = "bach.sr.hp.com" unless $them;

$AF_INET = 2;
$SOCK_STREAM = 1;
$SIG{'INT'} = 'dokill';
$sockaddr = 'S n a4 x8';

chop($hostname = `hostname`);
($name,$aliases,$proto) = getprotobyname('tcp');
($name,$aliases,$port) = getservbyname($port,'tcp')
    unless $port =~ /^\d+$/;;
($name,$aliases,$type,$len,$thisaddr) =
        gethostbyname($hostname);
($name,$aliases,$type,$len,$thataddr) = gethostbyname($them);
$this = pack($sockaddr, $AF_INET, 0, $thisaddr);
$that = pack($sockaddr, $AF_INET, $port, $thataddr);

if (socket(S, $AF_INET, $SOCK_STREAM, $proto)) {
#    print "socket ok\n";
}
else {
    die $!;
}
# Give the socket an address.
if (bind(S, $this)) {
#    print "bind ok\n";
}
else {
    die $!;
}

# Call up the server.

if (connect(S,$that)) {
#    print "connect ok\n";
}
else {
    die $!;
}

# Set socket to be command buffered.

select(S); $| = 1; select(STDOUT);

#    print S "@PJL ECHO Hi $hostname! $ends";
#    print S "@PJL OPMSG DISPLAY=\"Job $whoami\" $ends";
#    print S $dpi300;

# Avoid deadlock by forking.

if($child = fork) {
    print S $dosCr;
    print S $TimesNewR;

    while (<IN>) {
        print S;
    }
    sleep 3;
    do dokill();
} else {
    while(<S>) {
        print;
    }
}

sub dokill {
    kill 9,$child if $child;
}
]]>
</programlisting>

    </Para>
   </Sect3>
  </Sect2>

  <Sect2 id="if-for-remote-printers">
   <indexterm><primary><option>if</option></primary>
              <seealso>LPD</seealso></indexterm>
   <indexterm><primary>LPD</primary>
              <secondary><option>if</option></secondary></indexterm>
   <Title>Running an <option>if</option> for remote printers with old
          LPDs</Title>

   <Para>
    One oddity of older versions of lpd is that the <option>if</option>
    is not run for remote printers.  (Versions after 0.43 or so have
    the change originated on FreeBSD such that the <option>if</option>
    is always run).  If you find that you need to run an
    <option>if</option> for a remote printer, and it isn't working
    with your lpr, you can do so by setting up a double queue and
    requeueing the job.  As an example, consider this
    <filename>printcap</filename>:
   </Para>

   <Para>
<programlisting>
<![CDATA[
lj-5:\
        :lp=/dev/null:sh:\
        :sd=/var/spool/lpd/lj-5:\
        :if=/usr/lib/lpd/filter-lj-5:
lj-5-remote:sh:rm=printer.name.com:\
        :rp=raw:sd=/var/spool/lpd/lj-5-raw:
]]>
</programlisting>

    in light of this <command>filter-lj-5</command> script:
<programlisting>
<![CDATA[
#!/bin/sh
gs <options> -q -dSAFER -sOutputFile=- - | \
        lpr -Plj-5-remote -U$5
]]>
</programlisting>

   </Para>

   <Para>
    The <option>-U</option> option to lpr only works if lpr is run
    as daemon, and it sets the submitter's name for the job in the
    resubmitted queue correctly.  You should probably use a more
    robust method of getting the username, since in some cases it is
    not argument 5.  See the man page for <filename><ULink
    URL="http://www.linuxprinting.org/man/printcap.5.html"
    >printcap</ULink ></filename>.
   </Para>
  </Sect2>

  <Sect2 id="network-from-windows">
   <indexterm><primary>Windows</primary>
              <secondary>printing from</secondary></indexterm>
   <indexterm><primary>Windows</primary>
              <secondary>samba</secondary>
              <see>samba</see>
              </indexterm>
   <indexterm><primary>networks</primary>
              <secondary>Windows</secondary></indexterm>
   <Title>From Windows.</Title>

    <indexterm><primary>samba</primary></indexterm>

    <Para>
     Printing from a Windows (or presumably, OS/2) client to a Linux
     server is directly supported over SMB through the use of the
     SAMBA package, which also supports file sharing of your Linux
     filesystem to Windows clients.
    </Para>

    <Para>
     Samba includes fairly complete documentation, and there is a good
     Samba FAQ which covers it, too.  You can either configure a magic
     filter on the Linux box and print PostScript to it, or run around
     installing printer-specific drivers on all the Windows machines
     and having a queue for them with no filters at all.  Relying on
     the Windows drivers may in some cases produce better output, but
     is a bit more of an administrative hassle if there are many
     Windows boxen.  So try Postscript first.  Modern versions of
     Samba should support the automagical driver download mechanism
     offered by Windows NT servers to deal with this problem.
    </Para>

    <indexterm><primary>PDQ</primary>
               <secondary>from Windows</secondary></indexterm>
    <Para>
     With PDQ, you should configure Samba to run the pdq command with
     appropriate arguments instead of the lpr command that it defaults
     to running.  I believe that Samba will run pdq as the proper
     user, so it should work well this way.  There are several Samba
     options that you should adjust to do this:
     <VariableList>
      <VarListEntry>
       <Term>printcap</Term>
       <ListItem>
        <Para>This should point to a "fake" printcap you whip up listing
         available printers.  All you need is a short and long name
         for each printer, one per line:
<Screen>
lp1|Printer One
lp2|Printer Two
lp3|Printer Three
</Screen>
         The short name will be used as the printer name for the print
         command:
        </Para>
       </ListItem>
      </VarListEntry>

      <VarListEntry>
       <Term>print command</Term>
       <ListItem>
        <Para>This will need to be set to something like <Literal
         remap="tt">pdq -P &percnt;p &percnt;s ; rm
         &percnt;s</Literal>.
        </Para>
       </ListItem>
      </VarListEntry>

     <VarListEntry>
      <Term>lprm command</Term>
      <ListItem>
       <Para>There doesn't seem to be a good value for this setting at the
        moment.  PDQ's queued jobs will expire after a time, so if the
        printer is totally gone there's no problem.  If you just
        change your mind, you can use <command>xpdq</command> to
        cancel jobs, but this is inconvenient from Windows.  Just put
        a do-nothing command like <command>true</command> for now.  If
        you use <command>lpd</command> or LPRng as the back-end, then
        a suitable <command>lprm</command> command should work.  I'm
        not sure how Samba would identify the lpr queue entry number
        for a pdq-submitted job.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>lpq command</Term>
      <ListItem>
       <Para>Again, PDQ doesn't offer a good value to put here.
        Distributed systems don't offer a sensible way to see the
        queue, but samba-centric centralized server systems want to
        have a queue worth examining.  Just put a do-nothing command
        like <command>true</command> for now.  If you use LPD or LPRng
        as the back-end, then a suitable <command>lpq</command>
        command should work; you just won't see jobs until they're
        done being filtered by PDQ.
       </Para>
      </ListItem>
     </VarListEntry>
    </VariableList>
   </Para>
  </Sect2>

  <Sect2 id="networks-from-apple">
   <indexterm><primary>networks</primary>
              <secondary>Apple</secondary></indexterm>
   <indexterm><primary>Apple</primary>
              <secondary>printing from</secondary></indexterm>
   <indexterm><primary>netatalk</primary></indexterm>
   <indexterm><primary>Apple</primary>
              <secondary>netatalk</secondary>
              <see>netatalk</see></indexterm>
   <Title>From an Apple.</Title>

   <Para>
    Netatalk supports printing from Apple clients over EtherTalk.  See
    the <ULink URL="http://thehamptons.com/anders/netatalk/" >Netatalk
    HOWTO Page</ULink > for more information.
   </Para>
  </Sect2>

  <Sect2 id="networks-from-netware">
   <indexterm><primary>networks</primary>
              <secondary>Netware</secondary></indexterm>
   <indexterm><primary>Netware</primary>
              <secondary>printing from</secondary></indexterm>
   <indexterm><primary>ncpfs</primary></indexterm>
   <indexterm><primary>Netware</primary>
              <secondary>ncpfs</secondary>
              <see>ncpfs</see></indexterm>
   <Title>From Netware.</Title>

   <Para>
    The ncpfs package includes a daemon named pserver which can be
    used to privide service to a NetWare print queue.  From what I
    understand, this system requires a Bindery-based NetWare, ie 2.x,
    3.x, or 4.x with bindery access enabled.
   </Para>

   <Para>
    For more information on ncpfs and it's pserver program, see <ULink
    URL="ftp://ftp.gwdg.de/pub/linux/misc/ncpfs/" >the ncpfs FTP
    site</ULink >.
   </Para>
  </Sect2>


  <Sect2>
   <indexterm><primary>networks</primary>
              <secondary>administration</secondary></indexterm>
   <indexterm><primary>npadmin</primary></indexterm>
   <Title>Networked Printer Administration</Title>

   <Para>
    Most networked printers support some method of remote
    administration.  Often there are easy-to-use web pages for
    configuration.  More usefully, there is often support for SNMP
    management.  Typically you can find out interesting information on
    printer status like ink and paper levels, print volumes, and so
    forth, and you can usually change certain settings.  SNMP printer
    control, and a number of other printing-related things, are being
    standardized by the IEEE's <ulink url="http://www.pwg.org/"
    >Printer Working Group</ulink>
   </Para>

   <Sect3 id="npadmin">
    <Title><command>npadmin</command></Title>

    <Para>
     <ulink url="http://npadmin.sourceforge.net/">Npadmin</ulink> is a
     command-line program which offers an interface to the common SNMP
     functionality of networked printers.  It implements the standard
     <ulink url="http://www.ietf.org/rfc/rfc1759.txt" >Printer
     MIB</ulink>, as well as a few vendor-proprietary schemes used
     mainly for older devices.  Both printer-discovery style actions
     and various printer status queries are supported.
    </Para>

    <Para>
     npadmin has an excellent <ulink
     url="http://npadmin.sourceforge.net/man/">man page</ulink>, and
     precompiled packages are distributed for a number of RPM and dpkg
     based distributions.
    </Para>

   </Sect3>   

   <Sect3>
    <Title>Other SNMP tools</Title>
    <Para>
     Besides npadmin, there are a number of SNMP tools that will be
     useful.  <command>snmptraplogd</command> can log SNMP trap
     events.  This is useful for observing printer jams, out of paper
     events, etc; it would be straightforward to retransmit certain
     events to a pager, or to send an email.
    </Para>

    <Para>
     While npadmin provides simplified support for many network
     printers' SNMP interfaces, some printers may have vendor
     extensions which npadmin doesn't know about.  In this case, you
     can use the CMU SNMP tools, which support arbitrary SNMP GET and
     SET operations, as well as walks and the like.  With these, and a
     bit of work, you can make use of any SNMP feature offered by your
     printer's MIB.  You may need to obtain a MIB from your vendor to
     figure out what all the variables are; sometimes vendors think
     that people actually use the proprietary tools they ship.
    </Para>

    <Para>
     VA Linux's <command><ulink
     url="http://sourceforge.net/project/?group_id=3648"
     >libprinterconf</ulink></command> includes code to perform
     network printer discovery.  Printers are identified against a
     compiled-in library of printer signatures; at the moment the
     library is not large, but does cover many common networked
     printer models.
    </Para>
   </Sect3>   

  </Sect2>

 </Sect1>

 <Sect1 id="winprinters">
  <indexterm><primary>winprinters</primary>
             <secondary>workarounds</secondary></indexterm>
  <Title>Windows-only printers</Title>

  <Para>
   As I discussed earlier, some printers are inherently unsupported
   because they don't speak a normal printer language, instead using
   the computer's CPU to render a bitmap which is then piped to the
   printer at a fixed speed.  In a few cases, these printers also
   speak something normal like PCL, but often they do not.  In some
   (really low-end) cases, the printer doesn't even use a normal
   parallel connection but relies on the vendor's driver to emulate
   what should be hardware behaviour (most importantly flow control).
  </Para>

  <Para>
   In any case, there are a few possible workarounds if you find
   yourself stuck with such a lemon.
  </Para>

  <Sect2 id="gs-win-redirector">
   <Title>The Ghostscript Windows redirector</Title>

   <Para>
    There is now a Windows printer driver available (called
    <command>mswinpr2</command>) that will run a print job through
    Ghostscript before finally printing it.  (Rather like an
    <option>if</option> filter in Unix's LPD).  There is also a new
    Ghostscript driver which will print using Windows GDI calls.
    Taken all together, this allows a Windows machine to print
    PostScript to a Windows-only printer through the vendor's driver.
   </Para>

   <Para>
    If you get that working, you can then follow the instructions
    above for printing to a Windows printer over the network from
    Linux to let Unix (and other Windows, Mac, etc) hosts print to
    your lemon printer.
   </Para>
  </Sect2>

  <Sect2 id="hp-winprinters">
   <Title>HP Winprinters</Title>

   <Para>
    Some HP printers use "Printing Performance Architecture"
    (marketingspeak for "we were too cheap to implement PCL").  This
    is supported in a roundabout way via the pbm2ppa translator
    written by Tim Norman.  Basically, you use ghostscript to render
    PostScript into a bitmapped image in pbm format and then use
    pbm2ppa to translate this into a printer-specific ppa format
    bitmap ready to be dumped to the printer.  This program may also
    come in ghostscript driver format by now.
   </Para>

   <Para>
    The ppa software can be had from <ULink
    URL="http://www.rpi.edu/~normat/technical/ppa/" >the ppa home
    page</ULink >; pbm2ppa supports some models of the HP 720, 820,
    and 1000; read the documentation that comes with the package for
    more details on ppa printer support.
   </Para>
  </Sect2>

  <Sect2 id="lex-winprinters">
   <Title>Lexmark Winprinters</Title>

   <Para>
    Most of the cheap Lexmark inkjets use a proprietary language and
    are therefore Winprinters.  However, Henryk Paluch has written a
    program which can print on a Lexmark 7000.  Hopefully he'll be
    able to figure out color and expand support to other Lexmark
    inkjets.  See <ULink
    URL="http://bimbo.fjfi.cvut.cz/~paluch/l7kdriver/" >here</ULink >
    for more info.
   </Para>

   <Para>
    Similarly, there are now drivers for the 5700, 1000, 1100, 2070,
    3200, and others.  See the supported printers listing above, and
    my web site, for more information on obtaining these drivers.
   </Para>
  </Sect2>
 </Sect1>

 <Sect1 id="faxing">
  <Title>How to print to a fax machine.</Title>

  <Para>
   You can print to a fax machine with, or without, a modem.
  </Para>

  <Sect2 id="using-a-faxmodem">
   <Title>Using a faxmodem</Title>

   <Para>
    There are a number of fax programs out there that will let you fax
    and receive documents.  One of the most powerful is Sam Leffler's
    <ProductName><ulink url="http://www.hylafax.org/"
    >HylaFAX</ulink></ProductName>.  It supports all sorts of things
    from multiple modems to broadcasting.
   </Para>

   <Para>
    SuSE ships a Java HylaFax client which allegedly works on any Java
    platform (including Windows and Linux).  There are also non-Java
    fax clients for most platforms; Linux can almost certainly handle
    your network faxing needs.
   </Para>

   <Para id="efax">
    <indexterm><primary>environment</primary>
               <secondary>home</secondary></indexterm>
    Also available, and a better choice for smaller installations, is
    <command><ULink URL="http://casas.ee.ubc.ca/efax/">efax</ULink
    ></command>, a simple program which sends and receives faxes.  The
    getty program <command>mgetty</command> can receive faxes using
    <command>efax</command> (and do voicemail or interactive logins).
   </Para>

   <Sect3 id="fax-from-pdq">
    <Title>Faxing from PDQ</Title>

    <Para>
     PDQ doesn't ship with a fax interface declaration, but here's a
     simple one (which is only partly tested):
<programlisting>
<![CDATA[
interface efax-0.1 {
   help "This interface uses the efax package's fax program to send a
         fax.  You should first get efax's \"fax send\" working by
         itself by editing the file /etc/efax.rc and testing.  Connect
         this interface to a generic postscript driver to define a
         fax machine \"printer\"". 

   requires { "efax" "fax" }

   # Making phone number required means that the add printer wizard
   # will demand a phone number at add printer time.  This is
   # undesirable, so it isn't explicitly required, even though it is
   # logically required.  The send_exec script checks for the number.
   # You could skip the wizard by adding this printer by hand to
   # .printrc, mark this as required, and it might then prompt?
   argument {
      var = "PHONE_NUMBER"
      desc = "Phone Number"
      help = "The phone number to dial.  Prefixes like 9 ought to be
              defined in your /etc/efax.rc file."
   }

   option {
      var = "RESOLUTION"
      desc = "Fax resolution"
      default_choice = "high"
      choice "low" {
         value = "-l"
         desc = "Low"
         help = "Low resolution on a fax is 96lpi."         
      }
      choice "high" {
         value = ""
         desc = "High"
         help = "High resolution on a fax is 192lpi."         
      }
   }

   # If you don't specify a phone number the job just fails, and 
   # the only way to figure this out is to look at the error message
   # at the bottom of the job details.  Hmm.
   send_exec { 
     if [ "x$PHONE_NUMBER" != "x" ] 
     then
          fax send $RESOLUTION $PHONE_NUMBER $INPUT
     else 
          echo 'You must specify a phone number!'
          false
     fi
   }
}
]]>
</Programlisting>

    </Para>
   </Sect3>
  </Sect2>

  <Sect2 id="fax-via-email">
   <Title>Using the Remote Printing Service</Title>

   <Para>
    There is an experimental service offered that lets you send an
    email message containing something you'd like printed such that it
    will appear on a fax machine elsewhere.  Nice formats like
    postscript are supported, so even though global coverage is
    spotty, this can still be a very useful service.  For more
    information on printing via the remote printing service, see the
    <ULink URL="http://www.tpc.int/" >Remote Printing WWW Site</ULink
    >.
   </Para>
  </Sect2>

  <Sect2 id="fax-via-web">
   <Title>Commercial Faxing Services</Title>
   <Para>
    A number of companies operate web-based faxing services.  <ulink
    url="http://www.efax.com/">EFax</ulink>, in particular, offers
    free inbound faxes (to your own dedicated fax number, no less) via
    email, and fax transmission for a fee.  Other companies offer
    similar services.
   </Para>
  </Sect2>

 </Sect1>

 <Sect1 id="authoring">
  <Title>How to generate something worth printing.</Title>

  <Para>
   Here we get into a real rat's-nest of software.  Basically, Linux
   can run many types of binaries with varying degrees of success:
   Linux/x86, Linux/Alpha, Linux/Sparc, Linux/foo, iBCS, Win16/Win32s
   (with dosemu and, someday, with Wine), Mac/68k (with Executor), and
   Java.  I'll just discuss native Linux and common Unix software.
  </Para>

  <Sect2 id="markup-languages">
   <Title>Markup languages</Title>

   <Para>
    Most markup languages are more suitable for large or repetitive
    projects, where you want the computer to control the layout of the
    text to make things uniform.
    <VariableList>
     <VarListEntry>
      <Term><command>nroff</command></Term>
      <ListItem>
       <Para>This was one of the first Unix markup languages.  Man pages
        are the most common examples of things formatted in *roff
        macros; many people swear by them, but nroff has, to me at
        least, a more arcane syntax than needed (see <xref
        linkend="roff-example">), and probably makes a poor choice for
        new works.  It is worth knowing, though, that you can typeset
        a man page directly into postscript with groff.  Most man
        commands will do this for you with <command>man -t foo
        &verbar; lpr</command>.
       </Para>

       <figure id="roff-example">
        <title>Example of <command>roff</command> Input</title>
<programlisting>
<![CDATA[
.B man
is the system's manual pager. Each
.I page
argument given to 
.B man
is normally the name of a program, utility or function. 
The 
.I manual page 
associated with each of these arguments is then found and
displayed. A 
.IR section ,
if provided, will direct
.B man
to look 
only in that
.I section
of the manual.
]]>
</programlisting>
       </figure>

      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>TeX</Term>
      <ListItem>
       <Para>TeX, and the macro package LaTeX, are one of the most widely
        used markup languages on Unix.  Technical works are frequently
        written in LaTeX because it greatly simplifies the layout
        issues and is <Emphasis>still</Emphasis> one of the few text
        processing systems to support mathematics both completely and
        well.  TeX's output format is <filename>dvi</filename>, and is
        converted to PostScript or Hewlett Packard's PCL with
        <command>dvips</command> or <command>dvilj</command>.  If you
        wish to install TeX or LaTeX, install the whole teTeX group of
        packages; it contains everything.  Recent TeX installations
        include pdfTeX and pdfLaTeX, which produce Adobe PDF files
        directly.  Commands are available do create hyperlinks and
        navigation features in the PDF file.
       </Para>

       <figure id="latex-example">
        <title>Example of LaTeX Input</title>
<programlisting>
<![CDATA[
\subsubsection{NAT}

  Each real server is assigned a different IP address, and the NA
  implements address translation for all inbound and outbound
  packets.

  \begin{description}
  \item[Advantage] Implementation simplicity, especially if we
        already implement other NAT capabilities.

  \item[Disadvantage] Return traffic from the server goes through
        address translation, which may incur a speed penalty.  This
        probably isn't too bad if we design for it from the
        beginning.

  \item[Disadvantage] NAT breaks the end-to-end semantics of normal
        internet traffic.  Protocols like ftp, H.323, etc would
        require special support involving snooping and in-stream
        rewriting, or complete protocol proxying; neither is likely
        to be practical.
  \end{description}
]]>
</programlisting>
       </figure>


      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>SGML</Term>
      <ListItem>
       <Para>There is at least one free SGML parser available for Unix and
        Linux; it forms the basis of Linuxdoc-SGML's homegrown
        document system.  It can support other DTD's, as well, most
        notably DocBook.  This document is written in DocBook-DTD
        SGML; see <xref linkend="sgml-example"> for an example.
       </Para>

       <figure id="sgml-example">
        <title>Example of DocBook SGML</title>
<programlisting>
<![CDATA[
<VarListEntry>
 <Term>SGML</Term>
 <ListItem>
  <Para>
   There is at least one free SGML parser available for Unix 
   and Linux; it forms the basis of Linuxdoc-SGML's homegrown 
   document system.  It can support other DTD's, as well, most
   notably DocBook.  This document is written in DocBook-DTD 
   SGML.
  </Para>
 </ListItem>
</VarListEntry>
]]>
</programlisting>
       </figure>

      </ListItem>
     </VarListEntry>

    </VariableList>
   </Para>
  </Sect2>

  <Sect2 id="wysiwyg-processors">
   <Title>WYSIWYG Word Processors</Title>

   <Para>
    There is no shortage of WYSIWYG word processing software.  Several
    complete office suites are available, including one that's free
    for personal use (StarOffice).
    <VariableList>
     <VarListEntry>
      <Term>StarOffice</Term>
      <ListItem>
       <Para>Sun Microsystems is distributing StarOffice on the net free
        for Linux.  This full-blown office suite has all the features
        you'd expect, including both import and export of Microsoft
        Office file formats (including Word documents).  There's a
        mini-HOWTO out there which describes how to obtain and install
        it.  It generates PostScript, so should work with most any
        printer that works otherwise on Linux.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>WordPerfect</Term>
      <ListItem>
       <Para>Corel distributes a basic version of WordPerfect 8 free for
        Linux, and sells various packages of Word Perfect Office 2000
        (which includes WordPerfect, Corel Draw and Quattro Pro
        Versions 9).  The <ULink
        URL="http://www.rodsbooks.com/wpfonts/" > Linux WordPerfect
        Fonts and Printers</ULink > page has information about
        configuring WordPerfect for use with either Ghostscript or its
        built-in printer drivers (which are apparently identical the
        DOS WordPerfect drivers, if your printer's driver isn't
        included in the distribution).
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>Applix</Term>
      <ListItem>
       <Para>Applix is a cross-platform (ie, various Unices, Windows, and
        others) office suite sold by the Applix company.  Red Hat and
        SuSE sold it themselves when it was the only game in town;
        now sales have reverted to Applix.  This is the only native
        Unix-style application suite; it probably fits in better with
        the Unix way of doign things.
       </Para>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>AbiWord</Term>
      <ListItem>
       <Para><ulink url="http://www.abisource.com/">AbiWord</ulink> is one
        of several GPL WYSIWYG word processor projects; this one has
        produced a very nice word processor based on an XML format.
        It is capable of Word file import.  AbiWord is still a work in
        progress, although it is useful for small things now.
       </Para>
       <figure>
	<title>AbiWord</title>
	<graphic fileref="snapshot-abiword" scale="60"></graphic>
       </figure>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>LyX</Term>
      <ListItem>
       <Para>LyX is a front-end to LaTeX which looks very promising.  See
        the <ULink URL="http://www.lyx.org/" >LyX Homepage</ULink >
        for more information.  There is a KDE-styled version of LyX,
        called Klyx; the author of LyX and the instigator of KDE are
        the same person.
       </Para>
       <figure>
	<title>LyX</title>
	<graphic fileref="snapshot-lyx" scale="60"></graphic>
       </figure>
      </ListItem>
     </VarListEntry>

     <VarListEntry>
      <Term>Maxwell</Term>
      <ListItem>
       <Para>Maxwell is a simple MS RTF-format based word processor which
        started as a commercial product but is now distributed under
        the GPL.
       </Para>
      </ListItem>
     </VarListEntry>

    </VariableList>
   </Para>

   <Para>
    Other vendors should feel free to drop me a line with your offerings.
   </Para>
  </Sect2>
 </Sect1>

 <Sect1 id="photos">
  <Title>Printing Photographs</Title>

  <indexterm>
   <primary>photograph</primary>
   <secondary>tips</secondary>
  </indexterm>

  <Para>
   There are many details to getting decent photo output from common
   printers.  If you haven't bought a photo printer yet, see the
   photo-related tips in <xref linkend="shopping">.
  </Para>

  <Sect2 id="gs-photos-tips-and-tricks">
   <indexterm><primary>Ghostscript</primary>
              <secondary>photographs</secondary></indexterm>
   <indexterm><primary>photograph</primary>
              <secondary>Ghostscript</secondary></indexterm>

   <Title>Ghostscript and Photos</Title>

   <Para>
    Ghostscript has some difficulties rendering color photographs
    through most drivers.  The problems are several:
    <ItemizedList>
     <ListItem>
      <Para>Many drivers have poorly tuned color support.  Often the
       colors don't match the Windows driver output or the screen.
       OTOH, all drivers, and Ghostscript as a whole, have readily
       adjustable color support; the "Gamma" settings (see
       <xref linkend="gsgamma">) are one thing
       to play with, and there are others documented in Ghostscript's
       <filename>Use.htm</filename> documentation file.
      </Para>
     </ListItem>

     <ListItem>
      <Para>I'm only aware of one Ghostscript driver with support for 6
       and 7 color printing; it's in beta at the moment and supports
       most Epson Stylus Photo models.  It is rumoured to produce
       better color than the Windows driver (!).  The Ghostscript
       driver core itself provides no support for non CMYK or RGB
       colors; arguably, some work to put that there is needed.
      </Para>
     </ListItem>

     <ListItem>
      <Para>Ghostscript often ends up dithering coarsely, or generating
       printouts with artifacts like banding.  The dithering can
       usually be corrected; see <xref linkend="gscolor">, and read
       the documentation for your driver.
      </Para>
     </ListItem>
    </ItemizedList>
    You should be able to correct some of these problems by tuning
    Ghostscript; see <xref linkend="ghostscript"> for more
    information on how to do this.  Fiddling with Ghostscript options
    is much easier if you declare them as options in your spooling system.
   </Para>

   <Para>
    That said, the obvious solution for now is to use non-Ghostscript
    software for printing photos, and indeed, such things do exist.
    The main contender is the print plugin in the Gimp, which supports
    pixel-for-pixel printing on Epson Styluses and Postscript printers
    (with basic PPD support).  That Epson Stylus portion of that
    driver is available for Ghostcript, as well, as the
    <command>stp</command> driver.  Also possible to use for this
    purpose are the assorted external pnm-to-foo programs used to
    print on printers like the cheap Lexmarks; these print attempt to
    print pixmaps pixel-for-pixel.
   </Para>

   <Para>
    The best solution, of course, is to buy a Postscript printer;
    such printers can usually be completely controlled from available
    free software, and will print to the full capability of the
    printer.
   </Para>
  </Sect2>

  <Sect2 id="paper-for-inkjets">
   <indexterm><primary>paper</primary>
              <secondary>quality</secondary></indexterm>
   <Title>Paper</Title>

   <Para>
    Color inkjets are extremely dependent on the paper for good
    output.  The expensive glossy coated inkjet papers will allow you
    to produce near-photographic output, while plain uncoated paper
    will often produce muddy colors and fuzzy details.  Nonglossy
    coated inkjet papers will produce results in between, and are
    probably best for final prints of text, as well.  Stiffer glossy
    coated "photo" papers will produce similar output to
    lighter-weight glossy papers, but will feel like a regular photo.
   </Para>
  </Sect2>

  <Sect2 id="photo-printer-settings">
   <Title>Printer Settings</Title>

   <Para>
    For photo output on most color inkjets, you should use the most
    highly interlaced (and slowest) print mode; otherwise solid
    regions may have banding or weak colors.  Generally with
    Ghostscript this is what will happen when you pick the highest
    resolution.  With Postscript printers, you may need to add a
    snippet to the prologue based on the settings available in the PPD
    file.  The Gimp's PPD support doesn't include (printer-specific)
    print quality settings, but I added one in an ugly way for my own
    use; contact me if you'd like that.  If you use PDQ or CUPS, you
    can easily control all the printer settings you need.  VA Linux's
    <command>libppd</command> and the GPR front-end can also add these
    options for Postscript printers.
   </Para>
  </Sect2>

  <Sect2 id="inkjet-archiving">
   <indexterm><primary>archiving</primary>
              <secondary>print durability</secondary></indexterm>
   <Title>Print Durability</Title>

   <Para>
    Color inkjet printouts usually fade after a few years, especially
    if exposed to lots of light and air; this is a function of the
    ink.  Printers with ink-only consumables like the Epsons and
    Canons can buy archival inks, which are less prone to this
    problem.  Newer printers often use pigment-based inks, which
    don't fade as much as the older dye-based ink did.  No inkjet
    output is really particularly good for long-term archival use.
    Write the bits to a CD-R and store that instead.
   </Para>
  </Sect2>

  <Sect2 id="commercial-photo-printing-software">
   <indexterm><primary>photograph</primary>
              <secondary>commercial software</secondary></indexterm>
   <Title>Shareware and Commercial Software</Title>

   <Para>
    There's a program called <ULink
    URL="http://home.t-online.de/home/jj.sarton/startE.htm"
    >xwtools</ULink > which supports photo printing with all the
    bells and whistles on an assortment of Epson, HP, and Canon
    printers.  Unfortunately, it was written under NDA, so comes
    without source.  Unless you use it for the Epson Stylus Color 300
    on Linux x86, it costs E15 for personal use; commercial pricing
    is unknown.
   </Para>

   <Para>
    The ESP Print Pro package from Easy Software supports some
    printers which might otherwise be unsupported.  These drivers are
    not reported to be very well-tuned for photos, but they do work.
   </Para>
  </Sect2>
 </Sect1>

 <Sect1 id="previewing">
  <indexterm><primary>previewing</primary></indexterm>
  <Title>On-screen previewing of printable things.</Title>

  <Para>
   Nearly anything you can print can be viewed on the screen, too.
  </Para>

  <Sect2 id="previewing-with-ghostscript">
   <indexterm><primary>Ghostscript</primary>
              <secondary>previewing</secondary></indexterm>
   <indexterm><primary>previewing</primary>
              <secondary>Postscript</secondary></indexterm>
   <indexterm><primary>Postscript</primary>
              <secondary>previewing</secondary></indexterm>
   <Title>PostScript</Title>

   <Para>
    Ghostscript has an X11 driver best used under the management of
    the PostScript previewer <ULink
    URL="http://wwwthep.physik.uni-mainz.de/~plass/gv/" >gv</ULink >.
    The latest versions of these programs should be able to view PDF
    files, as well.  Note that gv has replaced the older previewer
    "Ghostview"; the new user interface is mch prettier and featureful
    that ghostview's plain old Athena GUI.
   </Para>

   <figure>
    <title>Gv</title>
    <graphic fileref="snapshot-gv" scale="60"></graphic>
   </figure>

  </Sect2>

  <Sect2 id="previewing-tex-dvi">
   <Title>TeX dvi</Title>

   <Para>
    TeX DeVice Independent files may be previewed under X11 with
    <ULink URL="http://www.linuxprinting.org/man/xdvi.1.html"
    >xdvi</ULink >.  Modern versions of xdvi call ghostscript to
    render PostScript specials.
   </Para>

   <Para>
    A VT100 driver exists as well.  It's called <Literal
    remap="tt">dgvt</Literal>.  <Literal remap="tt">Tmview</Literal>
    works with Linux and svgalib, if that's all you can do.
   </Para>
  </Sect2>

  <Sect2 id="pdf-previewing">
   <indexterm><primary>Ghostscript</primary>
              <secondary>previewing</secondary></indexterm>
   <indexterm><primary>previewing</primary>
              <secondary>PDF</secondary></indexterm>
   <indexterm><primary>PDF</primary>
              <secondary>previewing</secondary></indexterm>
   <Title>Adobe PDF</Title>

   <Para>
    Adobe's Acrobat Reader is available for Linux; just download it
    from the <ULink URL="http://www.adobe.com/">Adobe web site</ULink>.
   </Para>

   <Para>
    You can also use xpdf, which is free software, and I believe
    <command>gv</command> supports viewing PDF files with gs under X11.
   </Para>
  </Sect2>
 </Sect1>

 <Sect1 id="serial">
  <indexterm>
   <primary>ports</primary>
   <secondary>serial</secondary>
  </indexterm>
  <Title>Serial printers under lpd</Title>

  <Para>
   Serial printers are rather tricky under lpd.
  </Para>

  <Sect2 id="serial-printcap">
   <Title>Setting up in printcap</Title>

   <Para>
    Lpd provides five attributes which you can set in
    <Emphasis>/etc/printcap</Emphasis> to control all the settings of
    the serial port a printer is on.  Read the <Emphasis><ULink
    URL="http://www.linuxprinting.org/man/printcap.5.html"
    >printcap</ULink ></Emphasis> man page and note the meanings of
    <Emphasis>br&num;</Emphasis>, <Emphasis>fc&num;</Emphasis>,
    <Emphasis>xc&num;</Emphasis>, <Emphasis>fs&num;</Emphasis> and
    <Emphasis>xs&num;</Emphasis>.  The last four of these attributes
    are bitmaps indicating the settings for use the port.  The
    <Emphasis>br&num;</Emphasis> atrribute is simply the baud rate, ie
    `<Literal remap="tt">br&num;9600</Literal>'.
   </Para>

   <Para>
    It is very easy to translate from <ULink
    URL="http://www.linuxprinting.org/man/stty.1.html"
    >stty</ULink > settings to printcap flag settings. If you need to,
    see the man page for stty now.
   </Para>

   <Para>
    Use stty to set up the printer port so that you can cat a file to
    it and have it print correctly. Here's what `<Emphasis>stty
    -a</Emphasis>' looks like for my printer port:

<Screen>
dina:/usr/users/andy/work/lpd/lpd# stty -a &#60; /dev/ttyS2
speed 9600 baud; rows 0; columns 0; line = 0;
intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = &#60;undef&#62;;
eol2 = &#60;undef&#62;; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W;
lnext = ^V; min = 1; time = 0;
-parenb -parodd cs8 hupcl -cstopb cread -clocal -crtscts
-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr 
-igncr -icrnl ixon -ixoff -iuclc -ixany -imaxbel
-opost -olcuc -ocrnl -onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 
bs0 vt0 ff0
-isig -icanon -iexten -echo -echoe -echok -echonl -noflsh -xcase
-tostop -echoprt -echoctl -echoke
</Screen>

    The only changes between this and the way the port is initialized
    at bootup are <Literal remap="tt">-clocal</Literal>, <Literal
    remap="tt">-crtscts</Literal>, and <Literal
    remap="tt">ixon</Literal>. Your port may well be different
    depending on how your printer does flow control.
   </Para>

   <Para>
    You actually use stty in a somewhat odd way.  Since stty operates
    on the terminal connected to it's standard input, you use it to
    manipulate a given serial port by using the `<Literal
    remap="tt">&lt;</Literal>' character as above.
   </Para>

   <Para>
    Once you have your stty settings right, so that `<Emphasis>cat
    file &#62; /dev/ttyS2</Emphasis>' (in my case) sends the file to
    the printer, look at the file
    /usr/src/linux/include/asm-i386/termbits.h. This contains a lot of
    &num;defines and a few structs (You may wish to cat this file to
    the printer (you do have that working, right?) and use it as
    scratch paper).  Go to the section that starts out
   </Para>

   <Para>
<Screen>
/* c_cflag bit meaning */
#define CBAUD   0000017
</Screen>

    This section lists the meaning of the <Emphasis>fc&num;</Emphasis>
    and <Emphasis>fs&num;</Emphasis> bits. You will notice that the
    names there (after the baud rates) match up with one of the lines
    of stty output. Didn't I say this was going to be easy?
   </Para>

   <Para>
    Note which of those settings are preceded with a - in your stty
    output. Sum up all those numbers (they are octal). This represents
    the bits you want to clear, so the result is your
    <Emphasis>fc&num;</Emphasis> capability.  Of course, remember that
    you will be setting bits directly after you clear, so you can just
    use `<Literal remap="tt">fc&num;0177777</Literal>' (I do).
   </Para>

   <Para>
    Now do the same for those settings (listed in this section) which
    do not have a - before them in your stty output. In my example the
    important ones are CS8 (0000060), HUPCL (0002000), and CREAD
    (0000200). Also note the flags for your baud rate (mine is
    0000015). Add those all up, and in my example you get
    0002275. This goes in your <Emphasis>fs&num;</Emphasis> capability
    (`<Literal remap="tt">fs&num;02275</Literal>' works fine in my
    example).
   </Para>

   <Para>
    Do the same with set and clear for the next section of the include
    file, "c&lowbar;lflag bits". In my case I didn't have to set
    anything, so I just use `<Literal
    remap="tt">xc&num;0157777</Literal>' and `<Literal
    remap="tt">xs&num;0</Literal>'.
   </Para>
  </Sect2>

  <Sect2>
   <Title>Older serial printers that drop characters</Title>

   <Para>
    Jon Luckey points out that some older serial printers with
    ten-cent serial interfaces and small buffers
    <Emphasis>really</Emphasis> mean stop when they say so with flow
    control.  He found that disabling the FIFO in his Linux box's
    16550 serial port with <Literal remap="tt"><ULink
    URL="http://www.linuxprinting.org/man/setserial.8.html"
    >setserial</ULink ></Literal> corrected the problem of dropped
    characters (you apparently just specify the uart type as an 8250
    to do this).
   </Para>
  </Sect2>
 </Sect1>

 <sect1 id="development">
  <Title>What's missing?</Title>

  <para>
   Many of the parts for a complete printing system do not exist yet.
   Projects are underway to address most of these, although most have
   not yet produced running useful code, and efforts to standardize
   the necessary protocols and APIs are in their infancy.
  </para>
 
  <simplesect>
   <title>Plumbing</title>

   <Para>
    There's a general problem with getting all the parts to talk to
    one another; especially in a spooler-independent way.  This
    problem manifests itself most noticably in the pathetic
    application support for control over all the "usual" printing
    features.  There is simply no way for an application writer to get
    information about printers, jobs, etc; no standardized way to
    submit jobs; no good way to get job status back; nor even really a
    standardized way to generate print data (although most of the new
    desktop systems offer desktop-specific facilities for doing this).
   </Para>

   <Para>
    Work to define a sensible API for applications to use for printing
    will undoubtedly center around Corel's sysAPS library, which
    provides a rudimentary implementation of several queueing and
    printer information features.
   </Para>
  </simplesect>

  <simplesect>
   <title>Fonts</title>
   <para>
    Font handling on free systems is rather awkward.  The display, the
    printer, the application, and the data files should ideally all
    have access to the same fonts.  Unfortunately this is simply not
    the case.  Plans are afoot to remove font handling from the X
    server, simplifying part of the problem, but good printer font to
    application font mapping is still a problem.  No project really
    seems to be underway to address this; currently application
    writers simply embed their own fonts into printed data.
   </para>
  </simplesect>

  <simplesect>
   <title>Metadata</title>
   <para>
    Applications or spoolers need to learn about printer and driver
    properties somehow.  The current standardized scheme, implemented
    on Windows, the Mac, and in CUPS, is to use Postscript Printer
    Description files to drive a programatic interface and user
    interface.  This had trouble for non-Postscript printers, for
    obvious reasons, so the IEEE's Printer Working Group has a project
    to specify "Universal Printer Driver Format", or UPDF, files.
    Thus far they have constructed a sample file in an XML format.
    The sample file strongly resembles a PPD file, and is missing all
    sorts of driver and platform specific information; so much so that
    UPDF is currently not useful.  IBM has a fully parameterized
    driver architecture for OS/2 which is available as free software;
    once this is released it is bound to be a useful source of ideas
    or code, and possibly a good enough system to just use outright.
    Even this system, however, provides no defined mechanism for
    communicating interesting properties from the driver space up to
    the application.  Some XML format, and/or an API for fetching
    assorted properties, is bound to appear at some point.
   </para>
  </simplesect>

  <simplesect>
   <title>Drivers</title>
   <para>
    The state of free software drivers is rather poor.  Fortunately,
    several projects are underway to correct this, and impressive
    results can now be had on printers using that code.  The eventual
    goal seems to be to provide both good drivers and a good framework
    for the frequently duplicated (and hard!) parts of driver
    code&mdash;dithering, for example&mdash;to be shared.  
   </para>

   <para>
    Printer vendor cooperation will be an important part of achieving
    this goal.  Vendors currently do not provide the minimum
    documentation necessary to operate their devices well.  At the
    Printing Summit 2000, many vendors were present, and some small
    headway was made on this point.  Vendors are mainly concerned with
    keeping the dithering and related algorithms secret; these
    software components are what produces such remarkable inkjet
    output, and the vendors are of course competing.  Those vendors
    present at the summit should now have a clearer picture of how
    free software works and what we want from them.  This isn't much;
    bt it sets the stage for future progress.
   </para>
  </simplesect>

 </sect1>

 <Sect1 id="credits">
  <Title>Credits</Title>

  <Para>
   Special thanks to Jacob Langford, author of <Literal
   remap="tt">pdq</Literal>, who finally gave us something better than
   the smattering of scripts globbed onto a 20 year old overgrown
   line-printer control program.
  </Para>

  <Para>
   The <Literal remap="tt">smbprint</Literal> information is from an
   article by Marcel Roelofs <Literal
   remap="tt">&lt;marcel@paragon.nl&#62;</Literal>.
  </Para>

  <Para>
   The <Literal remap="tt">nprint</Literal> information for using
   Netware printers was provided by Michael Smith <Literal
   remap="tt">&lt;mikes@bioch.ox.ac.uk&#62;</Literal>.
  </Para>

  <Para>
   The serial printers under lpd section is from Andrew Tefft <Literal
   remap="tt">&lt;teffta@engr.dnet.ge.com&#62;</Literal>.
  </Para>

  <Para>
   The blurb about gammas and such for gs was sent in by Andreas
   <Literal remap="tt">&lt;quasi@hub-fue.franken.de&#62;</Literal>.
  </Para>

  <Para>
   The two paragraphs about the 30 second closing&lowbar;wait of the
   serial driver was contributed by Chris Johnson <Literal
   remap="tt">&lt;cdj@netcom.com&#62;</Literal>.
  </Para>

  <Para>
   Robert Hart sent a few excellent paragraphs about setting up a print
   server to networked HPs which I used verbatim.
  </Para>

  <Para>
   And special thanks to the dozens upon dozens of you who've pointed
   out typos, bad urls, and errors in the document over the years.
  </Para>
 </Sect1>

&phtindex;

</Article>
