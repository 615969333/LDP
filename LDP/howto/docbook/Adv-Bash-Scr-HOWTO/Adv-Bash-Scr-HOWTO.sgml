<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V3.1//EN" [
<!--
Uncomment line below to generate index.
-->
<!--
<!ENTITY indice SYSTEM "indice.sgml">
-->
<!ENTITY ex1 SYSTEM "ex1.sh">
<!ENTITY ex2 SYSTEM "ex2.sh">
<!ENTITY ex3 SYSTEM "ex3.sh">
<!ENTITY ex4 SYSTEM "ex4.sh">
<!ENTITY ex5 SYSTEM "ex5.sh">
<!ENTITY ex6 SYSTEM "ex6.sh">
<!ENTITY ex7 SYSTEM "ex7.sh">
<!ENTITY ex8 SYSTEM "ex8.sh">
<!ENTITY ex9 SYSTEM "ex9.sh">
<!ENTITY ex10 SYSTEM "ex10.sh">
<!ENTITY ex11 SYSTEM "ex11.sh">
<!ENTITY ex12 SYSTEM "ex12.sh">
<!ENTITY ex13 SYSTEM "ex13.sh">
<!ENTITY ex14 SYSTEM "ex14.sh">
<!ENTITY ex15 SYSTEM "ex15.sh">
<!ENTITY ex16 SYSTEM "ex16.sh">
<!ENTITY ex17 SYSTEM "ex17.sh">
<!ENTITY ex18 SYSTEM "ex18.sh">
<!ENTITY ex19 SYSTEM "ex19.sh">
<!ENTITY ex20 SYSTEM "ex20.sh">
<!ENTITY ex21 SYSTEM "ex21.sh">
<!ENTITY ex22 SYSTEM "ex22.sh">
<!ENTITY ex22a SYSTEM "ex22a.sh">
<!ENTITY ex23 SYSTEM "ex23.sh">
<!ENTITY ex24 SYSTEM "ex24.sh">
<!ENTITY ex25 SYSTEM "ex25.sh">
<!ENTITY ex26 SYSTEM "ex26.sh">
<!ENTITY ex26a SYSTEM "ex26a.sh">
<!ENTITY ex27 SYSTEM "ex27.sh">
<!ENTITY ex28 SYSTEM "ex28.sh">
<!ENTITY ex29 SYSTEM "ex29.sh">
<!ENTITY ex30 SYSTEM "ex30.sh">
<!ENTITY ex31 SYSTEM "ex31.sh">
<!ENTITY ex32 SYSTEM "ex32.sh">
<!ENTITY ex33 SYSTEM "ex33.sh">
<!ENTITY ex34 SYSTEM "ex34.sh">
<!ENTITY ex35 SYSTEM "ex35.sh">
<!ENTITY ex36 SYSTEM "ex36.sh">
<!ENTITY ex37 SYSTEM "ex37.sh">
<!ENTITY ex38 SYSTEM "ex38.sh">
<!ENTITY ex38bis SYSTEM "data-file">
<!ENTITY ex39 SYSTEM "ex39.sh">
<!ENTITY ex40 SYSTEM "ex40.sh">
<!ENTITY ex41 SYSTEM "ex41.sh">
<!ENTITY ex42 SYSTEM "ex42.sh">
<!ENTITY ex43 SYSTEM "ex43.sh">
<!ENTITY ex44 SYSTEM "ex44.sh">
<!ENTITY ex45 SYSTEM "ex45.sh">
<!ENTITY ex46 SYSTEM "ex46.sh">
<!ENTITY ex47 SYSTEM "ex47.sh">
<!ENTITY ex48 SYSTEM "ex48.sh">
<!ENTITY ex49 SYSTEM "ex49.sh">
<!ENTITY ex50 SYSTEM "ex50.sh">
<!ENTITY ex51 SYSTEM "ex51.sh">
<!ENTITY ex52 SYSTEM "ex52.sh">
<!ENTITY ex53 SYSTEM "ex53.sh">
<!ENTITY ex54 SYSTEM "ex54.sh">
<!ENTITY ex55 SYSTEM "ex55.sh">
<!ENTITY ex56 SYSTEM "ex56.sh">
<!ENTITY ex57 SYSTEM "ex57.sh">
<!ENTITY ex58 SYSTEM "ex58.sh">
<!ENTITY ex59 SYSTEM "ex59.sh">
<!ENTITY ex60 SYSTEM "ex60.sh">
<!ENTITY ex61 SYSTEM "ex61.sh">
<!ENTITY ex62 SYSTEM "ex62.sh">
<!ENTITY ex63 SYSTEM "ex63.sh">
<!ENTITY ex64 SYSTEM "ex64.sh">
<!ENTITY ex65 SYSTEM "ex65.sh">
<!ENTITY ex66 SYSTEM "ex66.sh">
<!ENTITY ex67 SYSTEM "ex67.sh">
<!ENTITY ex68 SYSTEM "ex68.sh">
<!ENTITY ex69 SYSTEM "ex69.sh">
<!ENTITY ex70 SYSTEM "ex70.sh">
<!ENTITY ex71 SYSTEM "ex71.sh">
<!ENTITY ex72 SYSTEM "ex72.sh">
<!ENTITY ex73 SYSTEM "ex73.sh">
<!ENTITY ex74 SYSTEM "ex74.sh">
<!ENTITY ex75 SYSTEM "ex75.sh">
<!ENTITY ex76 SYSTEM "ex76.sh">
<!ENTITY ex77 SYSTEM "ex77.sh">
<!ENTITY ex78 SYSTEM "ex78.sh">
<!ENTITY ex79 SYSTEM "ex79.sh">
<!ENTITY andor SYSTEM "and-or.sh">
<!ENTITY lnum SYSTEM "line-number.sh">
<!ENTITY manview SYSTEM "manview.sh">
<!ENTITY rfe SYSTEM "rfe.sh">
<!ENTITY behead SYSTEM "behead.sh">
<!ENTITY ftpget SYSTEM "ftpget.sh">
<!ENTITY encryptedpw SYSTEM "encryptedpw.sh">
<!ENTITY rpmcheck SYSTEM "rpm-check.sh">
<!ENTITY subshell SYSTEM "subshell.sh">
<!ENTITY lowercase SYSTEM "lowercase.sh">
<!ENTITY online SYSTEM "online.sh">
<!ENTITY reply SYSTEM "reply.sh">
<!ENTITY seconds SYSTEM "seconds.sh">
<!ENTITY numbers SYSTEM "numbers.sh">
<!ENTITY indref SYSTEM "ind-ref.sh">
<!ENTITY bubble SYSTEM "bubble.sh">
<!ENTITY paramsub SYSTEM "param-sub.sh">
<!ENTITY restricted SYSTEM "restricted.sh">
<!ENTITY pw SYSTEM "pw.sh">
<!ENTITY rn SYSTEM "rn.sh">
<!ENTITY coltotaler SYSTEM "col-totaler.sh">
<!ENTITY tmdin SYSTEM "timed-input.sh">
<!ENTITY fifo SYSTEM "fifo.sh">
<!ENTITY tree SYSTEM "tree.sh">
<!ENTITY secretpw SYSTEM "secret-pw.sh">
<!ENTITY stripc SYSTEM "strip-comments.sh">
<!ENTITY al SYSTEM "alias.sh">
<!ENTITY unal SYSTEM "unalias.sh">
<!ENTITY redir1 SYSTEM "redir1.sh">
<!ENTITY redir2 SYSTEM "redir2.sh">
<!ENTITY redir3 SYSTEM "redir3.sh">
<!ENTITY redir4 SYSTEM "redir4.sh">
<!ENTITY redir5 SYSTEM "redir5.sh">
<!ENTITY wipedir SYSTEM "wipedir.sh">
<!ENTITY grp SYSTEM "grp.sh">
<!ENTITY killprocess SYSTEM "kill-process.sh">
<!ENTITY strtest SYSTEM "str-test.sh">
<!ENTITY col SYSTEM "col.sh">
<!ENTITY lookup SYSTEM "lookup.sh">
<!ENTITY arglist SYSTEM "arglist.sh">
<!ENTITY rot13 SYSTEM "rot13.sh">
<!ENTITY bashrc SYSTEM "bashrc">
]>
<!-- 
<article>
  <artheader>
    <title>Advanced Bash-Scripting HOWTO</title>
    <subtitle>A guide to shell scripting, using Bash</subtitle>
    <author>
      <firstname>Mendel</firstname>
      <surname>Cooper</surname>
      <affiliation>
	<address><email>thegrendel@theriver.com</email></address>
      </affiliation>
    </author>
    <pubdate>v0.1, 14 June 2000</pubdate>
    <abstract><para>This document is both a tutorial and a reference
    to shell scripting. It is essentially a synopsis of a complete book on
    the subject. It is a work in progress. The intention is to add
    supplementary material in future updates to this HOWTO, so that
    it will gradually evolve into an LDP <quote>guide</quote>, i.e.,
    a complete book.</para>
    </abstract>
  </artheader>
  -->
<book>
  <bookinfo>
    <title>Advanced Bash-Scripting HOWTO</title>
    <subtitle>A guide to shell scripting, using Bash</subtitle>
    <author>
      <firstname>Mendel</firstname>
      <surname>Cooper</surname>
      <affiliation>
	<address><email>thegrendel@theriver.com</email></address>
      </affiliation>
    </author>

    <pubdate>v0.3, 11 February 2001</pubdate>


    <revhistory>

      <revision>
        <revnumber>0.1</revnumber>
        <date>14 June 2000</date>
        <authorinitials>mc</authorinitials>
        <revremark>Initial release.</revremark>
      </revision>

      <revision>
        <revnumber>0.2</revnumber>
        <date>30 October 2000</date>
        <authorinitials>mc</authorinitials>
        <revremark>Bugs fixed, plus much additional material and more example
	scripts.</revremark>
      </revision>

      <revision>
        <revnumber>0.3</revnumber>
        <date>11 February 2001</date>
        <authorinitials>mc</authorinitials>
        <revremark>More bugfixes, even more material, more
	scripts</revremark>
      </revision>

    </revhistory>


    <abstract>

      <para>This is a major update on version 0.2. -- more bugs swatted,
	plus much additional material and example scripts added.
	This project has now reached the proportions of an entire book.
	See <filename>NEWS</filename> for a revision history.</para>

      <para>This document is both a tutorial and a reference on shell
	scripting with Bash.  It assumes no previous knowledge of
	scripting or programming, but progresses rapidly toward an
	intermediate/advanced level of instruction.  The exercises and
	heavily-commented examples invite active reader participation.
	Still, it is a work in progress. The intention is to add much
	supplementary material in future updates to this HOWTO, so that
	it will gradually evolve into an LDP <quote>guide</quote>, i.e.,
	a complete book.</para>

      <para>The latest version of this document, as an archived
	<quote>tarball</quote> including both the SGML
	source and rendered HTML, may be downloaded <ulink
	url="http://personal.riverusers.com/~thegrendel/abs-HOWTO-0.3.tar.gz">
	here</ulink> from the author's home site.</para>

    </abstract>
  </bookinfo>
  <chapter id="why-shell">
    <title>Why Shell Programming?</title>
    
    <para>The shell is a command interpreter. It is the insulating layer between
      the operating system kernel and the user. Yet, it is also a fairly
      powerful programming language.  A shell program, called a 
      <firstterm>
	<indexterm>
	  <primary>script</primary>
	</indexterm>
	script
      </firstterm>,
      is an easy-to-use tool for building applications by <quote>gluing</quote> together
      system calls, tools, utilities, and compiled binaries.  Virtually the
      entire repertoire of UNIX commands, utilities, and tools is available for
      invocation by a shell script.  If that were not enough, internal shell
      commands, such as testing and loop constructs, give additional power
      and flexibility to scripts.  Shell scripts lend themselves exceptionally
      well to to administrative system tasks and other routine repetitive jobs
      not requiring the bells and whistles of a full-blown tightly structured
      programming language.</para>
    
    <para>A working knowledge of shell scripting is essential to everyone wishing
      to become reasonably adept at system administration, even if they
      do not anticipate ever having to actually write a script. Consider
      that as a Linux machine boots up, it executes the shell scripts in
      <filename>/etc/rc.d</filename> to restore the system configuration
      and set up services. A detailed understanding of these scripts
      is important for analyzing the behavior of a system, and possibly
      modifying it.</para>

    <para>Writing shell scripts is not hard to learn, since the scripts
      can be built in bite-sized sections and there is only a fairly
      small set of shell-specific operators and options to learn.
      The syntax is simple and straightforward, similar to that of
      invoking and chaining together utilities at the command line, and
      there are only a few <quote>rules</quote> to learn.  Most short
      scripts work right the first time, and debugging even the longer
      ones is straightforward.</para>

    <para>A shell script is a <quote>quick and dirty</quote> method of
      prototyping a complex application.  Getting even a limited subset
      of the functionality to work in a shell script, even if slowly,
      is often a useful first stage in project development. This way,
      the structure of the application can be tested and played with,
      and the major pitfalls found before proceeding to the final coding
      in C, C++, Java, or Perl.</para>

    <para>Shell scripting hearkens back to the classical UNIX philosophy
      of breaking complex projects into simpler subtasks, of chaining
      together components and utilities. Many consider this a better,
      or at least more esthetically pleasing approach to problem solving
      than using one of the new generation of high powered all-in-one
      languages, such as Perl, which attempt to be all things to all
      people, but at the cost of forcing you to alter your thinking
      processes to fit the tool.</para>

    <para>When not to use shell scripts

      <itemizedlist>
	<listitem>
	  <para>resource-intensive tasks, especially where speed is
	    a factor</para>
	</listitem> <listitem>
	  <para>complex applications, where structured programming is
	    a necessity</para>
	</listitem> <listitem>
	  <para>mission-critical applications upon which you are betting the
	    ranch, or the future of the company</para>
	</listitem> <listitem>
	  <para>situations where security is important, where you need to
	    protect against hacking</para>
	</listitem> <listitem>
	  <para>project consists of subcomponents with interlocking
	    dependencies</para>
	</listitem> <listitem>
	  <para>extensive file operations required (Bash is limited to
	    serial file access, and that only in a particularly clumsy
	    and inefficient line-by-line fashion)</para>
	</listitem> <listitem>
	  <para>need to generate or manipulate graphics or GUIs</para>
	</listitem> <listitem>
	  <para>need direct access to system hardware</para>
	</listitem> <listitem>
	  <para>need port or socket I/O</para>
	</listitem> <listitem>
	  <para>need to use libraries or interface with legacy code</para>
	</listitem>
      </itemizedlist></para>

    <para>If any of the above applies, consider a more powerful scripting
      language, perhaps Perl, Tcl, Python, or possibly a high-level
      compiled language such as C, C++, or Java. Even then, prototyping
      the application as a shell script might still be a useful
      development step.</para>

    <para>We will be using Bash, an acronym for <quote>Born-Again
      Shell</quote> and a pun on Stephen Bourne's now classic
      Bourne Shell.  Bash has become the de facto standard
      for shell scripting on all flavors of UNIX. Most of the
      principles dealt with in this document apply equally well
      to scripting with other shells, such as the Korn Shell, from
      which Bash derives some of its features,
     
       <footnote><para>Many of the features of <emphasis>ksh88</emphasis>,
	 not the newer <emphasis>ksh93</emphasis> have been merged into
	 Bash.</para></footnote>

      and the C Shell and its variants.  (Note that C Shell programming
      is not recommended due to certain inherent problems, as pointed
      out in a <ulink
      url="http://www.etext.org/Quartz/computer/unix/csh.harmful.gz">news
      group posting</ulink> by Tom Christiansen in October of 1993).
      </para>

    <para>The following is a tutorial in shell scripting.  It relies
      heavily on examples to illustrate features of the shell.
      As far as possible, the example scripts have been tested, and
      some of them may actually be useful in real life.  The reader
      should use the actual examples in the the source archive
      (<filename>something-or-other.sh</filename>), give them execute
      permission (<userinput>chmod u+x scriptname</userinput>), then
      run them to see what happens.  Should the source archive not
      be available, then cut-and-paste from the HTML, pdf, or text
      rendered versions.  Be aware that some of the scripts below
      introduce features before they are explained, and this may require
      the reader to temporarily skip ahead for enlightenment.</para>

    <para>Unless otherwise noted, the author of this document wrote
      the example scripts that follow.</para>

  </chapter> <!-- Why Shell Programming? -->


  <chapter id="sha-bang">
    <title>Starting Off With a Sha-Bang</title>

    <para>In the simplest case, a script is nothing more than a list of system
      commands stored in a file. At the very least, this saves the
      effort of retyping that particular sequence of commands each time
      it is invoked.</para>

    <example id="ex1">
      <title><command>cleanup</command>: A script to clean up the log
      files in /var/log </title> <programlisting>&ex1;</programlisting>
    </example>

    <para>There is nothing unusual here, just a set of commands that
      could just as easily be invoked one by one from the command line on
      the console or in an xterm. The advantages of placing the commands
      in a script go beyond not having to retype them time and again. The
      script can easily be modified, customized, or generalized for a
      particular application.</para>

    <example id="ex2">
      <title><command>cleanup</command>: An enhanced
      and generalized version of above script.</title>
      <programlisting>&ex2;</programlisting>
    </example>

    <para>Since you may not wish to wipe out the entire system log, this variant of
      the first script keeps the last section of the message log intact. You
      will constantly discover ways of refining previously written scripts
      for increased effectiveness.</para>
    
    <para>The 
      <firstterm><indexterm>
	  <primary>sha-bang</primary>
	</indexterm>
	sha-bang</firstterm> 
      (<token>
	<indexterm>
	  <primary>#!</primary>
	</indexterm>
	#!</token>) at the head of a script
      tells your system that this file 
      is a set of commands to be fed to the command interpreter indicated.
      The <token>#!</token> is actually a two byte 
      <quote>
	<indexterm>
	  <primary>magic number</primary>
	</indexterm>
	magic number</quote>, a special marker that designates an
	executable shell script (<userinput>man magic</userinput> gives
	more info on this fascinating topic). Immediately following
	the <emphasis>sha-bang</emphasis> is a path name. This is the
	path to the program that interprets the commands in the script,
	whether it be a shell, a programming language, or a utility. This
	enables the specific commands and directives embedded in the
	shell or program called.</para>

    <para><programlisting>#!/bin/sh
#!/bin/bash #!/bin/awk #!/usr/bin/perl #!/bin/sed
#!/usr/bin/tcl</programlisting></para>

    <para>Each of the above script header lines calls a different command
      interpreter, be it <filename>/bin/sh</filename>, the default shell
      (<command>bash</command> in a Linux system) or otherwise.  Using
      <userinput>#!/bin/sh</userinput>, the default Bourne Shell in 
      most commercial variants of UNIX, makes the script portable to non-Linux
      machines, though you may have to sacrifice a few bash-specific features
      (the script will conform to the POSIX <command>sh</command> standard).</para>
    
    <para>Note that the path given at the <quote>sha-bang</quote> must be correct, otherwise
      an error message, usually <errorname>Command not found</errorname> will be the
      only result of running the script.</para>
    
    <para><token>#!</token> can be omitted if the script consists only
      of a set of generic system commands, using no internal
      shell directives.  Example 2, above, requires the initial
      <token>#!</token>, since the variable assignment line,
      <userinput>lines=50</userinput>, uses a shell-specific construct.
      Note that <userinput>#!/bin/sh</userinput> invokes the default
      shell interpreter, which defaults to <filename>/bin/bash</filename>
      on a Linux machine.</para>

      <important><para>This tutorial encourages a modular approach
	to constructing a script. Make note of and collect
	<quote>boilerplate</quote> code snippets that might be useful
	in future scripts. Eventually you can build a quite extensive
	library of nifty routines.  As an example, the following script
	prolog tests whether the script has been invoked with the correct
	number of parameters.

	<programlisting>if [ $# -ne Number_of_expected args ]
then
  echo "Usage: `basename $0` whatever"
  exit $WRONG_ARGS
fi</programlisting>
        </para></important>
  

    <sect1 id="invoking">
      <title>Invoking the script</title>
      <para>Having written the script, you can invoke it by <userinput>sh
	scriptname</userinput>, or alternately <userinput>bash
	scriptname</userinput>.  (Not recommended is using <userinput>sh
	&lt;scriptname</userinput>, since this effectively disables
	reading from stdin within the script.)	Much more convenient is
	to make the script itself directly executable by
	<variablelist>
	  <varlistentry>
	    <term>Either:</term> <listitem>
	      <para><userinput>chmod 755 scriptname</userinput> (gives
	      everyone execute permission)</para>
	    </listitem>
	  </varlistentry> <varlistentry>
	    <term>or</term> <listitem>
	      <para><userinput>chmod +x scriptname</userinput> (gives
	      everyone execute permission)</para> <para><userinput>chmod
	      u+x scriptname</userinput> (gives only the
		script owner execute permission)</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </para>

      <para>In this case, you could try calling the script by
      <userinput>./scriptname</userinput>.</para>

      <para>As a final step, after testing and debugging,
      you would likely want to move it to <filename
      class="directory">/usr/local/bin</filename> (as root, of course),
      to make the script available to yourself and all other users as a
      system-wide executable.  The script could then be invoked by simply
      typing <command>scriptname</command> <keycap>[return]</keycap>
      from the command line.</para>
    </sect1> <!-- Invoking the script -->

    <sect1 id="wrapper">
      <title>Shell wrapper, self-executing script</title>
      
      <para>A 
	<command>
	  <indexterm>
	    <primary>sed</primary>
	  </indexterm>
	  <indexterm>
	    <primary>script</primary>
	    <secondary>sed</secondary>
	  </indexterm>
	  sed</command> or 
	<command>
	  <indexterm>
	    <primary>awk</primary>
	  </indexterm>
	  <indexterm>
	    <primary>script</primary>
	    <secondary>awk</secondary>
	  </indexterm>
	  awk</command> script  (see <xref linkend="sedawk">) would
	normally be invoked from the command line by a 
	<userinput>sed -e <replaceable>'commands'</replaceable></userinput> or 
	<userinput>awk -e <replaceable>'commands'</replaceable></userinput>.
	Embedding such a script in a bash script permits calling it more simply,
	and makes it <quote>reusable</quote>. This also enables combining the
	functionality of <command>sed</command> and <command>awk</command>, for
	example piping the output of a set of <command>sed</command> commands to
	<command>awk</command>.  As a saved executable file, you can then
	repeatedly invoke it in its original form or modified, without
	the inconvenience of retyping it on the command line.</para>

      <example id="ex3">
	<title><command>shell wrapper</command></title>
	<programlisting>&ex3;</programlisting>
      </example>
      
      <example id="ex4">
	<title> A slightly more complex <command>shell wrapper</command></title>
	<programlisting>&ex4;</programlisting>
      </example>

      <example id="coltotaler">
	<title> A <command>shell wrapper</command> around an awk script</title>
	<programlisting>&coltotaler;</programlisting>
      </example>


      <para>For those scripts needing a single do-it-all tool, a Swiss army knife,
	there is Perl. Perl combines the capabilities of
	<command>sed</command> and <command>awk</command>, and throws in
	a large subset of <command>C</command>, to boot. It is modular
	and contains support for everything ranging from object-oriented
	programming up to and including the kitchen sink. Short Perl
	scripts can be effectively embedded in shell scripts, and there
	may even be some substance to the claim that Perl can totally
	replace shell scripting (though the author of this HOWTO remains
	skeptical).</para>

      <example id="ex56">
	<title>Perl embedded in a <command>bash</command> script</title>
	<programlisting>&ex56;</programlisting>
      </example>
      
      <formalpara><title>Exercise</title>
	<para>Write a shell script that performs a simple task.</para>
      </formalpara>

    </sect1> <!-- Shell wrapper, self-executing script -->
  </chapter> <!-- Starting Off With a Sha-Bang -->



  <chapter id="tutorial">
    <title>Tutorial / Reference</title>
    <epigraph>
      <attribution>Chet Ramey</attribution>
      <para>...there are dark corners in the Bourne shell, and people use all
      of them.</para>
    </epigraph>
    
    <sect1 id="exit-status">
      <title>exit and exit status</title>
      <para>The 
	<command>
	  <indexterm>
	    <primary>exit</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>exit</secondary>
	  </indexterm>
	  exit
	</command> 
	command may be used to terminate a script, just as in a C program.
	It can also return a value, which is available to the shell.</para>

      <para>Every command returns an 
	<firstterm>
	  <indexterm>
	    <primary>exit status</primary>
	  </indexterm>
	  exit status
	</firstterm> 
	(sometimes referred to as a 
	<firstterm>
	  <indexterm>
	    <primary>return status</primary>
	  </indexterm>
	  return status
	</firstterm>). A successful command returns a
	<errorcode>0</errorcode>, while an unsuccessful one returns a
	<errorcode>non-zero</errorcode> value that usually may be interpreted as
	an error code.</para>

      <para>Likewise, functions within a script and the script itself
      return an exit status. The last command executed in the function
      or script determines the exit status. Within a script, an
      <userinput>exit <replaceable>nn</replaceable></userinput>
      command may be used to deliver an
      <errorcode><replaceable>nn</replaceable></errorcode> exit status to
      the shell (<errorcode><replaceable>nn</replaceable></errorcode>
      must be a decimal number in the <errorcode>0</errorcode> -
      <errorcode>255</errorcode> range).</para>

      <para>
	<varname>
	  <indexterm>
	    <primary>$?</primary>	    
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>	    
	    <secondary>$?</secondary>	    
	  </indexterm>
	  $?</varname> reads the exit status of script or function.</para>

      <example id="ex5">
	<title>exit / exit status</title>
	<programlisting>&ex5;</programlisting>
      </example>

    </sect1> <!-- exit and exit status -->

    <sect1 id="special-chars">
      <title>Special characters used in shell scripts</title>
      <variablelist>
	<varlistentry><term><token>#</token></term>
	  <indexterm>
	    <primary>#</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>#</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>comment</primary>
	  </indexterm>	  
	  <listitem>
	    <formalpara><title>Comments</title>
	      <para>Lines beginning with a <token>#</token> (with the exception
		of <token>#!</token>) are comments.</para>
	    </formalpara>
	    
	    <para><programlisting># This line is a comment.</programlisting></para>

	    <para>Comments may also occur at the end of a command.</para>
	    
	    <para><programlisting>echo "A comment will follow." # Comment here.</programlisting></para>	    

	    <para>Comments may also follow white space at the beginning of a line.</para>
	    <para><programlisting>	# A tab precedes this comment.</programlisting></para>
	    <caution><para>A command may not follow after a comment on the
	      same line. There is no method of terminating the comment,
	      in order for <quote>live code</quote> to begin on the same
	      line. Use a new line for the next command.</para></caution>
	  </listitem>
	</varlistentry>

	<varlistentry><term><token>;</token></term>
	  <indexterm>
	    <primary>;</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>;</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>separator</primary>
	  </indexterm>	  
	  
	  <listitem>
	    <formalpara><title>Command separator</title>
	      <para>Permits putting two or more commands on the same line.</para>
	    </formalpara>

	    <para><programlisting>echo hello; echo there</programlisting></para>
	    
	    <para>Note that the <token>;</token> sometimes needs to be escaped (<token>\</token>).</para>
	    </listitem>
	</varlistentry>


	<varlistentry><term><token>.</token></term>
	  <indexterm>
	    <primary>.</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>.</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>dot command</primary>
	  </indexterm>	  
	  <indexterm>
	    <primary>source</primary>
	  </indexterm>	  

	  <listitem>
	    <formalpara><title><quote>dot</quote> command</title>
	      <para>Equivalent to <token>source</token>, explained further on
	        (see <xref linkend="ex38">).</para>
	    </formalpara>
	  </listitem>
	</varlistentry>


	<varlistentry><term><token>:</token></term>
	  <indexterm>
	    <primary>:</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>:</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>null command</primary>
	  </indexterm>	  
	  <indexterm>
	    <primary>true</primary>
	  </indexterm>	  
	  <indexterm>
	    <primary>endless loop</primary>
	  </indexterm>	  

	  <listitem>
	    <formalpara><title>null command</title>
	      <para>Exit status <errorcode>0</errorcode>, alias for
	      <token>true</token></para>
	    </formalpara>

	    <para>Endless loop:</para>

	    <para><programlisting>
while :
do
   operation-1
   operation-2
   ...
   operation-n
done</programlisting>
	    </para>

	    <para>Placeholder in if/then test:</para>

	    <para><programlisting>
if condition
then :   # Do nothing and branch ahead
else
   take-some-action
fi</programlisting>
	    </para>

	    <para>Provides a placeholder where a binary operation is
	      expected, see <xref linkend="Parameter-Substitution">.</para>

	    <para><programlisting>: ${username=`whoami`}
# ${username=`whoami`}   without the leading : gives an error
            </programlisting></para>

	    <para>Evaluate string of variables using
		<quote>parameter substitution</quote>, see <xref
		linkend="ex6">:</para>

	    <para><programlisting>: ${HOSTNAME?} ${USER?} ${MAIL?}</programlisting>
	    </para>
	    
	    <para>Prints error message if one or more of essential environmental
	      variables not set.</para>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><token>()</token></term>
	  <listitem><formalpara><title>command group</title>
	      <para><programlisting>(a=hello; echo $a)</programlisting></para>
	    </formalpara>
	  <note><para>A listing of commands within
	  <replaceable>parentheses</replaceable> starts a
	  subshell (see <xref linkend="subshells">).</para></note>
	  </listitem>
	</varlistentry>


	<varlistentry><term><token>${}</token></term>
	  <indexterm>
	    <primary>${}</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>${}</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>parameter substitution</primary>
	  </indexterm>	  
	  <listitem>
            <formalpara><title>Parameter substitution</title>
             <para></para></formalpara>
	     <para>See <xref linkend="variables"> for more details.</para>
	  </listitem>

	</varlistentry>  


	<varlistentry>
	  <indexterm>
	    <primary>{xxx,yyy,zzz..}</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>{}</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>brace expansion</primary>
	  </indexterm>	  
	  <term><token>{xxx,yyy,zzz,...}</token></term>
	  <listitem><formalpara><title>Brace expansion</title>
	      <para><programlisting>grep Linux {file?.txt,*.list}
# Finds all instances of the work "Linux"
# in the files "fileA.txt", "file2.txt", "word.list", "vegetable.list", etc.</programlisting></para>
	    </formalpara>
	  <para>A command may act upon a comma-separated list of file specs within
	  <replaceable>braces</replaceable>. Filename expansion (globbing)
	  applies to the file specs between the braces.</para>
	  <warning><para>No spaces allowed within the braces.</para></warning>
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><token>{}</token></term>
	  <indexterm>
	    <primary>{}</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>{}</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>block of code</primary>
	  </indexterm>	  

	  <listitem><formalpara><title>Block of code</title>
	      <para>Also referred to as an <quote>inline group</quote>,
		this construct, in effect, creates an anonymous
		function. Similar to a function, a code block permits
		isolation from the remainder of the script, with its
		own local variables visible only within the scope of
		the block.</para>
	    </formalpara>
	    
	    <para>The code block enclosed in braces may have I/O redirected to
	      and from it. See <xref linkend="io-redirection"> for a detailed
	      discussion of I/O redirection.</para>

	    <example id="ex8">
	      <title>Code blocks and I/O redirection</title>
	      <programlisting>&ex8;</programlisting>
	    </example>

	    <example id="rpmcheck">
	      <title>Saving the results of a code block to a file</title>
	      <programlisting>&rpmcheck;</programlisting>
	    </example>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>/{}</token></term>
	  <listitem><formalpara><title>file pathname</title>
	      <para>Mostly used in 'find' constructs.</para>
	    </formalpara>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>></token> <token>>&</token> <token>>></token> <token><</token></term>
	  <indexterm>
	    <primary>></primary>
	  </indexterm>
	  <indexterm>
	    <primary>>&</primary>
	  </indexterm>
	  <indexterm>
	    <primary>>></primary>
	  </indexterm>
	  <indexterm>
	    <primary><</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>></secondary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>>&</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>>></secondary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary><</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>redirection</primary>
	  </indexterm>	  

	  <listitem><formalpara><title>redirection</title>
	      <para></para>
	    </formalpara>

	    <para><userinput>scriptname >filename</userinput> redirects the output of
	      <filename>scriptname</filename> to file
	      <filename>filename</filename>. Overwrite
	      <filename>filename</filename> if it already exists.</para>

	    <para><userinput>command >&2</userinput> redirects output of
	    <filename>command</filename> to stderr.</para>

	    <para><userinput>scriptname >>filename</userinput> appends
	    the output of <filename>scriptname</filename>
	    to file <filename>filename</filename>. If
	    <filename>filename</filename> does not already exist,
	    it will be created.</para>

	    <para>For a more detailed explanation, see <xref
	    linkend="io-redirection">.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token><<</token></term>
	  <listitem><formalpara><title>redirection used in <quote>here document</quote></title>
	      <para>See <xref linkend="here-docs">.</para>
	    </formalpara>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>|</token></term>
	  <indexterm>
	    <primary>|</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>|</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>pipe</primary>
	  </indexterm>	  

	  <listitem><formalpara><title>pipe</title>
	      <para>Passes the output of previous command to next one, or to shell.
	      This is a method of chaining commands together.</para>
	    </formalpara>

	    <para><programlisting>echo ls -l | sh</programlisting>
	    passes the output of <quote>ls -l</quote> to the shell, with the
	    same result as a simple <quote>ls -l</quote>.</para>

	    <para><programlisting>cat *.lst | sort | uniq</programlisting>
	      sorts the output of all the <filename>.lst</filename> files and
	      deletes duplicate lines.</para>

	     <note><para>If one of the commands in the pipe
	     aborts, this prematurely terminates execution of
	     the pipe. Called a <emphasis>broken pipe</emphasis>,
	     this condition sends a <emphasis>SIGPIPE</emphasis>
	     signal. (See <xref linkend="debugging"> for more detail
	     on signals.)</para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>>|</token></term>
	  <indexterm>
	    <primary>>|</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>>|</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>redirection</primary>
	    <secondary>force</secondary>
	  </indexterm>	  
	  <indexterm>
	    <primary>noclobber</primary>
	  </indexterm>	  

	  <listitem><formalpara><title>force redirection (even if
		<envar>noclobber</envar> environmental variable is in effect)</title>
	      <para>This will forcibly overwrite an existing file.</para>
	    </formalpara>
	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term><token>-</token></term>
	  <indexterm>
	    <primary>-</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>-</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>redirection</primary>
	    <secondary>from/to stdin/stdout</secondary>
	  </indexterm>	  
	  <listitem><formalpara><title>redirection from/to stdin or stdout</title>
	      <para></para>
	    </formalpara>

	    <para><programlisting>(cd /source/directory && tar cf - . ) | (cd /dest/directory && tar xvfp -)
# Move entire file tree from one directory to another
# [courtesy Alan Cox, a.cox@swansea.ac.uk]
#
# More elegant than, but equivalent to:
# cd source-directory
# tar cf - . | (cd ../target-directory; tar xzf -)</programlisting></para>

	    <para><programlisting>bunzip2 linux-2.4.3.tar.bz2 | tar xvf -
# --uncompress tar file--    | --then pass it to "tar"--
# If "tar" has not been patched to handle "bunzip2",
# this needs to be done in two discrete steps, using a pipe.
# The purpose of the exercise is to unarchive "bzipped" kernel source.
</programlisting></para>
       
          <para>Note that in this context the <quote>-</quote> is not
            itself a Bash operator, but rather an option recognized by
            certain UNIX utilities.</para>

	    <para>Where a filename is expected, redirects output to stdout
	      (mostly seen with <userinput>tar cf</userinput>)</para>
	    
	    <example id="ex58">
	      <title>Backup of all files changed in last day</title>
	      <programlisting>&ex58;</programlisting>
	    </example>
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><token>-</token></term>
	  <listitem><formalpara><title>previous working directory</title>
	      <para><command>cd -</command> changes to previous working
	        directory. This uses the <token>$OLDPWD</token> environmental
		variable (see <xref linkend="variables2">).</para>
	    </formalpara>
	      <caution><para>This is not to be confused with the
		<quote>-</quote> redirection operator just discussed. How
		Bash interprets the <quote>-</quote> depends on the
		context in which it appears.</para></caution>
	    </listitem>
	</varlistentry>


	<varlistentry>
	  <term><token>~</token></term>
	  <listitem><formalpara><title>home directory</title>
	      <para><emphasis>~bozo</emphasis> is bozo's home directory,
		and <command>ls ~bozo</command> lists the contents of it.
		<token>~/</token> is the current user's home directory,
		and <command>ls ~/</command> lists the contents of
		it.</para>
	    </formalpara>
	    </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term>White space</term>
	  <listitem><formalpara><title>functions as a separator, separating commands or variables.</title>
	      <para>White space consists of either spaces, tabs, blank lines, or any
		combination thereof. In some contexts, such as variable assignment,
		white space is not permitted, and results in a syntax error.</para>
	    </formalpara>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Blank lines</term>
	  <listitem><para>Blank lines have no effect on the action of a script, and are therefore useful
	      for visually separating functional sections of the script.</para>
	    
	  </listitem>
	</varlistentry>

      </variablelist>

    </sect1> <!-- Special characters used in shell scripts -->

    <sect1 id="variables">
      <title>Introduction to Variables and Parameters</title>

      <para>Variables are at the heart of every programming and scripting
      language. They are used for arithmetic operations and manipulation of
      quantities, string parsing, and working in the abstract with symbols -
      tokens that represent something else. A variable is nothing more than a
      location or set of locations in computer memory that holds an item of
      data.</para>
      
      <variablelist>
	<varlistentry>
	  <term><token>$</token></term>
	  <indexterm>
	    <primary>$</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>substitution</secondary>
	  </indexterm>

	  <listitem>
	    <formalpara><title>variable substitution</title>
	      <para>Let us carefully distinguish
	      between the <emphasis>name</emphasis> of a
	      variable and its <emphasis>value</emphasis>. If
	      <userinput>variable1</userinput> is the name of a variable,
	      then <userinput>$variable1</userinput> is a reference to its
	      <emphasis>value</emphasis>, the data item it contains. The
	      only time a variable appears <quote>naked</quote>, without
	      the <token>$</token>, is when declared or assigned (or when
	      <emphasis>exported</emphasis>).  Assignment may be with an
	      <token>=</token> (as in <emphasis>var1=27</emphasis>), in a
	      <replaceable>read</replaceable> statement, and at the head
	      of a loop (<emphasis>for var2 in 1 2 3</emphasis>).</para>
	    </formalpara>

            <para>Enclosing a referenced value in double quotes
	      (<token>" "</token>) does not interfere with variable
	      substitution. This is called partial quoting, sometimes
	      referred to as <quote>weak quoting</quote>. Using single
	      quotes (<token>' '</token>) causes the variable name to be
	      used literally, and no substitution will take place. This
	      is full quoting, sometimes referred to as <quote>strong
	      quoting</quote>.</para>

	    <para>Note that <userinput>$variable</userinput> is actually a
	      simplified alternate form of
	      <userinput>${variable}</userinput>.  In contexts
	      where the <userinput>$variable</userinput> syntax
	      causes an error, the longer form may work (see <xref
	      linkend="Parameter-Substitution"> below).</para>

	    <example id="ex9">
	      <title>Variable assignment and substitution</title>
	      <programlisting>&ex9;</programlisting>
	    </example>

	    <warning><para>An uninitialized variable has a
	      <quote>null</quote> value - no assigned value at all
	      (not zero!).  Using a variable before assigning a value
	      to it will inevitably cause problems.</para></warning>

	  </listitem>
	</varlistentry>
      </variablelist>

    <sect2 id="Parameter-Substitution">
      <title>Parameter Substitution</title>

            <variablelist>
	      <varlistentry>
		<term><userinput>${parameter}</userinput></term>
		<listitem>
		<para>Same as <replaceable>$parameter</replaceable>, i.e.,
		value of the variable <replaceable>parameter</replaceable>.</para>
		<para>May be used for concatenating variables with strings.</para>
	        <para><programlisting>
your_id=${USER}-on-${HOSTNAME}
echo "$your_id"
#
echo "Old \$PATH = $PATH"
PATH=${PATH}:/opt/bin  #Add /opt/bin to $PATH for duration of script.
echo "New \$PATH = $PATH"
</programlisting></para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><userinput>${parameter-default}</userinput></term>
		<listitem>
		<para>If parameter not set, use default.</para>
		<para><programlisting>
echo ${username-`whoami`}
# Echoes the result of `whoami`, but variable "username" is still unset.</programlisting></para>

                <note><para>This is almost equivalent to
		  <replaceable>${parameter:-default}</replaceable>. The
		  extra <token>:</token> makes a difference only when
		  <emphasis>parameter</emphasis> has been declared,
		  but is null.  </para></note>

		  <para><programlisting>&paramsub;</programlisting></para>
		  
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><userinput>${parameter=default}</userinput></term>
		<term><userinput>${parameter:=default}</userinput></term>
		<listitem><para>If parameter not set, set it to default.</para>
		<para>Both forms nearly equivalent. The <token>:</token>
		  makes a difference only when <emphasis>parameter</emphasis>
		  has been declared and is null, as above.</para>
		<para><programlisting>
echo ${username=`whoami`}
# Variable "username" is now set to `whoami`.</programlisting></para>
	      </listitem>
	      </varlistentry>

	      <varlistentry>
		<term><userinput>${parameter+otherwise}</userinput></term>
		<term><userinput>${parameter:+otherwise}</userinput></term>
		<listitem><para>If parameter set, use 'otherwise", else use null string.</para>
		<para>Both forms nearly equivalent. The <token>:</token>
		  makes a difference only when <emphasis>parameter</emphasis>
		  has been declared and is null, as above.</para>
		</listitem>
	      </varlistentry>
	      <varlistentry>
		<term><userinput>${parameter?err_msg}</userinput></term>
		<term><userinput>${parameter:?err_msg}</userinput></term>
		<listitem><para>If parameter set, use it, else print err_msg.</para>
		<para>Both forms nearly equivalent. The <token>:</token>
		  makes a difference only when <emphasis>parameter</emphasis>
		  has been declared and is null, as above.</para>
		</listitem>
	      </varlistentry>
	    </variablelist>

	    <example id="ex6">
	      <title>Using param substitution and <token>:</token></title>
	      <programlisting>&ex6;</programlisting>
	    </example>
	    
	    <formalpara><title>Parameter substitution and/or expansion</title>
	      
	      <para>The following expressions are the complement to the
		<command>match</command> <replaceable>in</replaceable>
		<command>expr</command> string operations (see <xref
		linkend="ex45">).  These particular ones are used mostly
		in parsing file path names.</para></formalpara>

	    <variablelist>
	      <varlistentry>
		<term><userinput>${var#pattern}</userinput></term>
		<term><userinput>${var##pattern}</userinput></term>
		<listitem><para>Strip off shortest/longest part of
		    <replaceable>pattern</replaceable> if it matches the front end of
		    <replaceable>variable</replaceable>.
		  </para></listitem>
	      </varlistentry>
	      
	      <varlistentry>
		<term><userinput>${var%pattern}</userinput></term>
		<term><userinput>${var%%pattern}</userinput></term>
		<listitem><para>Strip off shortest/longest part of
		    <replaceable>pattern</replaceable> if it matches the back end of 
		    <replaceable>variable</replaceable>.
		  </para></listitem>
	      </varlistentry>
	    </variablelist>
	    
	    <para>Version 2 of bash adds additional options.</para>


	    <example id="rfe">
	      <title>Renaming file extensions<token>:</token></title>
	      <programlisting>&rfe;</programlisting>
	    </example>
	    
	    <variablelist>
	      <varlistentry>
		<term><userinput>${var:pos}</userinput></term>
		<listitem><para>Variable <replaceable>var</replaceable> expanded,
		    starting from offset <replaceable>pos</replaceable>.
		  </para></listitem>
	      </varlistentry>
	      
	      <varlistentry>
		<term><userinput>${var:pos:len}</userinput></term>
		<listitem><para>Expansion to a max of <replaceable>len</replaceable>
		    characters of variable <replaceable>var</replaceable>, from offset
		    <replaceable>pos</replaceable>. See <xref linkend="pw">
		    for an example of the creative use of this operator.
		  </para></listitem>
	      </varlistentry>
	      
	      <varlistentry>
		<term><userinput>${var/patt/replacement}</userinput></term>
		<listitem>
		  <para>First match of <replaceable>patt</replaceable>,
		    within <replaceable>var</replaceable> replaced with
		    <replaceable>replacement</replaceable>.</para>
		  <para>If <replaceable>replacement</replaceable> is
		    omitted, then the first match of
		    <replaceable>patt</replaceable> is replaced by
		    <emphasis>nothing</emphasis>, that is, deleted.</para>
		  </listitem>  
	      </varlistentry>
	      
	      <varlistentry>
		<term><userinput>${var//patt/replacement}</userinput></term>
		<listitem>
		  <para>All matches of <replaceable>patt</replaceable>,
		    within <replaceable>var</replaceable> replaced with
		    <replaceable>replacement</replaceable>.</para>
		  <para>Similar to above, if
		    <replaceable>replacement</replaceable> is omitted,
		    then all occurrences <replaceable>patt</replaceable>
		    are replaced by <emphasis>nothing</emphasis>, that
		    is, deleted.</para>
		  </listitem>
	      </varlistentry>	
	    </variablelist>
	    
	    <example id="ex7">
	      <title>Using pattern matching to parse arbitrary strings</title>
	      <programlisting>&ex7;</programlisting>
	    </example>
	    
    </sect2> <!-- Parameter Substitution -->  

    </sect1> <!-- Variables -->



    <sect1 id="quoting">
      <title>Quoting</title>
      <indexterm>
	<primary>"</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>"</secondary>
      </indexterm>
      <indexterm>
	<primary>'</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>'</secondary>
      </indexterm>
      <indexterm>
	<primary>quote</primary>
      </indexterm>
      <indexterm>
	<primary>\</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>\</secondary>
      </indexterm>
      <indexterm>
	<primary>escape</primary>
      </indexterm>
      <para>Quoting means just that, bracketing a string in quotes. This
	has the effect of protecting special characters in the string from
	reinterpretation or expansion by the shell or shell script. (A character
	is <quote>special</quote> if it has an interpretation other than its
	literal meaning, such as the <token>wild card</token> character,
      <token>*</token>.)</para>
      
      <para>When referencing a variable, it is generally advisable in
	enclose it in double quotes (<token>" "</token>). This preserves
	all special characters within the variable name, except
	<token>$</token>, <token>'</token>, and <token>\</token>. This
	allows referencing it, that is, replacing the variable with
	its value (see <xref linkend="ex9">, above).  Enclosing the
	arguments to an <command>echo</command> statement in double
	quotes is usually a good practice (and sometimes required,
	see <xref linkend="gotchas">).</para>

      <para>Single quotes (<token>' '</token>) operate similarly to double
	quotes, but do not permit referencing variables, since
	the special meaning of <token>$</token> is turned off.
	Within single quotes, <emphasis>every</emphasis> special
	character except <token>'</token> gets interpreted literally.
	Consider single quotes (<quote>full quoting</quote>) to be a
	stricter method of quoting than double quotes (<quote>partial
	quoting</quote>).</para>

      <para><firstterm>Escaping</firstterm> is a method of quoting single
	characters. The <token>escape</token> (<token>\</token>) 
	preceding a character will either toggle on or turn off a special
	meaning for that character, depending on context.</para>

      <variablelist>

	<varlistentry><term><token>\n</token></term>
	  <indexterm>
	    <primary>\n</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\n</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>newline</primary>
	  </indexterm>
	  <listitem><para>means newline</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term><token>\r</token></term>
	  <indexterm>
	    <primary>\r</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\r</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>carriage return</primary>
	  </indexterm>
	  <listitem><para>means return</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term><token>\t</token></term>
	  <indexterm>
	    <primary>\t</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\t</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>tabulation</primary>
	  </indexterm>
	  <listitem><para>means tab</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term><token>\v</token></term>
	  <indexterm>
	    <primary>\v</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\v</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>vertical tabulation</primary>
	  </indexterm>
	  <listitem><para> means vertical tab</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term><token>\b</token></term>
	  <indexterm>
	    <primary>\b</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\b</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>backspace</primary>
	  </indexterm>
	<listitem><para>means backspace</para>
	</listitem>
	</varlistentry>

	<varlistentry><term><token>\a</token></term>
	  <indexterm>
	    <primary>\a</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\a</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>alert</primary>
	  </indexterm>
	  <indexterm>
	    <primary>beep</primary>
	  </indexterm>
	  <indexterm>
	    <primary>flash</primary>
	  </indexterm>
	<listitem><para>means <quote>alert</quote> (beep or flash)</para>
	</listitem>
	</varlistentry>

	<varlistentry><term><token>\0xx</token></term>
	  <indexterm>
	    <primary>\0xx</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\0xx</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>octal ASCII</primary>
	  </indexterm>
	  <listitem><para>translates to the octal ASCII
	      equivalent of <replaceable>0xx</replaceable></para>
	    <para><programlisting># Use the -e option with 'echo' to print these.
echo -e "\v\v\v\v"   # Prints 4 vertical tabs.
echo -e "\042"   # Prints " (quote, ASCII character 42).</programlisting>
	  </para>
	</listitem>
	</varlistentry>

	<varlistentry><term><token>\"</token></term>
	  <indexterm>
	    <primary>\"</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\"</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>quote</primary>
	  </indexterm>
	<listitem><para> gives the quote its literal meaning</para>
	<para><programlisting>echo "Hello"                  # Hello
echo "\"Hello\", he said."    # "Hello", he said.</programlisting></para>
	</listitem>
	</varlistentry>

	<varlistentry><term><token>\$</token></term>
	  <indexterm>
	    <primary>\$</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\$</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>dollar</primary>
	  </indexterm>
	  <listitem><para>gives the dollar sign its literal meaning
	      (variable name following <token>\$</token> will not be
	      referenced)</para>
	    <para><programlisting>echo "\$variable01"  # results in $variable01</programlisting></para>
	  </listitem>
	  </varlistentry>

	<varlistentry><term><token>\\</token></term>
	  <indexterm>
	    <primary>\\</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\\</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>double backslash</primary>
	  </indexterm>
	  <listitem><para>gives the backslash its literal meaning</para>
	    <para><programlisting>echo "\\"  # results in \</programlisting></para>
	  </listitem>
	  </varlistentry>
	</variablelist>


      <para>The <token>escape</token> also provides a means of writing a
	multi-line command. Normally, each separate line constitutes
	a different command, but an <token>escape</token> at the end
	of a line <emphasis>escapes the newline character</emphasis>,
	and the command sequence continues onto the next line.</para>
      <para><programlisting>(cd /source/directory && tar cf - . ) | \
(cd /dest/directory && tar xvfp -)
# Repeating Alan Cox's directory tree copy command,
# but split into two lines for increased legibility.</programlisting>
	</para>

    </sect1> <!-- Quoting -->

    <sect1 id="tests">
      <title>Tests</title>
      <indexterm>
	<primary>if</primary>
      </indexterm>
      <indexterm>
	<primary>test</primary>
	<secondary>if</secondary>
      </indexterm>
      <indexterm>
	<primary>then</primary>
      </indexterm>
      <indexterm>
	<primary>else if</primary>
      </indexterm>
      <indexterm>
	<primary>elif</primary>
      </indexterm>

      <para>The <token>if/then</token> construct tests whether a condition is
	true, and if so, executes one or more commands. Note that in this
	context, <literal>0</literal> (zero) will evaluate as true, as will
	a random string of alphanumerics.  Puzzling out the logic of this is
	left as an exercise for the reader.</para>

      <example id="ex10">
	<title>What is truth?</title>
	<programlisting>&ex10;</programlisting>
      </example>

      <formalpara><title>Exercise</title>
	<para>Explain the behavior of <xref linkend="ex10">, above.</para>
      </formalpara>
      
      <para><programlisting>if [ condition-true ]
then
   command 1
   command 2
   ...
else
   # Optional (may be left out if not needed).
   # Adds default code block executing if original condition tests false.
   command 3
   command 4
   ...
fi</programlisting>
      </para>

      <para>Add a semicolon when 'if' and 'then' are on same line.</para>
      <para><programlisting>if [ -x filename ]; then</programlisting></para>

      <variablelist>
	<varlistentry>
	  <term><token>elif</token></term>
	  <listitem><para>  This is a contraction for <token>else if</token>.
	  The effect is to nest an inner <token>if/then</token> construction
	      within an outer one.</para>

	    <para><programlisting>if [ condition ]
then
   command
   command
   command
elif
# Same as else if
then
   command
   command
else
   default-command
fi</programlisting>
	      </para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>
      <indexterm>
	<primary>test</primary>
      </indexterm>
      <indexterm>
	<primary>test</primary>
	<secondary>test</secondary>
      </indexterm>
      <indexterm>
	<primary>[</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>[</secondary>
      </indexterm>
      <indexterm>
	<primary>]</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>]</secondary>
      </indexterm>
	
	The <userinput>test condition-true</userinput> construct is the exact
	equivalent of <userinput>if [condition-true ]</userinput>. The left bracket
	<token>[</token> is, in fact, an alias for <token>test</token>. (The
	closing right bracket <token>]</token> in a test should not therefore 
	be strictly necessary, however newer versions of bash detect it as a
	syntax error and complain.)</para>

      <example id="ex11">
	<title>Equivalence of <token>[ ]</token> and <token>test</token></title>
	<programlisting>&ex11;</programlisting>
      </example>
      
      <sect2>
	<title>File test operators</title>

	<variablelist>
	  <title>Returns true if...</title>
	  <varlistentry>
	    <term><token>-e</token></term>
	    <listitem><para>file exists</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-f</token></term>
	    <listitem><para>file is a regular file</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-s</token></term>
	    <listitem><para>file is not zero size</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-d</token></term>
	    <listitem><para>file is a directory</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-b</token></term>
	    <listitem><para>file is a block device (floppy, cdrom, etc.)
	    </para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-c</token></term>
	    <listitem><para>file is a character device (keyboard, modem, sound
	    card, etc.)</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-p</token></term>
	    <listitem><para>file is a pipe</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-L</token></term>
	    <listitem><para>file is a symbolic link</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-S</token></term>
	    <listitem><para>file is a socket</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-r</token></term>
	    <listitem><para>file is readable (has read permission)</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-w</token></term>
	    <listitem><para>file has write permission</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-x</token></term>
	    <listitem><para>file has execute permission</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-g</token></term>
	    <listitem><para>group-id flag set on file</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-u</token></term>
	    <listitem><para>user-id flag set on file</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-k</token></term>
	    <listitem><para><quote>sticky bit</quote> set (if user does not
	      own a directory that has the sticky bit set, she cannot delete
	      files in it, not even files she owns)</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-O</token></term>
	    <listitem><para>you are owner of file</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-G</token></term>
	    <listitem><para>group-id of file same as yours</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-t n</token></term>
	    <listitem>
	    <para>file descriptor <emphasis>n</emphasis> is open</para>
	    <para>This usually refers to <emphasis>stdin</emphasis>,
	      <emphasis>stdout</emphasis>, and <emphasis>stderr</emphasis>
	      (file descriptors 0 - 2).</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>f1 -nt f2</token></term>
	    <listitem><para>file <replaceable>f1</replaceable> is newer than
		<replaceable>f2</replaceable></para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>f1 -ot f2</token></term>
	    <listitem><para>file <replaceable>f1</replaceable> is older than
		<replaceable>f2</replaceable></para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>f1 -ef f2</token></term>
	    <listitem><para>files <replaceable>f1</replaceable> and
		<replaceable>f2</replaceable> are links to the same
		file</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>!</token></term>
	    <listitem><para><quote>not</quote> -- reverses the sense of the
	    tests above (returns true if condition absent).</para></listitem>
	  </varlistentry>
	</variablelist>
	
	<example id="ex12">
	  <title>Tests, command chaining, redirection</title>
	  <programlisting>&ex12;</programlisting>
	</example>
      

      </sect2> <!-- File test operators -->

      <sect2>
	<title>Comparison operators (binary)</title>
	<variablelist>
	  <title>integer comparison</title>
	  <varlistentry>
	    <term><token>-eq</token></term>
	    <listitem><para>is equal to (<userinput>$a -eq $b</userinput>)</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-ne</token></term>
	    <listitem><para>is not equal to (<userinput>$a -ne $b</userinput>)</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-gt</token></term>
	    <listitem><para>is greater than (<userinput>$a -gt $b</userinput>)</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-ge</token></term>
	    <listitem><para>is greater than or equal to (<userinput>$a -ge $b</userinput>)</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-lt</token></term>
	    <listitem><para>is less than (<userinput>$a -lt $b</userinput>)</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-le</token></term>
	    <listitem><para>is less than or equal to (<userinput>$a -le $b</userinput>)</para></listitem>
	  </varlistentry>
	  
	</variablelist>
	
	<variablelist>
	  <title>string comparison</title>
	  <varlistentry>
	    <term><token>=</token></term>
	    <listitem><para>is equal to (<userinput>$a = $b</userinput>)</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>!=</token></term>
	    <listitem><para>is not equal to (<userinput>$a != $b</userinput>)</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>\&lt;</token></term>
	    <listitem>
	    <para>is less than, in ASCII alphabetical order (<userinput>$a
	      \&lt; $b</userinput>)</para>
	    <para>Note that the <quote>&lt;</quote> needs to be
	      escaped.</para>  
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>\&gt;</token></term>
	    <listitem>
	    <para>is greater than, in ASCII alphabetical order
	      (<userinput>$a \&gt; $b</userinput>)</para>
	    <para>Note that the <quote>&gt;</quote> needs to be
	      escaped.</para>  
	    <para>See <xref linkend="bubble"> for an application of this
	      comparison operator.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>-z</token></term>
	    <listitem><para>string is <quote>null</quote>, that is, has zero length</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-n</token></term>
	    <listitem>
	      <para>string is not <quote>null</quote>.</para>
	    
	      <caution><para>This test requires that the string be quoted
		within the test brackets.  You may use
		<userinput>! -z</userinput> instead, or even just
		the string itself, without a test operator (see <xref
		linkend="strtest">).</para></caution>

            </listitem>
	    </varlistentry>
	</variablelist>
	
	<example id="ex13">
	  <title>arithmetic and string comparisons</title>
	  <programlisting>&ex13;</programlisting>
	</example>

	<example id="strtest">
	  <title>testing whether a string is <emphasis>null</emphasis></title>
	  <programlisting>&strtest;</programlisting>
	</example>
      
	<example id="ex14">
	  <title><command>zmost</command></title>
	  <programlisting>&ex14;</programlisting>
	</example>

	<variablelist>  
	  <title>compound comparison</title>
	  <varlistentry>
	    <term><token>-a</token></term>
	    <listitem>
	      <para>logical and</para>
	      <para><replaceable>exp1 -a exp2</replaceable> returns true if
		<emphasis>both</emphasis> exp1 and exp2 are true.</para>
	    </listitem>
            </varlistentry>
	  <varlistentry>
	    <term><token>-o</token></term>
	    <listitem>
	      <para>logical or </para>
	      <para><replaceable>exp1 -o exp2</replaceable> returns
		true if either exp1 <emphasis>or</emphasis> exp2 are
		true.</para>
	    </listitem>
	    </varlistentry>
	</variablelist>

       <para>These are simpler forms of the comparison operators
	 <replaceable>&&</replaceable> and <replaceable>||</replaceable>,
	 which require brackets to separate the target expressions.</para>

	<para>Refer to <xref linkend="andor"> to see compound comparison operators
	  in action.</para>
      
      </sect2> <!-- Comparison operators (binary) -->


    </sect1> <!-- Tests -->

    <sect1 id="operations">
      <title>Operations and Related Topics</title>

     <sect2 id="ops">
      <title>Operations</title>

      <variablelist>
	<varlistentry>
	  <indexterm>
	    <primary>=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>=</secondary>
	  </indexterm>
	  <term>=</term>
	  <listitem><para>All-purpose assignment operator, which works for both arithmetic and
    string assignments.</para>

	    <para>
	      <programlisting>var=27
category=minerals</programlisting>
	    </para>

	    <para>May also be used in a string comparison test.</para>

	    <para>
	      <programlisting>if [ $string1 = $string2 ]
then
   command
fi</programlisting>
	    </para>
    
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>The following are normally used in combination with
	<indexterm>
	  <primary>expr</primary>
	</indexterm>
	<indexterm>
	  <primary>command</primary>
	  <secondary>expr</secondary>
	</indexterm>
	<indexterm>
	  <primary>let</primary>
	</indexterm>
	<indexterm>
	  <primary>command</primary>
	  <secondary>let</secondary>
	</indexterm>

      <command>expr</command> or <command>let</command>.</para>

      <variablelist><title>arithmetic operators</title>
	<varlistentry>
	  <term><token>+</token></term>
	  <indexterm>
	    <primary>+</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>+</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>addition</primary>
	  </indexterm>
	  <indexterm>
	    <primary>plus</primary>
	  </indexterm>
	  <listitem><para>plus</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>-</token></term>
	  <indexterm>
	    <primary>-</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>-</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>subtraction</primary>
	  </indexterm>
	  <indexterm>
	    <primary>minus</primary>
	  </indexterm>
	  <listitem><para>minus</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>*</token></term>
	  <indexterm>
	    <primary>*</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>*</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>multiplication</primary>
	  </indexterm>
	  <listitem><para>multiplication</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>/</token></term>
	  <indexterm>
	    <primary>/</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>/</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>division</primary>
	  </indexterm>
	  <listitem><para>division</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>%</token></term>
	  <indexterm>
	    <primary>%</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>%</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>modulo</primary>
	  </indexterm>
	  <listitem><para>modulo, or mod (returns the remainder of an integer
	  division)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>+=</token></term>
	  <indexterm>
	    <primary>+=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>+=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>plus-equal</primary>
	  </indexterm>
	  <listitem><para><quote>plus-equal</quote> (increment variable by a constant)</para>
	    <para><userinput>`expr $var+=5`</userinput> results in
	      <varname>var</varname> being incremented by
	      <literal>5</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>-=</token></term>
	  <indexterm>
	    <primary>-=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>-=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>minus-equal</primary>
	  </indexterm>
	  <listitem><para><quote>minus-equal</quote> (decrement variable by a constant)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>*=</token></term>
	  <indexterm>
	    <primary>*=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>*=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>times-equal</primary>
	  </indexterm>
	  <listitem><para><quote>times-equal</quote> (multiply variable by a constant)</para>
	    <para><userinput>`expr $var*=4`</userinput> results in <varname>var</varname>
	    being multiplied by <literal>4</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>/=</token></term>
	  <indexterm>
	    <primary>/=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>/=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>slash-equal</primary>
	  </indexterm>
	  <listitem><para><quote>slash-equal</quote> (divide variable by a constant)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>%=</token></term>
	  <indexterm>
	    <primary>%=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>%=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>mod-equal</primary>
	  </indexterm>
	  <listitem><para><quote>mod-equal</quote> (remainder of dividing variable by a constant)</para>
	  </listitem>
	</varlistentry>

      </variablelist>

      <para>The bitwise logical operators seldom make an appearance in shell scripts.
	Their chief use seems to be manipulating and testing values read from
	ports or sockets. <quote>Bit flipping</quote> is more relevant to compiled languages,
	such as C and C++, which run fast enough to permit its use on the fly.</para>

      <variablelist>
	<varlistentry>
	  <term><token><<</token></term>
	  <indexterm>
	    <primary><<</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary><<</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>left shift</primary>
	  </indexterm>
	  <listitem><para>bitwise left shift (multiplies by <literal>2</literal>
	      for each shift position)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token><<=</token></term>
	  <indexterm>
	    <primary><<=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary><<=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>left-shift-equal</primary>
	  </indexterm>
	  <listitem><para><quote>left-shift-equal</quote></para>
	    <para><userinput>let "var <<= 2"</userinput> results in <varname>var</varname>
	    left-shifted <literal>2</literal> bits (multiplied by <literal>4</literal>)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>>></token></term>
	  <indexterm>
	    <primary>>></primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>>></secondary>
	  </indexterm>
	  <indexterm>
	    <primary>right shift</primary>
	  </indexterm>
	  <listitem><para>bitwise right shift (divides by <literal>2</literal>
	      for each shift position)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>>>=</token></term>
	  <indexterm>
	    <primary>>>=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>>>=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>right-shift-equal</primary>
	  </indexterm>
	  <listitem><para><quote>right-shift-equal</quote> (inverse of <token><<=</token>)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>&</token></term>
	  <indexterm>
	    <primary>&</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>&</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>AND</primary>
	    <secondary>bitwise</secondary>
	  </indexterm>
	  <listitem><para>bitwise and</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>&=</token></term>
	  <indexterm>
	    <primary>&=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>&=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>and-equal</primary>
	  </indexterm>
	  <listitem><para><quote>bitwise and-equal</quote></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>|</token></term>
	  <indexterm>
	    <primary>|</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>|</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>OR</primary>
	    <secondary>bitwise</secondary>
	  </indexterm>
	  <listitem><para>bitwise OR</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>|=</token></term>
	  <indexterm>
	    <primary>|=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>|=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>OR-equal</primary>
	  </indexterm>
	  <listitem><para><quote>bitwise OR-equal</quote></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>~</token></term>
	  <indexterm>
	    <primary>~</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>~</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>negate</primary>
	  </indexterm>
	  <listitem><para>bitwise negate</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>!</token></term>
	  <indexterm>
	    <primary>!</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>!</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>NOT</primary>
	  </indexterm>
	  <listitem><para>bitwise NOT</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>^</token></term>
	  <indexterm>
	    <primary>^</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>^</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>XOR</primary>
	  </indexterm>
	  <listitem><para>bitwise XOR</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>^=</token></term>
	  <indexterm>
	    <primary>^=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>^=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>XOR-equal</primary>
	  </indexterm>
	  <listitem><para><quote>bitwise XOR-equal</quote></para>
	  </listitem>
	</varlistentry>

      </variablelist>

      <variablelist><title>relational tests</title>
	<varlistentry>
	  <term><token><</token></term>
	  <indexterm>
	    <primary><</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary><</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>less than</primary>
	  </indexterm>
	  <listitem><para>less than</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>></token></term>
	  <indexterm>
	    <primary>></primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>></secondary>
	  </indexterm>
	  <indexterm>
	    <primary>greater than</primary>
	  </indexterm>
	  <listitem><para>greater than</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token><=</token></term>
	  <indexterm>
	    <primary><=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary><=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>less than or equal to</primary>
	  </indexterm>
	  <listitem><para>less than or equal to</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>>=</token></term>
	  <indexterm>
	    <primary>>=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>>=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>greater than or equal to</primary>
	  </indexterm>
	  <listitem><para>greater than or equal to</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>==</token></term>
	  <indexterm>
	    <primary>==</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>==</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>equal to</primary>
	  </indexterm>
	  <listitem><para>equal to (test)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>!=</token></term>
	  <indexterm>
	    <primary>!=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>!=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>not equal to</primary>
	  </indexterm>
	  <listitem><para>not equal to</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>&&</token></term>
	  <indexterm>
	    <primary>&&</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>&&</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>AND</primary>
	    <secondary>logical</secondary>
	  </indexterm>
	  <listitem><para>and (logical)</para>
	    <para><programlisting>if [ $condition1 ] && [ $condition2 ]
# if both condition1 and condition2 hold true...</programlisting></para>
	  <note><para><token>&&</token> may also, depending on context, be
	    used to in an <emphasis>and list</emphasis> to concatenate
	    commands (see <xref linkend="list-cons">).</para></note>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>||</token></term>
	  <indexterm>
	    <primary>||</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>||</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>OR</primary>
	    <secondary>logical</secondary>
	  </indexterm>
	  <listitem><para>or  (logical)</para>
	    <para><programlisting>if [ $condition1 ] || [ $condition2 ]
# if both condition1 or condition2 hold true...</programlisting></para>
	<example id="andor">
	  <title>Compound Condition Tests Using && and ||</title>
       	    <programlisting>&andor;</programlisting>
	 </example>   
	  </listitem>
	</varlistentry>

      </variablelist>

    </sect2>

    <sect2 id="Numerical-Constants">
      <title>Numerical Constants</title>

      <para>A shell script interprets a number as decimal (base 10), unless
        that number has a special prefix or notation. A number preceded by a
	<replaceable>0</replaceable> is <replaceable>octal</replaceable> (base
	8). A number preceded by <replaceable>0x</replaceable> is
	<replaceable>hexadecimal</replaceable> (base 16). A number with an
	embedded <replaceable>#</replaceable> is evaluated as
	<replaceable>BASE#NUMBER</replaceable> (this option is of limited
	usefulness because of range restrictions).</para>

	    <example id="numbers">
	      <title>Representation of numerical constants<token>:</token></title>
	      <programlisting>&numbers;</programlisting>
	    </example>

    </sect2>

    </sect1> <!-- Operations -->



    <sect1 id="variables2">
      <title>Variables Revisited</title>

	<para>Used properly, variables can add power and flexibility
	  to scripts. This requires learning their subtleties and
	  nuances.</para>

      <variablelist>
	<varlistentry>
	  <term><replaceable>Internal (builtin) variables</replaceable></term>
	  <listitem><para>environmental variables affecting bash script behavior</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$IFS</varname></term>
	  <indexterm>
	    <primary>$IFS</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$IFS</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>input field separator</primary>
	  </indexterm>
	  <listitem><para>input field separator</para>
	    <para>This defaults to <token>white space</token>, but may be
	      changed, for example, to parse a comma-separated data file.
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$HOME</varname></term>
	  <indexterm>
	    <primary>$HOME</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$HOME</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>home directory</primary>
	  </indexterm>
	  <indexterm>
	    <primary>directory</primary>
	    <secondary>home</secondary>
	  </indexterm>
	  <listitem><para>home directory of the user, usually <filename
	    class="directory">/home/username</filename> (see <xref
	    linkend="ex6">)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$HOSTNAME</varname></term>
	  <indexterm>
	    <primary>$HOSTNAME</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$HOSTNAME</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>system name</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>name</secondary>
	  </indexterm>
	  <listitem><para>name assigned to the system, usually fetched at
	    bootup from <filename>/etc/hosts</filename> (see <xref
	    linkend="ex6">)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$UID</varname></term>
	  <indexterm>
	    <primary>$UID</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$UID</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>user id</primary>
	  </indexterm>
	  <listitem><para>user id number</para>
	    <para>current user's user identification number, as
	      recorded in <filename>/etc/passwd</filename>
	    </para>
	    <para>This is the current user's real id, even if she has
	      temporarily assumed another identity through
	      <command>su</command> (see <xref linkend="system">).
	      <varname>$UID</varname> is a readonly variable, not subject
	      to change from the command line or within a script.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$EUID</varname></term>
	  <indexterm>
	    <primary>$EUID</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$EUID</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>effective user id</primary>
	  </indexterm>
	  <listitem><para><quote>effective</quote> user id number</para>
	    <para>identification number of whatever identity the current user
	      has assumed, perhaps by means of <command>su</command></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$GROUPS</varname></term>
	  <indexterm>
	    <primary>$GROUPS</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$GROUPS</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>groups</primary>
	  </indexterm>
	  <listitem><para>groups current user belongs to</para>
	    <para>This is a listing (array) of the group id numbers for
	      current user, as  recorded in
	      <filename>/etc/passwd</filename>.
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$PATH</varname></term>
	  <indexterm>
	    <primary>$PATH</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PATH</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>path to binaries</primary>
	  </indexterm>
	  <listitem><para>path to binaries, usually 
	      <filename class="directory">/usr/bin/</filename>, 
	      <filename class="directory">/usr/X11R6/bin/</filename>, 
	      <filename class="directory">/usr/local/bin</filename>, etc.</para>

	    <para>When given a command, the shell automatically searches the
	      directories listed in the <emphasis>path</emphasis>
	      for the executable. The path is stored in the
	      environmental variable, <varname>$PATH</varname>, a
	      list of directories, separated by colons. Normally, the
	      system stores the <varname>$PATH</varname>
	      definition in <filename>/etc/profile</filename>
	      and/or <filename>~/.bashrc</filename> (see <xref
	      linkend="files">).</para>

	      <para><screen><prompt>bash$ </prompt><command>echo $PATH</command>
<computeroutput>/bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin:/sbin:/usr/sbin</computeroutput></screen>
              </para>

	    <para><userinput>PATH=${PATH}:/opt/bin</userinput> appends
	      the <filename class="directory">/opt/bin</filename>
	      directory to the current path. In a script, it may be
	      expedient to temporarily add a directory to the path
	      in this way. When the script exits, this restores the
	      original <varname>$PATH</varname> (a child process, such
	      as a script, may not change the environment of the parent
	      process, the shell).</para>

	    <note><para>The current <quote>working directory</quote>, 
	      <filename class="directory">./</filename>, is usually
	      omitted from the <varname>$PATH</varname> as a security
	      measure.</para></note>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$PS1</varname></term>
	  <indexterm>
	    <primary>$PS1</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PS1</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>prompt</primary>
	  </indexterm>
	  <listitem><para>This is the main prompt, seen at the command line.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$PS2</varname></term>
	  <indexterm>
	    <primary>$PS2</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PS2</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>prompt</primary>
	    <secondary>secondary</secondary>
	  </indexterm>
	  <listitem><para>The secondary prompt, seen when additional input is
	    expected. It displays as <quote>&gt;</quote>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$PS3</varname></term>
	  <indexterm>
	    <primary>$PS3</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PS3</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>prompt</primary>
	    <secondary>tertiary</secondary>
	  </indexterm>
	  <listitem><para>The tertiary prompt, displayed in a
	    <command>select</command> loop (see <xref linkend="ex31">).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$PS4</varname></term>
	  <indexterm>
	    <primary>$PS4</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PS4</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>prompt</primary>
	    <secondary>quartenary</secondary>
	  </indexterm>
	  <listitem><para>The quartenary prompt, shown at the beginning of
	    each line of output when invoking a script with
	    the <token>-x</token> option.  It displays as
	    <quote>+</quote>.</para>
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><varname>$PWD</varname></term>
	  <indexterm>
	    <primary>$PWD</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PWD</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>working directory</primary>
	  </indexterm>
	  <indexterm>
	    <primary>directory</primary>
	    <secondary>working</secondary>
	  </indexterm>
	  <listitem><para>working directory (directory you are in at the time)</para>
          <para><programlisting>&wipedir;</programlisting></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$OLDPWD</varname></term>
	  <indexterm>
	    <primary>$OLDPWD</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$OLDPWD</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>previous working directory</primary>
	  </indexterm>
	  <indexterm>
	    <primary>directory</primary>
	    <secondary>working</secondary>
	  </indexterm>
	  <listitem><para>old working directory (previous directory you were in)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$DIRSTACK</varname></term>
	  <indexterm>
	    <primary>$DIRSTACK</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$DIRSTACK</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>directory stack</primary>
	  </indexterm>
	  <indexterm>
	    <primary>directory</primary>
	    <secondary>stack</secondary>
	  </indexterm>
	  <listitem><para>contents of the directory stack (affected by
	    <command>pushd</command> and <command>popd</command>)</para>
	    <para>This builtin variable is the counterpart to the
	      <command>dirs</command> command (see <xref
	      linkend="internal">).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$PPID</varname></term>
	  <indexterm>
	    <primary>$PPID</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PPID</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>process id</primary>
	  </indexterm>
	  <listitem><para></para>
	    <para>the process id (pid) of the currently running process
	    </para>
	    <para>This corresponds to the <command>pidof</command> command
	      (see <xref linkend="system">).</para> 
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$MACHTYPE</varname></term>
	  <indexterm>
	    <primary>$MACHTYPE</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$MACHTYPE</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>machine type</primary>
	  </indexterm>
	  <listitem><para>machine type</para>
	    <para>Identifies the system hardware.</para>
	    <screen><prompt>bash$ </prompt><userinput>echo $MACHTYPE</userinput>
<computeroutput>i686-debian-linux-gnu</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$HOSTTYPE</varname></term>
	  <indexterm>
	    <primary>$HOSTTYPE</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$HOSTTYPE</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>host type</primary>
	  </indexterm>
	  <listitem><para>host type</para>
	    <para>Like <varname>$MACHTYPE</varname> above, identifies
	      the system hardware.</para>
	    <screen><prompt>bash$ </prompt><userinput>echo $HOSTTYPE</userinput>
<computeroutput>i686</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$OSTYPE</varname></term>
	  <indexterm>
	    <primary>$OSTYPE</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$OSTYPE</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>os type</primary>
	  </indexterm>
	  <listitem><para>operating system type</para>
	    <screen><prompt>bash$ </prompt><userinput>echo $OSTYPE</userinput>
<computeroutput>linux-gnu</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$EDITOR</varname></term>
	  <indexterm>
	    <primary>$EDITOR</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$EDITOR</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>editor</primary>
	  </indexterm>
	  <listitem><para>the default editor invoked by a script, usually
	      <command>vi</command> or <command>emacs</command>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$IGNOREEOF</varname></term>
	  <indexterm>
	    <primary>$IGNOREEOF</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$IGNOREEOF</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>ignore EOF</primary>
	  </indexterm>
	  <listitem><para>ignore EOF: how many end-of-files (control-D)
	    the shell will ignore before logging out.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$TMOUT</varname></term>
	  <indexterm>
	    <primary>$TMOUT</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$TMOUT</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>timeout interval</primary>
	  </indexterm>
	  <listitem><para>If the <replaceable>$TMOUT</replaceable>
	  environmental variable is set to a non-zero value
	  <emphasis>time</emphasis>, then the shell prompt will time out
	  after <emphasis>time</emphasis> seconds. This will cause a
	  logout.</para>

	  <note><para>Unfortunately, this works only while waiting
	    for input at the shell prompt console or in an xterm. While
	    it would be nice to speculate on the uses of this internal
	    variable for timed input, for example in combination with
	    <command>read</command>, <replaceable>$TMOUT</replaceable>
	    does not work in that context and is virtually useless for
	    shell scripting. (Reportedly the <emphasis>ksh</emphasis>
	    version of a timed <command>read</command> does
	    work).</para></note>

	  <para>Implementing timed input in a script is certainly
	    possible, but hardly seems worth the effort. It requires
	    setting up a timing loop to signal the script when it times
	    out.  Additionally, a signal handling routine is necessary
	    to trap (see <xref linkend="ex76">) the interrupt generated
	    by the timing loop (whew!).</para>

          <para><programlisting>&tmdin;</programlisting></para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$SECONDS</varname></term>
	  <indexterm>
	    <primary>$SECONDS</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$SECONDS</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>number of seconds the script has been running</primary>
	  </indexterm>
	  <indexterm>
	    <primary>runtime</primary>
	    <secondary>seconds</secondary>
	  </indexterm>
	  <listitem><para>The number of seconds the script has been running.</para>
	     <para><programlisting>&seconds;</programlisting></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$REPLY</varname></term>
	  <indexterm>
	    <primary>$REPLY</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$REPLY</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>default value of read</primary>
	  </indexterm>
	  <indexterm>
	    <primary>reply</primary>
	    <secondary>read</secondary>
	  </indexterm>
	  <listitem><para>The default value when a variable is not
	    supplied to <command>read</command>. Also applicable to
	    <command>select</command> menus, but only supplies the item
	    number of the variable chosen, not the value of the variable
	    itself.</para>
	     <para><programlisting>&reply;</programlisting></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$SHELLOPTS</varname></term>
	  <indexterm>
	    <primary>$SHELLOPTS</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$SHELLOPTS</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>shell options</primary>
	  </indexterm>
	  <listitem><para>the list of enabled shell options, a readonly
	    variable</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$BASH</varname></term>
	  <indexterm>
	    <primary>$BASH</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$BASH</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>path to bash</primary>
	  </indexterm>
	  <listitem><para>the path to the <command>bash</command> binary itself,
	  usually <filename>/bin/bash</filename></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$BASH_ENV</varname></term>
	  <indexterm>
	    <primary>$BASH_ENV</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$BASH_ENV</secondary>
	  </indexterm>
	  <listitem><para>an environmental variable pointing to a bash startup
	      file to be read when a script is invoked</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$BASH_VERSION</varname></term>
	  <indexterm>
	    <primary>$BASH_VERSION</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$BASH_VERSION</secondary>
	  </indexterm>
	  <listitem><para>the version of Bash installed on the system</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>echo $BASH_VERSION</userinput>
<computeroutput>2.04.12(1)-release</computeroutput>
	      </screen>
	    </para>

	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term><varname>$0</varname>, <varname>$1</varname>,
	  <varname>$2</varname>, etc.</term>
	  <indexterm>
	    <primary>$0</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$0</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>positional parameter</primary>
	  </indexterm>
	  <indexterm>
	    <primary>parameter</primary>
	    <secondary>positional</secondary>
	  </indexterm>
	  <listitem>
	    <para>positional parameters, passed from command
	      line to script, passed to a function, or
	      <command>set</command> to a variable (see <xref
	      linkend="ex17"> and <xref linkend="ex34">)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$#</varname></term>
	  <indexterm>
	    <primary>$#</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$#</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>positional parameter</primary>
	    <secondary>number of</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>parameter</primary>
	    <secondary>positional</secondary>
	    <tertiary>number of</tertiary>
	  </indexterm>
	  <listitem><para>number of command line arguments
		<footnote><para>The words <quote>argument</quote>
		and <quote>parameter</quote> are often used
		interchangeably. In the context of this document, they
		have the same precise meaning, that of a variable passed
		to a script or function.</para></footnote>
	    or positional parameters (see <xref linkend="ex4">)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$$</varname></term>
	  <indexterm>
	    <primary>$$</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$$</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>PID</primary>
	    <secondary>of script</secondary>
	  </indexterm>
	  <listitem><para>process id of script, often used in scripts
	    to construct temp file names (see <xref linkend="ftpget"> and
	    <xref linkend="online">)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$?</varname></term>
	  <indexterm>
	    <primary>$?</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$?</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>exit status</primary>
	  </indexterm>
	  <listitem><para>exit status of command, function, or the script itself
	    (see <xref linkend="ex5"> and <xref linkend="lookup">)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$*</varname></term>
	  <indexterm>
	    <primary>$*</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$*</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>positional parameter</primary>
	    <secondary>all</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>parameter</primary>
	    <secondary>positional</secondary>
	    <tertiary>all</tertiary>
	  </indexterm>
	  <listitem><para>All of the positional parameters, seen as a single
	    word</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$@</varname></term>
	  <indexterm>
	    <primary>$@</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$*</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>positional parameter</primary>
	    <secondary>all</secondary>
	  </indexterm>
	  <listitem><para>Same as <token>$*</token>, but each parameter is a
	      quoted string, that is, the parameters are passed on
	      intact, without interpretation or expansion. This means,
	      among other things, that each parameter in the argument
	      list is seen as a separate word.</para>

	    <example id="arglist">
	      <title><command>arglist</command>: Listing arguments with $* and $@</title>
	      <programlisting>&arglist;</programlisting>
	    </example>	    

	    <para>The <varname>$@</varname> intrinsic variable finds
	      use as a <quote>general input filter</quote> tool
	      in shell scripts. The <command>cat "$@"</command>
	      construction accepts input to a script either from
	      <filename>stdin</filename> or from files given as parameters
	      to the script. See <xref linkend="rot13">.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$-</varname></term>
	  <indexterm>
	    <primary>$-</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$-</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>flags</primary>
	  </indexterm>
	  <listitem>
	    <para>Flags passed to script</para>
	    <caution><para>This was originally a <emphasis>ksh</emphasis>
	      construct adopted into Bash, and unfortunately it does not
	      seem to work reliably in Bash scripts. One possible use for
	      it is to have a script self-test whether it is interactive
	      (see <xref linkend="miscellany">).</para></caution>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$!</varname></term>
	  <indexterm>
	    <primary>$!</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$!</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>PID</primary>
	    <secondary>last job run in background</secondary>
	  </indexterm>
	  <listitem>
	    <para>PID (process id) of last job run in background</para>
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><replaceable>variable assignment</replaceable></term>
	  <listitem><para>Initializing or changing the value of a variable</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>=</token></term>
	  <indexterm>
	    <primary>=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>assignment</secondary>
	  </indexterm>
	  <listitem><para>the assignment operator (<emphasis>no space before &
		after</emphasis>)</para>
	    <para>Do not confuse this with <token>=</token> and
	      <token>-eq</token>, which test, rather than assign!</para>

	    <caution><para><token>=</token> can be <emphasis>either</emphasis> an
	      assignment or a test operator, depending on
	      context.</para></caution>

	<example id="ex15">
	  <title>Variable Assignment</title>
	  <programlisting>&ex15;</programlisting>
	</example>

	<example id="ex16">
	  <title>Variable Assignment, plain and fancy</title>
	  <programlisting>&ex16;</programlisting>
	</example>

	    <para>Variable assignment using the <token>$()</token> mechanism
	      (a newer method than back quotes)</para>

	    <para><programlisting># From /etc/rc.d/rc.local
R=$(cat /etc/redhat-release)
arch=$(uname -m)</programlisting></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><replaceable>local variables</replaceable></term>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>local</secondary>
	  </indexterm>

	  <listitem><para>variables visible only within a code block or function
	      (see <xref linkend="functions">)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><replaceable>environmental variables</replaceable></term>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>environmental</secondary>
	  </indexterm>
	  <listitem><para>variables that affect the behavior of the shell and
	      user interface, such as the path and the prompt</para>
	    <para>If a script sets environmental variables, they need to be
	      <quote>exported</quote>, that is, reported to the
	      environment local to the script. This is the function of
	      the <command>export</command> command.</para>

	    <note><para>A script can <command>export</command> variables only
	      to child processes, that is, only to commands or processes which
	      that particular script initiates. A script invoked from the
	      command line <replaceable>cannot</replaceable> export variables
	      back to the command line environment. Child processes cannot
	      export variables back to the parent processes that spawned
	      them.</para></note>

	      <para>---</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><replaceable>positional parameters</replaceable></term>
	  <indexterm>
	    <primary>parameter</primary>
	    <secondary>positional</secondary>
	  </indexterm>
	  <listitem><para>arguments passed to the script from the command
	  line - $0, $1, $2, $3... ($0 is the name of the script
	  itself, $1 is the first argument, etc.)</para>

	    <example id="ex17">
	      <title>Positional Parameters</title>
	      <programlisting>&ex17;</programlisting>
	    </example>

	    <para>Some scripts can perform different operations,
	      depending on which name they are invoked with. For this
	      to work, the script needs to check <varname>$0</varname>,
	      the name it was invoked by. There also have to be symbolic
	      links present to all the alternate names of the same
	      script.</para>

	    <note><para>If a script expects a command line parameter
	      but is invoked without one, this may cause a null variable
	      assignment, certainly an undesirable result. One way to prevent
	      this is to append an extra character to both sides of the
	      assignment statement using the expected positional parameter.
	      </para></note>

	      <programlisting>variable1x=$1x
# This will prevent an error, even if positional parameter is absent.

# The extra character can be stripped off later, if desired, like so.
variable1=${variable1x/x/}
# This uses one of the parameter substitution templates previously discussed.
# Leaving out the replacement pattern results in a deletion.
</programlisting>

	      <para>---</para>

	    <example id="ex18">
	      <title><command>wh</command>, whois domain name lookup</title>
	      <programlisting>&ex18;</programlisting>
	    </example>

	      <para>---</para>

	    <para>
	      <indexterm>
		<primary>shift</primary>
	      </indexterm>
	      <indexterm>
		<primary>command</primary>
		<secondary>shift</secondary>
	      </indexterm>
	      The <command>shift</command> command reassigns the positional
	      parameters, in effect shifting them to the left one notch.</para>
	      
	    <para><varname>$1</varname> <--- <varname>$2</varname>, <varname>$2</varname> <--- <varname>$3</varname>, <varname>$3</varname> <--- <varname>$4</varname>, etc.</para>

	    <para>The old <varname>$1</varname> disappears, but
	      <varname>$0</varname> does not change. If you use a large number 
	      of positional parameters to a script, <command>shift</command>
	      lets you access those past <literal>10</literal>.</para>

	    <example id="ex19">
	      <title>Using <command>shift</command></title>
	      <programlisting>&ex19;</programlisting>
	    </example>
	  </listitem>
	</varlistentry>
      </variablelist>

      <sect2>
	<indexterm>
	  <primary>declare</primary>
	</indexterm>
	<indexterm>
	  <primary>typeset</primary>
	</indexterm>
	<indexterm>
	  <primary>command</primary>
	  <secondary>declare</secondary>
	</indexterm>
	<indexterm>
	  <primary>command</primary>
	  <secondary>typeset</secondary>
	</indexterm>
	<title>Typing variables: <command>declare</command> or <command>typeset</command></title>
	<para>The <command>declare</command> or <command>typeset</command>
	  keywords (they are exact synonyms) permit restricting the properties
	  of variables. This is a very weak form of the typing available in
	  certain programming languages. The <command>declare</command> command
	is not available in version 1 of <command>bash</command>.</para>

	<variablelist>
	  <varlistentry>
	    <term><token>-r</token> <replaceable>readonly</replaceable></term>
	    <listitem><para><programlisting>declare -r var1</programlisting></para>
	      <para>(<userinput>declare -r var1</userinput> works the same as
		<userinput>readonly var1</userinput>)</para>
	      <para>This is the rough equivalent of the C
		<command>const</command> type qualifier. An 
		attempt to change the value of a readonly variable fails with an 
		error message.</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>-i</token> <replaceable>integer</replaceable></term>
	    <listitem><para><programlisting>declare -i var2</programlisting></para>
	      <para>The script treats subsequent occurrences of
		<varname>var2</varname> as an integer.
		Note that certain arithmetic operations are permitted for declared
		integer variables without the need for 
		<command>expr</command> or 
		<command>let</command>.</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>-a</token> <replaceable>array</replaceable></term>
	    <listitem><para><programlisting>declare -a indices</programlisting></para>
	      <para>The variable <varname>indices</varname> will be treated as
		an array.</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>-f</token> <replaceable>functions</replaceable></term>
	    <listitem><para><programlisting>declare -f  # (no arguments)</programlisting></para>
	      <para>A <userinput>declare -f</userinput> line within a script causes
		a listing of all the functions contained in that script.</para></listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term><token>-x</token> <replaceable>export</replaceable></term>
	      <listitem><para><programlisting>declare -x var3</programlisting></para>
	      <para>This declares a variable as available for exporting outside the
		environment of the script itself.</para></listitem>
	  </varlistentry>

	</variablelist>

	<example id="ex20">
	  <title>Using <command>declare</command> to type variables</title>
	  <programlisting>&ex20;</programlisting>
	</example>

      </sect2> <!-- Typing variables: declare or typeset -->


      <sect2>
        <title>Indirect References to Variables</title>

	<para>Assume that the value of a variable is the name of a second
	  variable.  Is it somehow possible to retrieve the value
	  of this second variable from the first one? For example,
	  if <replaceable>a=letter_of_alphabet</replaceable>
	  and <replaceable>letter_of_alphabet=z</replaceable>,
	  can a reference to <replaceable>a</replaceable> return
	  <replaceable>z</replaceable>? This can indeed be done, and
	  it is called an <emphasis>indirect reference</emphasis>. It
	  uses the unusual <replaceable>eval var1=\$$var2</replaceable>
	  notation.</para>

      <example id="indref">
	<title>Indirect References</title>
	<programlisting>&indref;</programlisting>
      </example>

      <caution><para>This method of indirect referencing has a weakness. If
        the second order variable changes its value, an indirect reference to
	the first order variable produces an error. Fortunately, this flaw has
	been fixed in the newer <replaceable>${!variable}</replaceable>
	notation introduced with version 2 of Bash (see <xref
	linkend="ex78">).</para></caution>

      </sect2> <!-- Indirect References to Variables -->

      <sect2>
	<indexterm>
	  <primary>$RANDOM</primary>
	</indexterm>
	<indexterm>
	  <primary>variable</primary>
	  <secondary>$RANDOM</secondary>
	</indexterm>
	<title>$RANDOM: generate random integer</title>
	<note><para>$RANDOM is an internal Bash function (not a constant) that
	  returns a <emphasis>pseudorandom</emphasis> integer in the range
	  0 - 32767. $RANDOM should <replaceable>not</replaceable> be used
	  to generate an encryption key.</para></note>

	<example id="ex21">
	  <title>Generating random numbers</title>
	  <programlisting>&ex21;</programlisting>
	</example>

	<note><para>The variables <varname>$USER</varname>,
	  <varname>$USERNAME</varname>, <varname>$LOGNAME</varname>,
	  <varname>$MAIL</varname>, and <varname>$ENV</varname> are
	  <emphasis>not</emphasis> Bash builtins. These are, however,
	  often set as environmental variables in one of the Bash startup
	  files (see <xref linkend="files">). <varname>$SHELL</varname>
	  is a readonly variable set from <filename>/etc/passwd</filename>
	  and is likewise not a Bash builtin.</para></note>

      </sect2> <!-- RANDOM: generate random integer -->
    </sect1> <!-- Variables -->



    <sect1 id="loops">
      <title>Loops</title>

      <para>A <emphasis>loop</emphasis> is a block of code that iterates
        (repeats) a list of commands as long as the loop control condition is
	true.</para>

      <variablelist>
	<varlistentry>
	  <term><command>for (in)</command></term>
	  <indexterm>
	    <primary>for</primary>
	  </indexterm>
	  <indexterm>
	    <primary>in</primary>
	  </indexterm>
	  <indexterm>
	    <primary>do</primary>
	  </indexterm>
	  <indexterm>
	    <primary>done</primary>
	  </indexterm>
	  <indexterm>
	    <primary>loop</primary>
	    <secondary>for</secondary>
	  </indexterm>
	  <listitem>
	    <para>This is the basic looping construct. It differs significantly
	      from its C counterpart.</para>

	    <para><cmdsynopsis>
		<command>for</command>
		<arg choice="opt"><replaceable>arg</replaceable></arg>
		<arg choice="plain">in</arg>
		<arg choice="opt"><replaceable>list</replaceable></arg><sbr>
		<arg choice="plain">do</arg><sbr>
		<arg rep=repeat choice=plain><replaceable>&nbsp;command</replaceable></arg><sbr>
		<arg choice="plain">done</arg>
	      </cmdsynopsis></para>

	    <para>Note that <replaceable>list</replaceable> may contain wild cards.</para>

	    <para>Note further that if <command>do</command> is on same line as
	      <command>for</command>, there needs to be a semicolon before list.</para>

	    <para><cmdsynopsis>
		<command>for</command>
		<arg choice="opt"><replaceable>arg</replaceable></arg>
		<arg choice="plain">in</arg>
		<arg choice="opt"><replaceable>list</replaceable></arg>
		<arg choice="plain">;</arg>
		<arg choice="plain">do</arg><sbr>
	      </cmdsynopsis></para>

	    <example id="ex22">
	      <title>Simple <command>for</command> loops</title>
	      <programlisting>&ex22;</programlisting>
	    </example>

            
	    <note><para>Each <userinput>[list]</userinput> element
	      may contain multiple parameters. This is useful when
	      processing parameters in groups. In such cases, use the
	      <command>set</command> command (see <xref linkend="ex34">)
	      to force parsing of each <userinput>[list]</userinput>
	      element and assignment of each component to the positional
	      parameters.</para></note>

	    <example id="ex22a">
	      <title><command>for</command> loop with two parameters in each
	      [list] element</title>
	      <programlisting>&ex22a;</programlisting>
	    </example>


	    <para>Omitting the <userinput>in [list]</userinput> part of a
	      <command>for</command> loop causes the loop to operate on 
	      <token>$*</token>, the list of arguments given on the command line
	      to the script.</para>

	    <example id="ex23">
	      <title>Missing <userinput>in [list]</userinput> in a
		<command>for</command> loop</title>
	      <programlisting>&ex23;</programlisting>
	    </example>

	    <example id="ex24">
	      <title>Using <command>efax</command> in batch mode</title>
	      <programlisting>&ex24;</programlisting>
	    </example>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command>while</command></term>
	  <indexterm>
	    <primary>while</primary>
	  </indexterm>
	  <indexterm>
	    <primary>do</primary>
	  </indexterm>
	  <indexterm>
	    <primary>done</primary>
	  </indexterm>
	  <indexterm>
	    <primary>loop</primary>
	    <secondary>while</secondary>
	  </indexterm>
	  <listitem>
	    <para>This construct tests for a condition at the top of a loop, and keeps
	      looping as long as that condition is true.</para>

	    <para><cmdsynopsis>
		<command>while</command>
		<arg choice="opt"><replaceable>condition</replaceable></arg><sbr>
		<arg choice="plain">do</arg><sbr>
		<arg choice="plain" rep="repeat"><replaceable>&nbsp;command</replaceable></arg><sbr>
		<arg choice="plain">done</arg>
	      </cmdsynopsis></para>

	    <para>As is the case with <token>for/in</token> loops, placing the
	      <command>do</command> on the same line as the condition test
	      requires a semicolon.</para>

	    <para><cmdsynopsis>
		<command>while</command>
		<arg choice="opt"><replaceable>condition</replaceable></arg>
		<arg choice="plain">;</arg>
		<arg choice="plain">do</arg>
	      </cmdsynopsis></para>
	    
	    <para>Note that certain specialized <command>while</command> loops, as,
	      for example,  a <command>getopts</command> construct, deviate
	      somewhat from the standard template given here (see <xref
	      linkend="internal">).</para>

	    <example id="ex25">
	      <title>Simple <command>while</command> loop</title>
	      <programlisting>&ex25;</programlisting>
	    </example>
	    
	    <example id="ex26">
	      <title>Another <command>while</command> loop</title>
	      <programlisting>&ex26;</programlisting>
	    </example>	    


            <note><para>A <command>while</command> loop may have multiple
	      conditions. Only the final condition determines when the loop
	      terminates. This necessitates a slightly different loop syntax,
	      however.</para></note>

	    <example id="ex26a">
	      <title><command>while</command> loop with multiple conditions</title>
	      <programlisting>&ex26a;</programlisting>
	    </example>	    

	    <note><para>A <command>while</command> loop may have its
	      <emphasis>stdin</emphasis> redirected to a file by a
	      <token>&lt;</token> at its end (see <xref
	      linkend="redir2">).</para></note>

	    </listitem>
	  </varlistentry>



	<varlistentry>
	  <term><command>until</command></term>
	  <indexterm>
	    <primary>until</primary>
	  </indexterm>
	  <indexterm>
	    <primary>do</primary>
	  </indexterm>
	  <indexterm>
	    <primary>done</primary>
	  </indexterm>
	  <indexterm>
	    <primary>loop</primary>
	    <secondary>until</secondary>
	  </indexterm>

	  <listitem>
	    <para>This construct tests for a condition at the top of a loop, and keeps
	      looping as long as that condition is false (opposite of
	      <command>while</command> loop).</para>

	    <para><cmdsynopsis>
		<command>until</command>
		<arg choice="opt"><replaceable>condition-is-true</replaceable></arg><sbr>
		<arg choice="plain">do</arg><sbr>
		<arg choice="plain" rep="repeat"><replaceable>&nbsp;command</replaceable></arg><sbr>
		<arg choice="plain">done</arg>
	      </cmdsynopsis></para>

	    <para>Note that an <command>until</command> loop tests for the
	      terminating condition at the top of the loop, differing from a
	      similar construct in some programming languages.</para>

	    <para>As is the case with <token>for/in</token> loops, placing the
	      <command>do</command> on the same line as the condition test
	      requires a semicolon.</para>

	    <para><cmdsynopsis>
		<command>until</command>
		<arg choice="opt"><replaceable>condition-is-true</replaceable></arg>
		<arg choice="plain">;</arg>
		<arg choice="plain">do</arg>
	      </cmdsynopsis></para>

	    <example id="ex27">
	      <title><command>until</command> loop</title>
	      <programlisting>&ex27;</programlisting>
	    </example>	    
	    </listitem>
	  </varlistentry>

	<varlistentry>
	  <indexterm>
	    <primary>break</primary>
	  </indexterm>
	  <indexterm>
	    <primary>continue</primary>
	  </indexterm>
	  <indexterm>
	    <primary>loop</primary>
	    <secondary>break</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>loop</primary>
	    <secondary>continue</secondary>
	  </indexterm>
	  <term><command>break</command></term>
	  <term><command>continue</command></term>
	  <listitem>
	    <para>The <command>break</command> and <command>continue</command>
	      loop control commands correspond exactly to their counterparts in
	      other programming languages. The <command>break</command> command
	      terminates the loop (breaks out of it), while <command>continue</command>
	      causes a jump to the next iteration of the loop, skipping all the
	      remaining commands in that particular loop cycle.</para>

	    <example id="ex28">
	      <title>Effects of <command>break</command> and
		<command>continue</command> in a loop</title>
	      <programlisting>&ex28;</programlisting>
	    </example>	    
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>case (in) / esac</command></term>
	  <indexterm>
	    <primary>case</primary>
	  </indexterm>
	  <indexterm>
	    <primary>in</primary>
	  </indexterm>
	  <indexterm>
	    <primary>esac</primary>
	  </indexterm>
	  <indexterm>
	    <primary>switch</primary>
	  </indexterm>
	  <indexterm>
	    <primary>;;</primary>
	  </indexterm>
	  <indexterm>
	    <primary>menus</primary>
	  </indexterm>

	  <listitem>
	    <para>The <command>case</command> construct is the shell equivalent
	      of <command>switch</command>  in C/C++.
	      It permits branching to one of a number of code blocks, depending
	      on condition tests. It serves as a kind of shorthand for multiple
	      <token>if/then/else</token> statements and is an appropriate tool
	      for creating menus.</para>

	    <para><cmdsynopsis>
		<command>case</command>
		<arg choice="plain">"$<replaceable>variable</replaceable>"</arg>
		<arg choice="plain">in</arg><sbr><sbr>
		<arg choice="plain">&nbsp;"$<replaceable>condition1</replaceable>" )</arg><sbr>
		<arg choice="plain" rep="repeat">&nbsp;<replaceable>command</replaceable></arg><sbr>
		<arg choice="plain">&nbsp;;;</arg><sbr><sbr>
		<arg choice="plain">&nbsp;"$<replaceable>condition2</replaceable>" )</arg><sbr>
		<arg choice="plain" rep="repeat">&nbsp;<replaceable>command</replaceable></arg><sbr>
		<arg choice="plain">&nbsp;;;</arg><sbr><sbr>
		<arg choice="plain">esac</arg>
	      </cmdsynopsis></para>

	    <note><para>
	      <itemizedlist>
		<listitem><para>Quoting the variables is recommended.</para>
		</listitem>
		<listitem><para>Each test line ends with a left paren <token>)</token>.</para>
		</listitem>
		<listitem><para>Each condition block ends with a <emphasis>double</emphasis>
		    semicolon <token>;;</token>.</para>
		</listitem>
		<listitem><para>The entire <command>case</command> block terminates with an
	      <command>esac</command> (<wordasword>case</wordasword> spelled
		backwards).</para>
		  </listitem>
	      </itemizedlist>
	    </para></note>

	    <example id="ex29">
	      <title>Using <command>case</command></title>
	      <programlisting>&ex29;</programlisting>
	    </example>	    

	    <example id="ex30">
	      <title>Creating menus using <command>case</command></title>
	      <programlisting>&ex30;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command>select</command></term>
	  <indexterm>
	    <primary>select</primary>
	  </indexterm>
	  <indexterm>
	    <primary>menus</primary>
	  </indexterm>
	  <listitem>
	    <para>The <command>select</command> construct, adopted from the Korn
	      Shell, is yet another tool for building menus.</para>

	    <para><cmdsynopsis>
		<command>select</command>
		<arg choice="plain"><replaceable>variable</replaceable></arg>
		<arg choice="opt">in <replaceable>list</replaceable></arg><sbr>
		<arg choice="plain">do</arg><sbr>
		<arg choice="plain" rep="repeat">&nbsp;<replaceable>command</replaceable></arg><sbr>
		<arg choice="plain">&nbsp;break</arg><sbr>
		<arg choice="plain">done</arg>
	      </cmdsynopsis></para>
	    
	    <para>This prompts the user to enter one of the choices presented in the
	      variable list.  Note that <command>select</command> uses the
	      <varname>PS3</varname> prompt (<prompt>#? </prompt>) by default, 
		but that this may be changed.</para>
	    
	    <example id="ex31">
	      <title>Creating menus using <command>select</command></title>
	      <programlisting>&ex31;</programlisting>
	    </example>	    

	    <para>If <userinput>in <replaceable>list</replaceable></userinput> is
	      omitted, then <command>select</command> uses the list of command
	      line arguments (<varname>$@</varname>) passed to the script or to
	      the function in which the <command>select</command> construct is
	      embedded. (Compare this to the behavior of a 
	      <cmdsynopsis>
		<command>for</command>
		<arg choice="plain"><replaceable>variable</replaceable></arg>
		<arg choice="opt">in <replaceable>list</replaceable></arg>
	      </cmdsynopsis>
	      construct with the 
	      <userinput>in <replaceable>list</replaceable></userinput>
	      omitted.)</para>

	    <example id="ex32">
	      <title>Creating menus using <command>select</command> in a function</title>
	      <programlisting>&ex32;</programlisting>
	    </example>	    
	    </listitem>
	  </varlistentry>
      </variablelist>
      
    </sect1> <!-- Loops -->

    <sect1 id="internal">
      <title>Internal Commands and Builtins</title>
      <indexterm>
	<primary>builtin</primary>
      </indexterm>

      <para>A <firstterm>builtin</firstterm> is a command contained in the bash tool
	set, literally built in.</para>
      
      <variablelist>
	<varlistentry>
	  <term><command>getopts</command></term>
	  <indexterm>
	    <primary>getopts</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>getopts</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>$OPTIND</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$OPTIND</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>$OPTARG</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$OPTARG</secondary>
	  </indexterm>
	  <listitem>
	    <para>This powerful tool parses command line arguments passed to the
	      script. This is the bash analog of the <command>getopt</command>
	      library function familiar to C programmers. It permits passing and
	      concatenating multiple flags<footnote><para>A flag is an argument
		  that acts as a signal, switching script behaviors on or
		  off.</para></footnote> and options to a script (for example
	      <userinput>scriptname -abc -e /usr/local</userinput>).</para>

	    <para>The <command>getopts</command> construct uses two implicit
	      variables. <varname>$OPTIND</varname> is the argument pointer
	      (<wordasword>OPTion INDex</wordasword>) and
	      <varname>$OPTARG</varname> (<wordasword>OPTion ARGument</wordasword>)
	      the (optional) argument attached to a flag. A colon following the flag
	      name in the declaration tags that flag as having an option.</para>

	    <para>A <command>getopts</command> construct usually comes packaged
	      in a <command>while</command> loop, which processes the flags and
	      options one at a time, then decrements the implicit
	      <varname>$OPTIND</varname> variable to step to the next.</para>

	    <note>
	      <para>
		<orderedlist>
		  <listitem><para>The arguments must be passed from the command line to the
		      script preceded by a minus (<option>-</option>) or a plus
		      (<option>+</option>), else <command>getopts</command> will 
		      not process them, and will, in fact, terminate option
		      processing at the first argument encountered lacking these
		      modifiers.</para>
		  </listitem>
		  <listitem><para>The <command>getopts</command> template
		      differs slightly from the standard <command>while</command>
		      loop, in that it lacks condition brackets.</para>
		  </listitem>
		  <listitem><para>The <command>getopts</command>
		      construct replaces the obsolete <command>getopt</command>
		      command.</para></listitem>
		</orderedlist>
	      </para>
	    </note>

	    <para><programlisting>
while getopts ":abcde:fg" Option
# Initial declaration.
# a, b, c, d, e, f, and g are the flags expected.
# The : after flag 'e' shows it will have an option passed with it.
do
  case $Option in
    a ) # Do something with variable 'a'.
    b ) # Do something with variable 'b'.
    ...
    e)  # Do something with 'e', and also with $OPTARG,
        # which is the associated argument passed with 'e'.
    ...
    g ) # Do something with variable 'g'.
  esac
done
shift $(($OPTIND - 1))
# Move argument pointer to next.

# All this is not nearly as complicated as it looks &lt;grin&gt;.
	      </programlisting></para>

	    <example id="ex33">
	      <title>Using <command>getopts</command> to read the flags/options
		  passed to a script</title>
	      <programlisting>&ex33;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>exit</command></term>
	  <indexterm>
	    <primary>exit</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>exit</secondary>
	  </indexterm>
	  <listitem><para>Unconditionally terminates a script. The
	      <command>exit</command> command may optionally take an integer
	      argument, which is returned to the shell as the <firstterm>exit
		status</firstterm> of the script. It is a good practice to end all
	      but the simplest scripts with an <userinput>exit 0</userinput>,
	      indicating a successful run.</para>
	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term><command>set</command></term>
	  <indexterm>
	    <primary>set</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>set</secondary>
	  </indexterm>
	  <listitem><para>The <command>set</command> command changes the value
	      of internal script variables. One use for this is to toggle
	      option flags which help determine the behavior of the
	      script (see <xref linkend="options">). Another application
	      for it is to reset the positional parameters that a
	      script sees as the result of a command (<userinput>set
	      `command`</userinput>). The script can then parse the
	      fields of the command output.</para>

	    <example id="ex34">
	      <title>Using <command>set</command> with positional
	      parameters</title> <programlisting>&ex34;</programlisting>
	    </example>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>unset</command></term>
	  <indexterm>
	    <primary>unset</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>unset</secondary>
	  </indexterm>
	  <listitem><para>The <command>unset</command> command deletes an
	      internal script variable. It is a way of negating a previous
	      <command>set</command>. Note that this command does not affect 
	      positional parameters.</para>
	    </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><command>export</command></term>
	  <indexterm>
	    <primary>export</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>export</secondary>
	  </indexterm>
	  <listitem><para>The <command>export</command> command makes
	      available variables to all child processes of the
	      running script or shell. Unfortunately, there is no way
	      to <command>export</command> variables back to the parent
	      process, to the process that called or invoked the script
	      or shell. One important use of <command>export</command>
	      command is in startup files, to initialize and make
	      accessible environmental variables to subsequent user
	      processes (see <xref linkend="files">).</para>
	      
	      <note><para>It is possible to initialize and export
		variables in the same operation, as in <command>export
		var1=xxx</command>.</para></note>

	    </listitem>
	  </varlistentry>
	
	<varlistentry>
	  <term><command>readonly</command></term>
	  <indexterm>
	    <primary>readonly</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>readonly</secondary>
	  </indexterm>
	  <listitem><para>Same as <userinput>declare -r</userinput>, sets a variable
	      as read-only, or, in effect, as a constant. Attempts to change the
	      variable fail with an error message. This is the shell analog of
	      the C language <command>const</command> type qualifier.</para>
	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term><command>basename</command></term>
	  <indexterm>
	    <primary>basename</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>basename</secondary>
	  </indexterm>
	  <listitem><para>Strips the path information from a file name, printing
	      only the file name. The construction  <userinput>basename
		$0</userinput> lets the script know its name, that is, the name it
	      was invoked by. This can be used for <quote>usage</quote> messages if, 
	      for example a script is called with missing arguments:
              <programlisting>echo "Usage: `basename $0` arg1 arg2 ... argn"</programlisting>
	    </para>

	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term><command>dirname</command></term>
	  <indexterm>
	    <primary>dirname</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>dirname</secondary>
	  </indexterm>
	  <listitem><para>Strips the <command>basename</command> from a file
	      name, printing only the path information.</para>
	    <note>
	      <para><command>basename</command> and <command>dirname</command>
		can operate on any arbitrary string. The filename given as an
		argument does not need to refer to an existing file.</para>
	    </note>
	    
	    <example id="ex35">
	      <title><command>basename</command> and <command>dirname</command></title>
	      <programlisting>&ex35;</programlisting>
	    </example>	    
	    
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>read</command></term>
	  <indexterm>
	    <primary>read</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>read</secondary>
	  </indexterm>
	  <listitem><para><quote>Reads</quote> the value of a variable from stdin,
	    that is, interactively fetches input from the keyboard. The <option>-a</option>
	    option lets <command>read</command> get array variables (see 
	      <xref linkend="ex67">).</para>

	    <example id="ex36">
	      <title>Variable assignment, using <command>read</command></title>
	      <programlisting>&ex36;</programlisting>
	    </example>

	    <para>The <command>read</command> command may also
	      <quote>read</quote> its variable value from a file
	      redirected to <filename>stdin</filename> (see <xref
	      linkend="io-redirection">). If the file contains more
	      than one line, only the first line is assigned to the
	      variable. If there is more than one parameter to the
	      <command>read</command>, then each variable gets assigned
	      a successive whitespace delineated string. Caution!</para>

	    <para><programlisting>
read var1 &lt;data-file
echo "var1 = $var1"
# var1 set to the entire first line of the input file "data-file"

read var2 var3 &lt;data-file
echo "var2 = $var2   var3 = $var3"
# Note inconsistent behavior of "read" here.
# 1) Rewinds back to the beginning of input file.
# 2) Each variable is now set to a corresponding string, separated by whitespace,
#    rather than to an entire line of text.
# 3) The final variable gets the remainder of the line.
# 4) If there are more variables to be set than whitespace-terminated strings
#    on the first line of the file, then the excess variable remain unset.
</programlisting></para>

	    </listitem>
	  </varlistentry>

      <varlistentry>
	<term><command>true</command></term>
	  <indexterm>
	    <primary>true</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>true</secondary>
	  </indexterm>
	  <listitem><para>A command that returns a successful
	    (<errorcode>zero</errorcode>) exit status, but does nothing else.
	  </para>

	  <para><programlisting># Endless loop
while true
# alias for :
do
   operation-1
   operation-2
   ...
   operation-n
   # Need a way to break out of loop.
done</programlisting></para>

	    </listitem>
	  </varlistentry>

      <varlistentry>
	<term><command>false</command></term>
	  <indexterm>
	    <primary>false</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>false</secondary>
	  </indexterm>
	  <listitem><para>A command that returns an unsuccessful exit status,
	    but does nothing else.</para>

	  <para><programlisting># Null loop
while false
do
   # The following code will not execute.
   operation-1
   operation-2
   ...
   operation-n
   # Nothing happens!
done   
</programlisting></para>

	    </listitem>
	  </varlistentry>

      <varlistentry>
	<term><command>factor</command></term>
	  <indexterm>
	    <primary>factor</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>factor</secondary>
	  </indexterm>
	  <listitem><para>Factor an integer into prime factors.</para>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>factor 27417</userinput>
<computeroutput>27417: 3 13 19 37</computeroutput>
	      </screen>
	    </para>

	    </listitem>
	  </varlistentry>

      <varlistentry>
	<term><command>hash [cmds]</command></term>
	  <indexterm>
	    <primary>hash</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>hash</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>$PATH</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PATH</secondary>
	  </indexterm>
	  <listitem><para>Record the path name of specified commands (in the
	      shell hash table), so the shell or script will not need to search
	      the <varname>$PATH</varname> on subsequent calls to those
		commands. When <command>hash</command> is called with no
	      arguments,  it simply lists the commands that have been hashed.
	    </para>
	  </listitem>
	</varlistentry>

      <varlistentry>
	<term><command>pwd</command></term>
	  <indexterm>
	    <primary>pwd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>pwd</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>$PWD</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PWD</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>directory</primary>
	    <secondary>working</secondary>
	  </indexterm>
	  <listitem><para>Print Working Directory. This gives the user's
	      (or script's) current directory (see <xref
	      linkend="ex37">). The effect is identical to reading the
	      value of the builtin variable <command>$PWD</command>
	      (see <xref linkend="variables2">).</para>
	  </listitem>
	</varlistentry>

      <varlistentry>
	<term><command>pushd</command></term>
	<term><command>popd</command></term>
	<term><command>dirs</command></term>
	  <indexterm>
	    <primary>pushd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>pushd</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>popd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>popd</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>dirs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>dirs</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>directory</primary>
	    <secondary>working</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>bookmark</primary>
	  </indexterm>
	  <listitem><para>This command set is a mechanism for bookmarking working directories,
	      a means of moving back and forth through directories in an orderly
	      manner.  A pushdown stack is used to keep track of directory names.
	      Options allow various manipulations of the directory stack.</para>

	    <para><userinput>pushd dir-name</userinput> pushes the path
	      <replaceable>dir-name</replaceable> onto the directory 
	      stack and simultaneously changes the current working directory to
	      <replaceable>dir-name</replaceable></para>

	    <para><command>popd</command> removes (pops) the top directory path
	      name off the directory stack and simultaneously changes the
	      current working directory to that directory popped from the stack.
	      </para>
	    
	    <para><command>dirs</command> lists the contents of the directory
	      stack (counterpart to <varname>$DIRSTACK</varname>,
	      see below).  A successful <command>pushd</command>
	      or <command>popd</command> will automatically invoke
	      <command>dirs</command>.</para>


	    <para>Scripts that require various changes to the current
	      working directory without hard-coding the directory name
	      changes can make good use of these commands. Note that
	      the implicit <varname>$DIRSTACK</varname> array variable,
	      accessible from within a script, holds the contents of
	      the directory stack.
	    </para>

	    <example id="ex37">
	      <title>Changing the current working directory   </title>
	      <programlisting>&ex37;</programlisting>
	    </example>	    
	    
	  </listitem>
	</varlistentry>

      <varlistentry>
	<term><command>source</command></term>
	<term><token>.</token> (<command>dot</command> command)</term>
	<term><command>dirs</command></term>
	  <indexterm>
	    <primary>source</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>source</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>.</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>.</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>dirs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>dirs</secondary>
	  </indexterm>

	  <listitem><para>This command, when invoked from the command line, executes a script. Within
	      a script, a <userinput>source file-name</userinput> loads the file
	      <filename>file-name</filename>. This is the 
	      shell scripting equivalent of a C/C++ <userinput>#include</userinput>
	      directive. It is useful in situations when multiple scripts use a
	      common data file or function library.</para>

	    <example id="ex38">
	      <title><quote>Including</quote> a data file</title>
	      <programlisting>&ex38;</programlisting>
	      <para>File <filename>data-file</filename> for <xref linkend="ex38">, above.
		Must be present in same directory.</para>
	      <programlisting>&ex38bis;</programlisting>
	    </example>	    
	    
	    </listitem>
	  </varlistentry>

      </variablelist>

      <sect2>
	<title>Job Control Commands</title>

	<variablelist>

	<varlistentry>
	  <term><command>ps</command></term>
	  <indexterm>
	    <primary>ps</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ps</secondary>
	  </indexterm>
	  <listitem>
	    <para>Lists currently executing jobs by owner and process
	      id. This is usually invoked with <option>ax</option>
	      options, and may be piped to <command>grep</command> or
	      <command>sed</command> to search for a specific process
	      (see <xref linkend="ex44">).</para>

	    <screen><prompt>bash$ </prompt><userinput> ps ax | grep sendmail</userinput>
<computeroutput>295 ?	   S	  0:00 sendmail: accepting connections on port 25</computeroutput></screen>

	  </listitem>
	</varlistentry>

	  <varlistentry>
	    <term><command>wait</command></term>
	  <indexterm>
	    <primary>wait</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>wait</secondary>
	  </indexterm>
	    <listitem>
	      <para>Stop script execution until all jobs running in
	       background have terminated, or until the job number
	       specified as an option terminates. Sometimes used to
	       prevent a script from exiting before a background
	       job finishes executing (this would create a dreaded
	       orphan process).</para>

	    <example id="ex39">
	      <title>Waiting for a process to finish before proceeding</title>
	      <programlisting>&ex39;</programlisting>
	    </example>	    

	    </listitem>
	  </varlistentry>


	  <varlistentry>
	    <term><command>suspend</command></term>
	    <indexterm>
	      <primary>suspend</primary>
	    </indexterm>
	    <indexterm>
	      <primary>command</primary>
	      <secondary>suspend</secondary>
	    </indexterm>
	    <listitem>
	      <para>This has the same effect as
		<keycombo><keycap>Control</keycap><keycap>Z</keycap></keycombo>, 
		pausing a foreground job.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>stop</command></term>
	    <indexterm>
	      <primary>stop</primary>
	    </indexterm>
	    <indexterm>
	      <primary>command</primary>
	      <secondary>stop</secondary>
	    </indexterm>
	    <listitem>
	      <para>This has the same effect as <command>suspend</command>, but
		for a background job.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>disown</command></term>
	  <indexterm>
	    <primary>disown</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>disown</secondary>
	  </indexterm>
	    <listitem>
	      <para>Remove job(s) from the shell's table of active jobs.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>jobs</command></term>
	  <indexterm>
	    <primary>jobs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>jobs</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>ps</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ps</secondary>
	  </indexterm>
	    <listitem>
	      <para>Lists the jobs running in the background, giving the job number.
		Not as useful as <command>ps</command>.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>times</command></term>
	  <indexterm>
	    <primary>times</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>times</secondary>
	  </indexterm>
	    <listitem>
	      <para>Gives statistics on the system time used in executing commands, in the
		following form:
		<screen><computeroutput>0m0.020s 0m0.020s</computeroutput></screen>
		This capability is of very limited value, since it is uncommon to
		profile and benchmark shell scripts.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>kill</command></term>
	  <indexterm>
	    <primary>kill</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>kill</secondary>
	    </indexterm>
	    <listitem>
	      <para>Forcibly terminate a process by sending it an
	      appropriate <emphasis>terminate</emphasis> signal (see <xref
	      linkend="killprocess">).</para>
	      
	      <note><para><userinput>kill -l</userinput> lists all the
		<quote>signals</quote>. (See <xref linkend="debugging">
		for more detail on signals).</para></note>
	    </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><command>command</command></term>
	  <indexterm>
	    <primary>command</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>command</secondary>
	  </indexterm>
	  <listitem><para>The <command>command</command> directive
	    disables aliases and functions. This leaves only shell builtins,
	    system commands, and commands and scripts accessible via
	    <varname>$PATH</varname>.</para>

	    <note><para>This is one of three shell directives that
	      effect script command processing. The others are
	      <command>builtin</command> and <command>enable</command>,
	      see below.</para></note>
	    </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><command>builtin</command></term>
	  <indexterm>
	    <primary>builtin</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>builtin</secondary>
	  </indexterm>
	  <listitem><para>This disables both functions and 
	      commands in the <varname>$PATH</varname>,
	      leaving only shell builtins accessible.</para>
	    </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><command>enable</command></term>
	  <indexterm>
	    <primary>enable</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>enable</secondary>
	  </indexterm>
	  <listitem><para>This either enables or disables a shell
	      builtin command. As an example, <command>enable
	      -n kill</command> disables the shell builtin
	      <command>kill</command>, so that when Bash subsequently
	      encounters <command>kill</command>, it invokes
	      <filename>/bin/kill</filename>. The <option>-a</option>
	      option lists all the shell builtins, indicating whether
	      or not they are enabled.</para>
	    </listitem>
	  </varlistentry>

	</variablelist>

      </sect2> <!-- Job Control Commands -->
    </sect1> <!-- Internal Commands and Builtins -->



    <sect1 id="external">
      <title>External Filters, Programs and Commands</title>
      <para>This is a descriptive listing of standard UNIX commands useful in shell
	scripts. The power of scripts comes from coupling system commands and
	shell directives with simple programming constructs.</para>

      <sect2 id="basic">
        <title>Basic Commands</title>

      <variablelist>

	<varlistentry>
	  <term><command>echo</command></term>
	  <indexterm>
	    <primary>echo</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>echo</secondary>
	  </indexterm>
	  <listitem>
	    <para>prints (to <filename>stdout</filename>) an expression
	      or variable (see <xref linkend="ex9">). 
	      <programlisting>echo Hello
echo $a</programlisting></para>
	    
	    <para>Normally, each <command>echo</command> command prints a terminal newline, but
	      the <option>-n</option> option suppresses this.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>ls</command></term>
	  <indexterm>
	    <primary>ls</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ls</secondary>
	  </indexterm>
	  <listitem>
	    <para>The basic file <quote>list</quote> command. It is all too easy
	      to underestimate the power of this humble command. For example,
	      using the <option>-R</option>, recursive option,
	      <command>ls</command> provides a tree-like listing of a directory
	      structure.</para>

	    <example id="ex40">
	      <title>Using <command>ls</command> to create a table of contents
		for burning a <abbrev>CDR</abbrev> disk</title>
	      <programlisting>&ex40;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>cat</command></term>
	  <term><command>tac</command></term>
	  <indexterm>
	    <primary>cat</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cat</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>tac</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tac</secondary>
	  </indexterm>
	  <listitem>
	    <para><command>cat</command>, an acronym for
	    <wordasword>concatenate</wordasword>,
	      lists a file to stdout. When combined with redirection
	      (<token>></token> or <token>>></token>), it is commonly
	      used to concatenate files.  <programlisting>cat filename
              cat file.1 file.2 file.3 > file.123</programlisting>
              The <replaceable>-n</replaceable> option to
              <command>cat</command> inserts consecutive numbers before
              each line of the target file(s).</para>

	    <para><command>tac</command>, is the inverse of
	      <wordasword>cat</wordasword>, listing a file backwards from its end.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>rev</command></term>
	  <indexterm>
	    <primary>rev</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rev</secondary>
	  </indexterm>
	  <listitem>
	    <para>reverses each line of a file, and outputs to stdout.
	      This is not the same effect as <command>tac</command>,
	      as it preserves the order of the lines, but flips each
	      one around.</para>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>cat file1.txt</userinput>
<computeroutput>This is line 1.
 This is line 2.</computeroutput>
	      </screen>
	    </para>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>tac file1.txt</userinput>
<computeroutput>This is line 2.
 This is line 1.</computeroutput>
	      </screen>
	    </para>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>rev file1.txt</userinput>
<computeroutput>.1 enil si sihT
 .2 enil si sihT</computeroutput>
	      </screen>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>cd</command></term>
	  <indexterm>
	    <primary>cd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cd</secondary>
	  </indexterm>
	  <listitem>
	    <para>The familiar <command>cd</command> change directory command finds use in scripts where
	      execution of a command requires being in a specified directory.
	      <programlisting>(cd /source/directory && tar cf - . ) | (cd /dest/directory && tar xvfp -)</programlisting>
	      [from the previously cited example by Alan Cox]</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>cp</command></term>
	  <indexterm>
	    <primary>cp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cp</secondary>
	  </indexterm>
	  <listitem>
	    <para>This is the file copy command. <userinput>cp file1
	      file2</userinput> copies <filename>file1</filename>
	      to <filename>file2</filename>, overwriting
	      <filename>file2</filename> if it already exists (see <xref
	      linkend="ex42">).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>mv</command></term>
	  <listitem>
	    <para>This is the file move command. It is equivalent to a combination of
	      <command>cp</command> and <command>rm</command>. It may be used to
	      move multiple files to a directory. For some examples of using
	      <command>mv</command> in a script, see <xref linkend="rfe"> and
	      <xref linkend="rn">.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>rm</command></term>
	  <indexterm>
	    <primary>rm</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rm</secondary>
	  </indexterm>
	  <listitem>
	    <para>Delete (remove) a file or files. The <option>-f</option>
	      forces removal of even readonly files.</para> 

	    <warning><para>When used with the recursive flag
	      <option>-r</option>, this command removes files all the way
	      down the directory tree.</para></warning>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>rmdir</command></term>
	  <indexterm>
	    <primary>rmdir</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rmdir</secondary>
	  </indexterm>
	  <listitem>
	    <para>Remove directory. The directory must be empty of all files,
	      including dotfiles, for this command to succeed.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>mkdir</command></term>
	  <indexterm>
	    <primary>mkdir</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mkdir</secondary>
	  </indexterm>
	  <listitem>
	    <para>Make directory, creates a new directory.
	      <userinput>mkdir -p project/programs/December</userinput>
	      creates the named directory. The
	      <replaceable>-p</replaceable> option automatically creates
	      any necessary parent directories.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>chmod</command></term>
	  <indexterm>
	    <primary>chmod</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>chmod</secondary>
	  </indexterm>
	  <listitem>

	    <para>Changes the attributes of an existing file (see <xref
	      linkend="ex44">).</para>

	    <para><programlisting>chmod +x filename
# Makes "filename" executable for all users.</programlisting></para>

	    <para><programlisting>chmod 644 filename
# Makes "filename" readable/writable to owner, readable to
# others
# (octal mode).</programlisting></para>

	    <para><programlisting>chmod 1777 directory-name
# Gives everyone read, write, and execute permission in directory,
# however also sets the "sticky bit", which means that
# only the directory owner can change files in the directory.</programlisting></para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>chattr</command></term>
	  <indexterm>
	    <primary>chattr</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>chattr</secondary>
	  </indexterm>
	  <listitem>
	    <para>Change file attributes. This has the same effect
	      as <command>chmod</command> above, but with a different
	      invocation syntax.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>ln</command></term>
	  <listitem>

	    <para>Creates links to pre-existings files. Most often used
	      with the <option>-s</option>, symbolic or
	      <quote>soft</quote> link flag. This permits referencing
	      the linked file by more than one name and is a superior
	      alternative to aliasing (see <xref linkend="ex18">).</para>

	      <para><userinput>ln -s oldfile newfile</userinput>
		links the previously existing
		<filename>oldfile</filename> to the newly created link,
		<filename>newfile</filename>.</para>

	  </listitem>
	</varlistentry>

      </variablelist>

        </sect2> <!-- End Basic Commands -->


      <sect2 id="moreadv">
        <title>Complex Commands</title>

      <variablelist>

	<varlistentry>
	  <term><command>find</command></term>
	  <indexterm>
	    <primary>find</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>find</secondary>
	  </indexterm>

	  <indexterm>
	    <primary>{}</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>{}</secondary>
	  </indexterm>

	  <indexterm>
	    <primary>\;</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\;</secondary>
	  </indexterm>

	  <listitem>
	    <para>exec <replaceable>COMMAND</replaceable> \;</para>
	    <para>Carries out <replaceable>COMMAND</replaceable> on
	      each file that <command>find</command> scores a hit
	      on.  <replaceable>COMMAND</replaceable> terminates
	      with <token>\;</token> (the <token>;</token>
	      is escaped to make certain the shell passes it to
	      <command>find</command> literally, which concludes the
	      command sequence). If <replaceable>COMMAND</replaceable>
	      contains <token>{}</token>, then <command>find</command>
	      substitutes the full path name of the selected file.</para>

	    <example id="ex57">
	      <title><command>Badname</command>, eliminate file names
		in current directory containing bad characters and
		white space.</title>
	      <programlisting>&ex57;</programlisting>
	    </example>

	    <para>See the man page for <command>find</command> for more
	      detail.</para>


	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>xargs</command></term>
	  <indexterm>
	    <primary>xargs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>xargs</secondary>
	  </indexterm>
	  <listitem>
	    <para>A filter for feeding arguments to a command, and also a tool for
	      assembling the commands themselves. It breaks a data stream into small
	      enough chunks for filters and commands to process.  Consider it as a
	      powerful replacement for backquotes.  In situations where backquotes
	      fail with a <errorname>too many arguments</errorname> error,
	      substituting <command>xargs</command> often works. Normally, xargs
	      reads from 'stdin' or from a pipe, but it can also be given the
	      output of a file.</para>
	    
	    <para><userinput>ls | xargs -p -l gzip</userinput> gzips every file in
	      current directory, one at a time, prompting before each operation.</para>

	    <para>One of the more interesting xargs options is 
	      <option>-n <replaceable>XX</replaceable></option>, which limits
	      the number of arguments passed to <replaceable>XX</replaceable>.</para> 

	    <para><userinput>ls | xargs -n 8 echo</userinput> lists the files in the
	      current directory in <literal>8</literal> columns.</para>

	     <note><para>The default command for <command>xargs</command> is
	     <command>echo</command>.</para></note> 


	    <example id="ex41">
	      <title>Log file using <command>xargs</command> to monitor system log</title>
	      <programlisting>&ex41;</programlisting>
	    </example>	    

	    <example id="ex42">
	      <title><command>copydir</command>, copying files in current
		directory to another, using <command>xargs</command></title>
	      <programlisting>&ex42;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><userinput>eval arg1, arg2, ...</userinput></term>
	  <indexterm>
	    <primary>eval</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>eval</secondary>
	  </indexterm>
	  <listitem>
	    <para>Translates into commands the arguments in a list
	      (useful for code generation within a script).</para>

	    <example id="ex43">
	      <title>Showing the effect of <command>eval</command></title>
	      <programlisting>&ex43;</programlisting>
	    </example>	    

	    <example id="ex44">
	      <title>Forcing a log-off</title>
	      <programlisting>&ex44;</programlisting>
	    </example>	    
	    
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><userinput>expr arg1 operation arg2 ...</userinput></term>
	  <indexterm>
	    <primary>expr</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>expr</secondary>
	  </indexterm>
	  <listitem>
	    <para>All-purpose expression evaluator:
	      Concatenates and evaluates the arguments according
	      to the operation given (arguments must be separated
	      by spaces). Operations may be arithmetic, comparison,
	      string, or logical.</para>

	    <variablelist>
	      <varlistentry>
		<term><userinput>expr 3 + 5</userinput></term>
		<listitem>
		  <para>returns <literal>8</literal></para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><userinput>expr 5 % 3</userinput></term>
		<listitem>
		  <para>returns 2</para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><userinput>y=`expr $y + 1`</userinput></term>
		<listitem>
		  <para>incrementing variable, same as <userinput>let y=y+1</userinput> and
		    <userinput>y=$(($y+1))</userinput>, as discussed elsewhere</para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><userinput>z=`expr substr $string28 $position $length`</userinput></term>
		<listitem>
		  <para>Note that external programs, such as
		    <command>sed</command> and <command>Perl</command> have far superior 
		    string parsing facilities, and it might well be advisable to use
		    them instead of the built-in bash ones.</para>
		</listitem>
	      </varlistentry>
	    </variablelist>

	    <example id="ex45">
	      <title>Using <command>expr</command></title>
	      <programlisting>&ex45;</programlisting>
	    </example>	    
	    
	    <para>Note that <token>:</token> can substitute for <command>match</command>.
	      <userinput>b=`expr $a : [0-9]*`</userinput> is an exact equivalent of
	      <userinput>b=`expr match $a [0-9]*`</userinput> in the above example.</para>
	  
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>let</command></term>
	  <indexterm>
	    <primary>let</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>let</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>let</command> command carries out arithmetic
	      operations on variables. In many cases, it functions as a less
	      complex version of <command>expr</command>.</para>

	    <example id="ex46">
	      <title>Letting <command>let</command> do some arithmetic.</title>
	      <programlisting>&ex46;</programlisting>
	    </example>	    
	    
	  </listitem>
	</varlistentry>

       </variablelist>
       
        </sect2> <!-- End Complex Commands -->



      <sect2 id="timedate">
        <title>Time / Date Commands</title>

       <variablelist>

	<varlistentry>
	  <term><command>date</command></term>
	  <indexterm>
	    <primary>date</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>date</secondary>
	  </indexterm>
	  <listitem>
	    <para>Simply invoked, <command>date</command> prints the date and
	      time to stdout. Where this command gets interesting is in its
	      formatting and parsing options.</para>

	    <example id="ex51">
	      <title>Using <command>date</command></title>
	      <programlisting>&ex51;</programlisting>
	    </example>	    	   

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>time</command></term>
	  <indexterm>
	    <primary>time</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>time</secondary>
	  </indexterm>
	  <listitem>
	    <para>Outputs very verbose timing statistics for executing a command.</para>
	    <para><userinput>time ls -l /</userinput> gives something like this:
<screen><computeroutput>0.00user 0.01system 0:00.05elapsed 16%CPU (0avgtext+0avgdata 0maxresident)k
0inputs+0outputs (149major+27minor)pagefaults 0swaps</computeroutput></screen>
	  </para>
	  <para>See also the very similar <command>times</command> command
	    in the previous section.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>touch</command></term>
	  <indexterm>
	    <primary>touch</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>touch</secondary>
	  </indexterm>
	  <listitem>
	    <para>Utility for updating access/modification times of a
	      file to current system time or other specified time,
	      but also useful for creating a new file. The command
	      <userinput>touch zzz</userinput> will create a new file
	      of zero length, named <filename>zzz</filename>, assuming
	      that <filename>zzz</filename> did not previously exist.
	      Time-stamping empty files in this way is useful for
	      storing date information, for example in keeping track of
	      modification times on a project. See <xref linkend="ex12">.
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>at</command></term>
	  <indexterm>
	    <primary>at</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>at</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>cron</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cron</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>at</command> job control command executes a given
	      set of commands at a specified time. This is a user version of
	      <command>cron</command>.</para>
	    
	    <para><userinput>at 2pm January 15</userinput> prompts for a set of
	      commands to execute at that time. These commands may include
	      executable shell scripts.</para>

	    <para>Using either the <option>-f</option> option or input
	      redirection (<token><</token>), <command>at</command>
	      reads a command list from a file. This file can
	      include shell scripts, though they should, of course,
	      be noninteractive.</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>at 2:30 am Friday < at-jobs.list</userinput>
<computeroutput>job 2 at 2000-10-27 02:30</computeroutput>
	      </screen>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>batch</command></term>
	  <indexterm>
	    <primary>batch</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>batch</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>at</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>at</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>batch</command> job control command is similar to
	      <command>at</command>, but it runs a command list when the system
	      load drops below <literal>.8</literal>. Like
	      <command>at</command>, it can read commands from a file with the
	      <option>-f</option> option.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>cal</command></term>
	  <indexterm>
	    <primary>cal</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cal</secondary>
	  </indexterm>
	  <listitem>
	    <para>Prints a neatly formatted monthly calendar to
	      <filename>stdout</filename>. Will do current year or a large
	      range of past and future years.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>sleep</command></term>
	  <indexterm>
	    <primary>sleep</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sleep</secondary>
	  </indexterm>
	  <listitem>
	    <para>This is the shell equivalent of a wait loop. It pauses for a
	      specified number of seconds, doing nothing. This can be useful for
	      timing or in processes running in the background, checking for a
	      specific event every so often (see <xref linkend="online">).
	      <programlisting>sleep 3
# Pauses 3 seconds.</programlisting>
	    </para>
	  </listitem>
	</varlistentry>

       </variablelist>
       
        </sect2> <!-- End Time / Date Commands -->




      <sect2 id="textproc">
        <title>Text Processing Commands</title>

       <variablelist>

	<varlistentry>
	  <term><command>sort</command></term>
	  <indexterm>
	    <primary>sort</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sort</secondary>
	  </indexterm>
	  <listitem>
	    <para>File sorter, often used as a filter in a pipe. See the man page
	      for options.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>diff</command></term>
	  <indexterm>
	    <primary>diff</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>diff</secondary>
	  </indexterm>
	  <listitem>
	    <para>Simple file comparison utility. This compares
	      the target files line-by-line sequentially.  In some
	      applications, such as comparing word dictionaries,
	      it may be helpful to filter the files through
	      <command>sort</command> and <command>uniq</command> before
	      piping them to <command>diff</command>. <userinput>diff
	      file-1 file-2</userinput> outputs the lines in the
	      files that differ, with carets showing which file
	      each particular line belongs to.	A common use for
	      <command>diff</command> is generating difference files
	      to be used with <command>patch</command> (see below).
	      The <option>-e</option> option outputs files suitable
	      for <command>ed</command> or <command>ex</command>
	      scripts.</para>

	    <para><programlisting>patch -p1 &lt;patch-file
# Takes all the changes listed in 'patch-file' and applies them
# to the files referenced therein.

cd /usr/src
gzip -cd patchXX.gz | patch -p0
# Upgrading kernel source using 'patch'.
# From the Linux kernel docs "README",
# by anonymous author (Alan Cox?).</programlisting></para>

          <para>There are available various fancy frontends for
	    <command>diff</command>, such as <command>spiff</command>,
	    <command>wdiff</command>, <command>xdiff</command>, and
	    <command>mgdiff</command>. </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>comm</command></term>
	  <indexterm>
	    <primary>comm</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>comm</secondary>
	  </indexterm>
	  <listitem>
	    <para>Versatile file comparison utility. The files must be sorted for this to be
	      useful.</para>

	    <para><command>comm
		<replaceable>-options</replaceable>
		<replaceable>first-file</replaceable>
		<replaceable>second-file</replaceable></command></para>

	    <para><userinput>comm file-1 file-2</userinput> outputs three columns:
	      <itemizedlist>
		<listitem><para>column 1 = lines unique to <filename>file-1</filename></para>
		</listitem>
		
		<listitem><para>column 2 = lines unique to <filename>file-2</filename></para>
		</listitem>
		
		<listitem><para>column 3 = lines common to both.</para>
		</listitem>
	      </itemizedlist></para>
	      
	    <para>The options allow suppressing output of one or more columns.
	      <itemizedlist>
		<listitem><para><option>-1</option> suppresses column
		    <literal>1</literal></para>
		</listitem>
		<listitem><para><option>-2</option> suppresses column
		    <literal>2</literal></para>
		</listitem>
		<listitem><para><option>-3</option> suppresses column
		    <literal>3</literal></para>
		</listitem>
		<listitem><para><option>-12</option> suppresses both columns
		    <literal>1</literal> and <literal>2</literal>, etc.</para>
		</listitem>
		</itemizedlist>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>uniq</command></term>
	  <indexterm>
	    <primary>uniq</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uniq</secondary>
	  </indexterm>
	  <listitem>
	    <para>This filter removes duplicate lines from a sorted
	      file. It is often seen in a pipe coupled with
	      <command>sort</command>.
	      <programlisting>cat list-1 list-2 list-3 | sort | uniq > final.list
# Concatenates the list files,
# sorts them,
# removes duplicate lines,
# and finally writes the result to an output file.</programlisting>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>expand</command></term>
	  <indexterm>
	    <primary>expand</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>expand</secondary>
	  </indexterm>
	  <listitem>
	    <para>A filter than converts tabs to spaces, often seen in a pipe.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>cut</command></term>
	  <indexterm>
	    <primary>cut</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cut</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>awk</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>awk</secondary>
	  </indexterm>
	  <listitem>
	    <para>A tool for extracting fields from files. It is similar to the 
	      <userinput>print $N</userinput> command set in <command>awk</command>,
	      but more limited. It may be simpler to use <command>cut</command>
	      in a script than <command>awk</command>. Particularly important
	      are the <option>-d</option> (delimiter) and <option>-f</option>
	      (field specifier) options.</para>

	    <para>Using <command>cut</command> to obtain a listing of the
	      mounted filesystems: 
	      <programlisting>cat /etc/mtab | cut -d ' ' -f1,2</programlisting></para>

	    <para>Using <command>cut</command> to list the OS and kernel version:
	      <programlisting>uname -a | cut -d" " -f1,3,11,12</programlisting></para>

	    <para><userinput>cut -d ' ' -f2,3 filename</userinput> is equivalent to
	      <userinput>awk '{ print $2, $3 }' filename</userinput>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>colrm</command></term>
	  <indexterm>
	    <primary>colrm</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>colrm</secondary>
	  </indexterm>
	  <listitem>
	    <para>Column removal filter. This removes columns (characters)
	      from a file and writes them, lacking the range of
	      specified columns, back to stdout.  <userinput>colrm 2
	      4 &lt;filename</userinput> removes the second through
	      fourth characters from each line of the text file
	      <filename>filename</filename>.</para>
	    <warning><para>If the file contains tabs or nonprintable
	      characters, this may cause unpredictable
	      behavior.</para></warning>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>paste</command></term>
	  <indexterm>
	    <primary>paste</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>paste</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>cut</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cut</secondary>
	  </indexterm>
	  <listitem>
	    <para>Tool for merging together different files into a single, multi-column file.
	      In combination with <command>cut</command>, useful for creating system log files.
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>join</command></term>
	  <indexterm>
	    <primary>join</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>join</secondary>
	  </indexterm>
	  <listitem>
	    <para>Consider this a more flexible version of
	      <command>paste</command>. It works on exactly two files, but
	      permits specifying which fields to paste together, and in which
	      order.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>head</command></term>
	  <indexterm>
	    <primary>head</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>head</secondary>
	  </indexterm>
	  <listitem>
	    <para>lists the first <literal>10</literal> lines of a file
	      to stdout (see <xref linkend="ex52">).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>tail</command></term>
	  <indexterm>
	    <primary>tail</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tail</secondary>
	  </indexterm>
	  <listitem>
	    <para>lists the end of a file to stdout (the default is
	      <literal>10</literal> lines, but this can be changed).
	      Commonly used to keep track of changes to a system logfile,
	      using the <option>-f</option> option, which outputs lines
	      appended to the file.</para>
	      <para><xref linkend="ex41">, <xref linkend="ex52">, and
		<xref linkend="online"> show <emphasis>tail</emphasis>
		in action.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>grep</command></term>
	  <indexterm>
	    <primary>grep</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>grep</secondary>
	  </indexterm>
	  <listitem>
	    <para>A multi-purpose file search tool that uses regular expressions.
	      Originally a command/filter in the ancient <command>ed</command> line editor, <userinput>g/re/p</userinput>, or <emphasis>global - regular expression - print</emphasis>.</para>
  
	    <para><cmdsynopsis>
		<command>grep</command>
		<arg choice="plain"><replaceable>pattern</replaceable></arg>
		<arg choice="opt" rep="repeat"><replaceable>file</replaceable></arg>
	      </cmdsynopsis>
	      search the files <filename>file</filename>, etc. for
	      occurrences of <replaceable>pattern</replaceable>.</para>

	    <para><userinput>ls -l | grep '.txt'</userinput> has the same effect as <userinput>ls -l *.txt</userinput>.</para>

            <para>The <emphasis>-i</emphasis> option to
	      <command>grep</command> causes a case-insensitive
	      search.</para>

	    <para><xref linkend="online"> demonstrates how to use
	    <emphasis>grep</emphasis> to search for a keyword in a system
	    log file.</para>

	    <example id="grp">
	      <title>Emulating <quote>grep</quote> in a script</title>
	      <programlisting>&grp;</programlisting>
	    </example>	    	   

            <note><para><command>egrep</command> is the same as <command>grep
	      -E</command>. This uses a somewhat different, extended set
	      of regular expressions, which may make the search somewhat
	      more flexible.</para></note>

	    <note><para><command>fgrep</command> is the same as <command>grep
	      -F</command>. It does a literal string search (no regular
	      expressions), which generally speeds things up quite a
	      bit.</para></note>
	    
	    <note><para>To search compressed files, use
	      <command>zgrep</command>. It also works on non-compressed
	      files, though slower than plain <command>grep</command>.
	      This is handy for searching through a mixed set of files,
	      some of them compressed, some not.  </para></note>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command>look</command></term>
	  <indexterm>
	    <primary>look</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>look</secondary>
	  </indexterm>
	  <listitem>
	    <para>The command <command>look</command> works like
	      <command>grep</command>, but does a lookup on
	      a <quote>dictionary</quote>, a sorted word list.
	      By default, <command>look</command> searches for a match
	      in <filename>/usr/dict/words</filename>, but a different
	      dictionary file may be specified.</para>

	    <example id="lookup">
	      <title>Checking words in a list for validity</title>
	      <programlisting>&lookup;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command>sed</command></term>
	  <term><command>awk</command></term>
	  <indexterm>
	    <primary>sed</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sed</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>awk</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>awk</secondary>
	  </indexterm>
	  <listitem>
	    <para>Scripting languages especially suited for parsing text
	      files and command output. May be embedded singly or in
	      combination in pipes and shell scripts.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>sed</command></term>
	  <listitem>
	    <para>Non-interactive <quote>stream editor</quote>, permits using
	      many <command>ex</command> commands in batch mode. It finds many
	      uses in shell scripts. See <xref linkend="sedawk">.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>awk</command></term>
	  <listitem>
	    <para>Programmable file extractor and formatter, good for
	      manipulating and/or extracting fields (columns) in
	      structured text files. Its syntax is similar to C.
	      See <xref linkend="awk">.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>groff</command></term>
	  <term><command>gs</command></term>
	  <term><command>TeX</command></term>
	  <indexterm>
	    <primary>groff</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>groff</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>gs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>gs</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>TeX</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>TeX</secondary>
	  </indexterm>
	  <listitem>

	    <para>Text markup languages. Used for preparing copy for
	      printing or formatted video display.</para>
	      
	      <para><emphasis>Man pages</emphasis> use
	        <command>groff</command> (see <xref linkend="manview">).
		<emphasis>Ghostscript</emphasis> (<command>gs</command>) is
		the GPL version of Postscript. <command>TeX</command> is
		Donald Knuth's elaborate typsetting system. It is often
		convenient to write a shell script encapsulating all the
		options and arguments passed to one of these markup
		languages.</para>
		
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>wc</command></term>
	  <indexterm>
	    <primary>wc</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>wc</secondary>
	  </indexterm>
	  <listitem>
	    <para><emphasis>wc</emphasis> gives a <quote>word count</quote> on a file or I/O stream:
	      <screen><prompt>$ </prompt><userinput>wc /usr/doc/sed-3.02/README</userinput>
<computeroutput>20     127     838 /usr/doc/sed-3.02/README</computeroutput>
[20 lines  127 words  838 characters]</screen></para>

	    <para><userinput>wc -w</userinput> gives only the word count.</para>
	    <para><userinput>wc -l</userinput> gives only the line count.</para>
	    <para><userinput>wc -c</userinput> gives only the character count.</para>
	    <para><userinput>wc -L</userinput> gives only the length of the longest line.</para>

            <para>Using <emphasis>wc</emphasis> to count how many
	    <emphasis>.txt</emphasis> files are in current working directory:
	      <programlisting>$ ls *.txt | wc -l</programlisting>
	    </para>

	    <para>See <xref linkend="ex52"> and <xref
	    linkend="redir4">.</para>

	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term><command>tr</command></term>
	  <indexterm>
	    <primary>tr</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tr</secondary>
	  </indexterm>
	  <listitem>
	    <para>character translation filter.</para>
	    
	    <caution><para>must use quoting and/or brackets, as
	    appropriate.</para></caution>
	    
	    <para><userinput>tr "A-Z" "*" &lt;filename</userinput>
	      changes all the uppercase letters in
	      <filename>filename</filename> to asterisks (writes to stdout).</para>

	    <para><userinput>tr -d [0-9] &lt;filename</userinput> deletes all digits
	      from the file <filename>filename</filename>.</para>

	    <example id="ex49">
	      <title><command>toupper</command>: Transforms a file to all uppercase.</title>
	      <programlisting>&ex49;</programlisting>
	    </example>	    


	    <example id="lowercase">
	      <title><command>lowercase</command>: Changes all filenames in working directory to lowercase.</title>
	      <programlisting>&lowercase;</programlisting>
	    </example>	    

	    <example id="rot13">
	      <title><command>rot13</command>: rot13, ultra-weak encryption.</title>
	      <programlisting>&rot13;</programlisting>
	    </example>	    
	    
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>fold</command></term>
	  <indexterm>
	    <primary>fold</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>fold</secondary>
	  </indexterm>
	  <listitem>
	    <para>A filter that wraps inputted lines to a specified width
	      (see <xref linkend="ex50">).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>fmt</command></term>
	  <indexterm>
	    <primary>fmt</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>fmt</secondary>
	  </indexterm>
	  <listitem>
	    <para>Simple-minded file formatter, used as a filter in a
	      pipe to <quote>wrap</quote> long lines of text output (see
	      <xref linkend="ex41"> and <xref linkend="ex50">).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>ptx</command></term>
	  <indexterm>
	    <primary>ptx</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>index</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>ptx [targetfile]</command> command
	      outputs a permuted index (cross-reference list) of the
	      targetfile. This may be further filtered and formatted in a
	      pipe, if necessary.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>column</command></term>
	  <indexterm>
	    <primary>column</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>column</secondary>
	  </indexterm>
	  <listitem>
	    <para>Column formatter. This filter transforms list-type
	      text output into a <quote>pretty-printed</quote> table
	      by inserting tabs at appropriate places.</para>

	    <example id="col">
	      <title>Using <command>column</command> to format a directory
	        listing</title>
	      <programlisting>&col;</programlisting>
	    </example>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>nl</command></term>
	  <indexterm>
	    <primary>nl</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>fmt</secondary>
	  </indexterm>
	  <listitem>
	    <para>Line numbering filter. <userinput>nl filename</userinput>
	    lists <filename>filename</filename> to stdout,
	    but inserts consecutive numbers at the beginning of each
	    non-blank line. If <filename>filename</filename> omitted,
	    operates on stdin.</para>

	    <example id="lnum">
	      <title><command>nl</command>: A self-numbering script.</title>
	      <programlisting>&lnum;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command>pr</command></term>
	  <indexterm>
	    <primary>pr</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>pr</secondary>
	  </indexterm>
	  <listitem>
	    <para>Print formatting filter. This will paginate a file (or stdout) into
	      sections suitable for hard copy printing. A particularly useful option
	      is <option>-d</option>, forcing double-spacing.</para>

	    <example id="ex50">
	      <title>Formatted file listing.</title>
	      <programlisting>&ex50;</programlisting>
	    </example>	    
	    
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>printf</command></term>
	  <indexterm>
	    <primary>printf</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>printf</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>printf</command>, formatted print, command is an
	      enhanced <command>echo</command>.  It is a limited variant of the
	      C language <function>printf</function>, and the syntax is somewhat 
	      different.</para>
	    <cmdsynopsis>
	      <command>printf</command>
	      <arg choice=plain rep=repeat><replaceable>format-string</replaceable></arg>
	      <arg choice=plain rep=repeat><replaceable>parameter</replaceable></arg>
	    </cmdsynopsis>

	    <para>See the <command>printf</command> man page for in-depth coverage.</para>
	    
	    <caution><para>Older versions of <command>bash</command> may not
		support <command>printf</command>.</para></caution> 

	    <example id="ex47">
	      <title><command>printf</command> in action</title>
	      <programlisting>&ex47;</programlisting>
	    </example>
	    
	  </listitem>
	</varlistentry>
	
       </variablelist>

        </sect2> <!-- End Text Processing Commands -->


      <sect2 id="filearchiv">
        <title>File and Archiving Commands</title>

       <variablelist>

	<varlistentry>
	  <term><command>tar</command></term>
	  <indexterm>
	    <primary>tar</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tar</secondary>
	  </indexterm>
	  <listitem>
	    <para>The standard UNIX archiving utility. Originally a <wordasword>Tape ARchiving</wordasword>
	      program, from whence it derived its name, it has developed
	      into a general purpose package that can handle all manner
	      of archiving with all types of destination devices, ranging
	      from tape drives to regular files to even stdout (see <xref
	      linkend="ex58">). GNU tar has long since been patched to
	      accept <command>gzip</command> compression options, such
	      as <command>tar czvf archive-name.tar.gz *</command>,
	      which recursively archives and compresses all files
	      (except <quote>dotfiles</quote>) in a directory tree.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>cpio</command></term>
	  <indexterm>
	    <primary>cpio</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cpio</secondary>
	  </indexterm>
	  <listitem>
	    <para>This specialized archiving copy command is rarely used any more,
	      having been supplanted by
	      <command>tar</command>/<command>gzip</command>. It still has its
	      uses, such as moving a directory tree.</para>

	    <example id="ex48">
	      <title>Using <command>cpio</command> to move a directory tree</title>
	      <programlisting>&ex48;</programlisting>
	    </example>	    
	    
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command>gzip</command></term>
	  <indexterm>
	    <primary>gzip</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>gzip</secondary>
	  </indexterm>
	  <listitem>

	    <para>The standard GNU/UNIX compression utility, replacing
	      the inferior and proprietary
	      <command>compress</command>. The corresponding decompression
	      command is <command>gunzip</command>, which is the equivalent of
	      <command>gzip -d</command>.</para>

	    <para>The filter <command>zcat</command> decompresses a
	      <emphasis>gzipped</emphasis> file to stdout, as
	      possible input to a pipe or redirection. This is, in
	      effect, a <command>cat</command> command that works on
	      compressed files (including files processed with the older
	      <command>compress</command> utility). See <xref
	      linkend="ex14">.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>bzip2</command></term>
	  <indexterm>
	    <primary>bzip2</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>bzip2</secondary>
	  </indexterm>
	  <listitem>
	    <para>An alternate compression utility, usually more efficient
	      than <command>gzip</command>, especially on large files. The
	      corresponding decompression command is
	      <command>bunzip2</command>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>sq</command></term>
	  <indexterm>
	    <primary>sq</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sq</secondary>
	  </indexterm>
	  <listitem>

	    <para>Yet another compression utility, a filter that works
	      only on sorted ASCII word lists. It uses the standard
	      invocation syntax for a filter, <command>sq < input-file
	      > output-file</command>.	Fast, but not nearly as
	      efficient as <command>gzip</command>.  The corresponding
	      uncompression filter is <command>unsq</command>, invoked
	      like <command>sq</command>.</para>

	      <note><para>The output of <command>sq</command> may be
	        piped to <command>gzip</command> for further
		compression.</para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>shar</command></term>
	  <indexterm>
	    <primary>shar</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>shar</secondary>
	  </indexterm>
	  <listitem>
	    <para>Shell archiving utility. The files in a shell archive are concatenated
	      without compression, and the resultant archive is essentially a
	      shell script, complete with <token>#!/bin/sh</token> header, and containing all
	      the necessary unarchiving commands.  Shar archives still show up in
	      Internet newsgroups, but otherwise <command>shar</command> has
	      been pretty well replaced by
	      <command>tar</command>/<command>gzip</command>. The <command>unshar</command>
	      command unpacks <command>shar</command> archives.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>split</command></term>
	  <indexterm>
	    <primary>split</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>split</secondary>
	  </indexterm>
	  <listitem>
	    <para>Utility for splitting a file into smaller chunks. Usually used 
	      for splitting up large files in order to back them up on floppies or
	      preparatory to e-mailing or uploading them.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>file</command></term>
	  <indexterm>
	    <primary>file</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>file</secondary>
	  </indexterm>
	  <listitem>
	    <para>A utility for identifying file types. The command <userinput>file file-name</userinput>
	      will return a file specification for
	      <filename>file-name</filename>, such as
	      <computeroutput>ascii text</computeroutput> 
		or <computeroutput>data</computeroutput>. It references the
		magic numbers found in <filename>/usr/share/magic</filename>, 
		<filename>/etc/magic</filename>, or
	      <filename>/usr/lib/magic</filename>, depending on the Linux/UNIX
		distribution.</para>

	    <example id="stripc">
	      <title>stripping comments from C program files</title>
	      <programlisting>&stripc;</programlisting>
	    </example>	    	   
		
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command>uuencode</command></term>
	  <indexterm>
	    <primary>uuencode</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uuencode</secondary>
	  </indexterm>
	  <listitem>
	    <para>This utility encodes binary files into ASCII characters, making them
	      suitable for transmission in the body of an e-mail message or in a
	      newsgroup posting.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>uudecode</command></term>
	  <indexterm>
	    <primary>uudecode</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uudecode</secondary>
	  </indexterm>
	  <listitem>
	    <para>This reverses the encoding, decoding uuencoded files back into the
	      original binaries.</para>

	    <example id="ex52">
	      <title>uudecoding encoded files</title>
	      <programlisting>&ex52;</programlisting>
	    </example>	    	   
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>sum</command></term>
	  <term><command>cksum</command></term>
	  <term><command>md5sum</command></term>
	  <indexterm>
	    <primary>sum</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sum</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>cksum</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cksum</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>md5sum</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>md5sum</secondary>
	  </indexterm>
	  <listitem>
	    <para>These are utilities for generating checksums. A
	      <emphasis>checksum</emphasis> is a number mathematically
	      calculated from the contents of a file, for the purpose of
	      checking its integrity. A script might refer to a list of
	      checksums for security purposes, such as ensuring that
	      the contents of key system files have not been altered
	      or corrupted.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>strings</command></term>
	  <indexterm>
	    <primary>strings</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>strings</secondary>
	  </indexterm>
	  <listitem>
	    <para>Use the <command>strings</command> command to find
	      printable strings in a binary or data file. It will list
	      sequences of printable characters found in the target
	      file. This might be handy for a quick 'n dirty examination
	      of a core dump or for looking at an unknown graphic image
	      file (<userinput>strings image-file | more</userinput>
	      might show something like
	      <computeroutput>JFIF</computeroutput>, which would
	      identify the file as a <emphasis>jpeg</emphasis>
	      graphic). In a script, you would probably parse the output
	      of <command>strings</command> with <command>grep</command>
	      or <command>sed</command>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>more</command></term>
	  <term><command>less</command></term>
	  <indexterm>
	    <primary>more</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>more</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>less</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>less</secondary>
	  </indexterm>
	  <listitem>
	    <para>Pagers that display a text file or stream to
	      <filename>stdout</filename>, one screenful at a time.
	      These may be used to filter the output of a script.</para>
	  </listitem>
	</varlistentry>
       
       </variablelist>	

	</sect2> <!-- End File and Archiving Commands -->



      <sect2 id="communications">
        <title>Communications Commands</title>

       <variablelist>	

	<varlistentry>
	  <term><command>host</command></term>
	  <indexterm>
	    <primary>host</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>host</secondary>
	  </indexterm>
	  <listitem>
	    <para>Searches for information about an Internet host by name or
	      IP address, using DNS.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>vrfy</command></term>
	  <indexterm>
	    <primary>vrfy</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>vrfy</secondary>
	  </indexterm>
	  <listitem>
	    <para>Verify an Internet e-mail address.</para>
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command>nslookup</command></term>
	  <indexterm>
	    <primary>nslookup</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>name server lookup</secondary>
	  </indexterm>
	  <listitem>
	    <para>Do an Internet <quote>name server lookup</quote> on a host
	      by IP address. This may be run either interactively or
	      noninteractively, i.e., from within a script.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>dig</command></term>
	  <indexterm>
	    <primary>dig</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>domain information groper</secondary>
	  </indexterm>
	  <listitem>
	    <para>Similar to <command>nslookup</command>, do an Internet
	      <quote>name server lookup</quote> on a host.  May be run
	      either interactively or noninteractively, i.e., from within
	      a script.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>traceroute</command></term>
	  <indexterm>
	    <primary>traceroute</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>traceroute</secondary>
	  </indexterm>
	  <listitem>
	    <para>Trace the route taken by packets sent to a remote host. This
	      command works within a LAN, WAN, or over the Internet. The
	      remote host may be specified by an IP address. The output of
	      this command may be filtered by <command>grep</command> or
	      <command>sed</command> in a pipe.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>rcp</command></term>
	  <indexterm>
	    <primary>rcp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rcp</secondary>
	  </indexterm>
	  <listitem>
	    <para><quote>Remote copy</quote>, copies files between two different networked machines.
	      Using <command>rcp</command> and similar utilities with security
	      implications in a shell script may not be advisable. Consider
	      instead, using an <command>expect</command> script.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>sx</command></term>
	  <term><command>rx</command></term>
	  <indexterm>
	    <primary>sx</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sx</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>rx</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rx</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>sx</command> and <command>rx</command>
	      command set serves to transfer files to and from a remote
	      host using the <emphasis>xmodem</emphasis> protocol. These
	      are generally part of a communications package, such as
	      <command>minicom</command>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>sz</command></term>
	  <term><command>rz</command></term>
	  <indexterm>
	    <primary>sz</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sz</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>rz</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rz</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>sz</command> and <command>rz</command>
	      command set serves to transfer files to and from a remote
	      host using the <emphasis>zmodem</emphasis> protocol.
	      <emphasis>Zmodem</emphasis> has certain advantages over
	      <emphasis>xmodem</emphasis>, such as greater transmission
	      rate and resumption of interrupted file transfers.
	      Like <command>sx</command> and <command>rx</command>,
	      these are generally part of a communications package.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>uucp</command></term>
	  <indexterm>
	    <primary>uucp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uucp</secondary>
	  </indexterm>
	  <listitem>

	    <para><emphasis>UNIX to UNIX copy</emphasis>. This is a
	      communications package for transferring files between UNIX
	      servers. A shell script is an effective way to handle a
	      <command>uucp</command> command sequence.</para>

	    <para>Since the advent of the Internet and e-mail,
	      <command>uucp</command> seems to have faded into obscurity,
	      but it still exists and remains perfectly workable in
	      situations where an Internet connection is not available
	      or appropriate.</para>

	  </listitem>
	</varlistentry>


       </variablelist>	

	</sect2> <!-- End Communications Commands -->

	

      <sect2 id="extmisc">
        <title>Miscellaneous Commands</title>

       <variablelist>	

	<varlistentry>
	  <term><command>jot</command></term>
	  <term><command>seq</command></term>
	  <indexterm>
	    <primary>jot</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>jot</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>seq</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>seq</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>loop</primary>
	    <secondary>arguments</secondary>
	  </indexterm>
	  <listitem>
	    <para>These utilities emit a sequence of integers, with a user selected
	      increment. This can be used to advantage in a <command>for</command> loop.</para>

	    <example id="ex53">
	      <title>Using <command>seq</command> to generate loop arguments</title>
	      <programlisting>&ex53;</programlisting>
	    </example>	    	   
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>which</command></term>
	  <indexterm>
	    <primary>which</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>which</secondary>
	  </indexterm>
	  <listitem>
	    <para><command>which</command> &lt;command-xxx&gt; gives the full path
	      to <quote>command-xxx</quote>. This is useful for finding
	      out whether a particular command or utility is installed
	      on the system.</para>
	    <para><userinput>$bash which pgp</userinput>
<screen><computeroutput>/usr/bin/pgp</computeroutput></screen>
	  </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>script</command></term>
	  <indexterm>
	    <primary>script</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>script</secondary>
	  </indexterm>
	  <listitem>
	    <para>This utility records (saves to a file) all the user keystrokes at
	      the command line in a console or an xterm window. This, in effect,
	      create a record of a session.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>lp</command></term>
	  <indexterm>
	    <primary>lp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>lpr</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>lp</command> and <command>lpr</command>
	      commands send file(s) to the print queue, to be printed as
	      hard copy.

	      <footnote><para>The <emphasis>print queue</emphasis> is
	      the group of jobs <quote>waiting in line</quote> to be
	      printed.</para></footnote>

	      These commands trace the origin of their names to the
	      line printers of another era.</para>

	      <para><prompt>bash$ </prompt><userinput>cat file1.txt | lp</userinput>
	        </para>

	      <para>It is often useful to pipe the formatted output from
	        <command>pr</command> to <command>lp</command>.</para>

	      <para><prompt>bash$ </prompt><userinput>pr -options file1.txt | lp</userinput>
	        </para>

	      <para>Formatting packages, such as <command>groff</command> and
	        <emphasis>Ghostscript</emphasis> may send their output
		directly to <command>lp</command>.</para>

	      <para><prompt>bash$ </prompt><userinput>groff -Tascii file.tr | lp</userinput>
	        </para>

	      <para><prompt>bash$ </prompt><userinput>gs -options | lp file.ps</userinput>
	        </para>

	      <para>Related commands are <command>lpq</command>, for viewing
	        the print queue, and <command>lprm</command>, for removing
		jobs from the print queue.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>tee</command></term>
	  <indexterm>
	    <primary>tee</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tee</secondary>
	  </indexterm>
	  <listitem>
	    <para>[UNIX borrows an idea here from the plumbing trade.]</para>
	    <para>This is a redirection operator, but with a difference. Like the
	      plumber's <emphasis>tee</emphasis>, it permits <quote>siponing
		off</quote> the output of a command 
	      or commands within a pipe, but without affecting the result. This is
	      useful for printing an ongoing process to a file or paper, perhaps to
	      keep track of it for debugging purposes.</para>
	    
	    <screen>
                   tee
                 |------> to file
                 |
  ===============|===============
  command--->----|-operator-->---> result of command(s)
  ===============================
	      </screen>


	    <para><programlisting>cat listfile* | sort | tee check.file | uniq > result.file</programlisting>
	      (The file <filename>check.file</filename> contains the
	      concatenated sorted <quote>listfiles</quote>, 
	      before the duplicate lines are removed by <command>uniq</command>.)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>clear</command></term>
	  <indexterm>
	    <primary>clear</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>clear</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>clear</command> command simply clears
	      the text screen at the console or in an xterm. The
	      prompt and cursor reappear at the upper lefthand corner
	      of the screen or xterm window. This command may be used
	      either at the command line or in a script. See <xref
	      linkend="ex30">.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>yes</command></term>
	  <indexterm>
	    <primary>yes</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>yes</secondary>
	  </indexterm>
	  <listitem>
	    <para>In its default behavior the <command>yes</command> command feeds a continuous string
	      of the character <computeroutput>y</computeroutput> followed by a line feed to
	      stdout. A
	      <keycombo><keycap>control</keycap><keycap>c</keycap></keycombo> 
	      terminates the run. A different output string may be specified, as in
	      <userinput>yes different string</userinput>, which would continually
	      output 
	      <computeroutput>different	string</computeroutput> to stdout. 
	      One might well ask the purpose of this. From the command
	      line or in a script, the output of <command>yes</command> can be
	      redirected or piped into a
	      program expecting user input. In effect, this becomes a sort of poor man's
	      version of <command>expect</command>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>mkfifo</command></term>
	  <indexterm>
	    <primary>mkfifo</primary>
	  </indexterm>
	  <indexterm>
	    <primary>mkfifo</primary>
	    <secondary>mkfifo</secondary>
	  </indexterm>
	  <listitem>
	    <para>This obscure command creates a <emphasis>named
	    pipe</emphasis>, a temporary First-In-First-Out buffer for
	    transferring data between processes. Typically, one process
	    writes to the FIFO, and the other reads from it. See <xref
	    linkend="fifo">.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>pathchk</command></term>
	  <indexterm>
	    <primary>pathchk</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>pathchk</secondary>
	  </indexterm>
	  <listitem>
	    <para>This command checks the validity of a filename. If the
	      filename exceeds the maximum allowable length (255
	      characters) or one or more of the directories in
	      its path is not searchable, then an error message
	      results. Unfortunately, <command>pathchk</command> does
	      not return a recognizable error code, and it is therefore
	      pretty much useless in a script.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>dd</command></term>
	  <indexterm>
	    <primary>dd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>dd</secondary>
	  </indexterm>
	  <listitem>
	    <para>This is the somewhat obscure and much feared <quote>data duplicator</quote>
	      command. It simply copies a file (or stdin/stdout), but with
	      conversions. Possible conversions are ASCII/EBCDIC, upper/lower case,
	      swapping of byte pairs between input and output, and skipping and/or
	      truncating the head or tail of the input file. A <userinput>dd --help</userinput> lists
	      the conversion and other options that this powerful utility takes.</para>

	    <para>The <command>dd</command> command can copy raw data and disk
	      images to and from devices, such as floppies and tape
	      drives.  It can even be used to create boot floppies.
	      <programlisting>dd if=kernel-image of=/dev/fd0H1440</programlisting>
	      One important use for <command>dd</command> is initializing
	      temporary swap files (see <xref linkend="ex73">).</para>
	  </listitem>
	</varlistentry>

      </variablelist>

        </sect2> <!-- End Miscellaneous Commands -->

    </sect1> <!-- External Filters, Programs and Commands -->



    <sect1 id="system">
      <title>System and Administrative Commands</title>


      <para>The startup and shutdown scripts in 
	<filename class="directory">/etc/rc.d</filename> illustrate the uses
	(and usefulness) of these comands. These are usually invoked by root and used
	for system maintenance or emergency filesystem repairs. Use with caution,
	as some of these commands may damage your system if misused.</para>

      <variablelist>
	<varlistentry>
	  <term><command>uname</command></term>
	  <indexterm>
	    <primary>uname</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uname</secondary>
	  </indexterm>
	  <listitem>
	    <para>Output system specifications (OS, kernel version, etc.) to stdout.
	      Invoked with the <option>-a</option> option, gives
	      verbose system info (see <xref linkend="ex41">).</para>
	    <screen><prompt>bash$ </prompt><userinput>uname -a</userinput>
<computeroutput>Linux localhost.localdomain 2.2.15-2.5.0 #1 Sat Feb 5 00:13:43 EST 2000 i686 unknown</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>arch</command></term>
	  <indexterm>
	    <primary>arch</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>arch</secondary>
	  </indexterm>
	  <listitem>
	    <para>Show system architecture.
	      Equivalent to <command>uname -m</command>.</para>
	    <screen><prompt>bash$ </prompt><userinput>arch</userinput>
<computeroutput>i686</computeroutput></screen>
	    <screen><prompt>bash$ </prompt><userinput>uname -m</userinput>
<computeroutput>i686</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>id</command></term>
	  <indexterm>
	    <primary>id</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>id</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>id</command> command lists the real and
	      effective user IDs and the group IDs of the
	      current user.  This is the counterpart to the
	      <varname>$UID</varname>, <varname>$EUID</varname>, and
	      <varname>$GROUPS</varname> internal Bash variables (see
	      <xref linkend="variables2">).</para>
	    <screen><prompt>bash$ </prompt><userinput>id</userinput>
<computeroutput>uid=501(bozo) gid=501(bozo) groups=501(bozo),22(cdrom),80(cdwriter),81(audio)</computeroutput></screen>
	    <screen><prompt>bash$ </prompt><userinput>echo $UID</userinput>
<computeroutput>501</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>who</command></term>
	  <indexterm>
	    <primary>who</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>whoami</secondary>
	  </indexterm>
	  <listitem>
	    <para>Show all users logged on to the system.</para>
	    <para><command>whoami</command> is a variant of
	      <command>who</command> that lists only the current
	      user.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>w</command></term>
	  <indexterm>
	    <primary>w</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>w</secondary>
	  </indexterm>
	  <listitem>
	    <para>Show all logged on users and the processes belonging to them. This is
	      an extended version of <command>who</command>. The output of <command>w</command>
	      may be piped to <command>grep</command> to find a specific user and/or process.</para>
	    <screen><prompt>bash$ </prompt><userinput>w | grep startx</userinput>
<computeroutput>grendel  tty1     -                 4:22pm  6:41   4.47s  0.45s  startx</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>users</command></term>
	  <indexterm>
	    <primary>users</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>users</secondary>
	  </indexterm>
	  <listitem>
	    <para>Show all logged on users. This is the approximate
	      equivalent of <command>who -q</command>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>groups</command></term>
	  <indexterm>
	    <primary>groups</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>groups</secondary>
	  </indexterm>
	  <listitem>
	    <para>Lists the current user and the groups she belongs to.
	       This corresponds to the <varname>$GROUPS</varname> internal
	       variable, but gives the group names, rather than the
	       numbers.</para> 
	    <screen><prompt>bash$ </prompt><userinput>groups</userinput>
<computeroutput>bozita cdrom cdwriter audio xgrp</computeroutput></screen>
	    <screen><prompt>bash$ </prompt><userinput>echo $GROUPS</userinput>
<computeroutput>501</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>hostname</command></term>
	  <indexterm>
	    <primary>hostname</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>hostname</secondary>
	  </indexterm>
	  <listitem>
	    <para>Lists the system's host name, as recorded in
	      <filename>/etc/hosts</filename>.
	      This is a counterpart to the <varname>$HOSTNAME</varname> internal
	      variable.</para>
	    <screen><prompt>bash$ </prompt><userinput>hostname</userinput>
<computeroutput>localhost.localdomain</computeroutput></screen>
	    <screen><prompt>bash$ </prompt><userinput>echo $HOSTNAME</userinput>
<computeroutput>localhost.localdomain</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>ulimit</command></term>
	  <indexterm>
	    <primary>ulimit</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ulimit</secondary>
	  </indexterm>
	  <listitem>
	    <para>Sets an <emphasis>upper limit</emphasis> on system
	     resources. Usually invoked with the <option>-f</option>
	     option, which sets a limit on file size (<command>ulimit
	     -f 1000</command> limits files to 1 meg maximum). The
	     <option>-t</option> option limits the coredump size
	     (<command>ulimit -c 0</command> eliminates coredumps).
	      Normally, the value of <command>ulimit</command>
	      would be set in <filename>/etc/profile</filename>
	      and/or <filename>~/.bash_profile</filename> (see <xref
	      linkend="files">).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>uptime</command></term>
	  <indexterm>
	    <primary>uptime</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uptime</secondary>
	  </indexterm>
	  <listitem>
	    <para>Shows how long the system has been running, along with
	      associated statistics.</para>
	    <screen><prompt>bash$ </prompt><userinput>uptime</userinput>
<computeroutput>10:28pm  up  1:57,  3 users,  load average: 0.17, 0.34, 0.27</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>env</command></term>
	  <indexterm>
	    <primary>env</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>env</secondary>
	  </indexterm>
	  <listitem>
	    <para>Runs a program or script with certain environmental
	      variables set or changed (without changing the overall
	      system environment). The <option>[varname=xxx]</option>
	      permits changing the environmental variable
	      <varname>varname</varname> for the duration of the
	      script. With no options specified, this command lists all
	      the environmental variable settings.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>su</command></term>
	  <indexterm>
	    <primary>su</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>su</secondary>
	  </indexterm>
	  <listitem>
	    <para>Runs a program or script as a
	    <emphasis>s</emphasis>ubstitute <emphasis>u</emphasis>ser.
	    <command>su rjones</command> starts a shell as user
	    <emphasis>rjones</emphasis>. A naked <command>su</command>
	    defaults to <emphasis>root</emphasis>.  See <xref
	    linkend="fifo">.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>shopt</command></term>
	  <indexterm>
	    <primary>shopt</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>shopt</secondary>
	  </indexterm>
	  <listitem>
	    <para>This command permits changing shell options on the fly (see
	      <xref linkend="al">).  It often appears in the Bash setup files,
	      but also has its uses in scripts. Works with version 2 of
	      Bash only.

	      <programlisting>shopt -s cdspell
# Allows minor misspelling directory names with 'cd'
command.</programlisting></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>lockfile</command></term>
	  <indexterm>
	    <primary>lockfile</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>lockfile</secondary>
	  </indexterm>
	  <listitem>
	    <para>This utility is part of the <command>procmail</command>
	      package (<ulink url="http://www.procmail.org">www.procmail.org</ulink>).
	      It creates a <emphasis>lock file</emphasis>, a semaphore file that
	      controls access to a file, device, or resource. The lock file
	      serves as a flag that this particular file, device, or resource is
	      in use by a particular process (<quote>busy</quote>), and
	      permitting only restricted access (or no access) to other
	      processes. Lock files are used in such applications as protecting 
	      system mail folders from simultaneously being changed by multiple
	      users, indicating that a modem port is being accessed, and showing
	      that an instance of <application>Netscape</application> is using its
	      cache.  Scripts may check for the existence of a lock file created
	      by a certain process to check if that process is running.  Note
	      that if a script attempts create a lock file that already exists,
	      the script will likely hang.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>cron</command></term>
	  <indexterm>
	    <primary>cron</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cron</secondary>
	  </indexterm>
	  <listitem>
	    <para>Administrative program scheduler, performing such duties as cleaning up
	      and deleting system log files and updating the
	      <database>slocate</database> database. This is the superuser
	      version of <command>at</command>.  It runs as a daemon (background
	      process) and executes scheduled entries from <filename>/etc/crontab</filename>.
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>chroot</command></term>
	  <indexterm>
	    <primary>chroot</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>chroot</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>directory</primary>
	    <secondary>root</secondary>
	    <tertiary>change</tertiary>
	  </indexterm>
	  <listitem>
	    <para>CHange ROOT directory. Normally commands are fetched from <varname>$PATH</varname>,
	      relative to <filename class="directory">/</filename>, the default
	      root directory. This changes the root directory to a different one
	      (and also changes the working directory to there). A <userinput>chroot /opt</userinput>
	      would cause references to <filename class="directory">/usr/bin</filename> to be 
	      translated to <filename class="directory">/opt/usr/bin</filename>,
	      for example. This is useful for security purposes, for instance
	      when the system administrator wishes to restrict 
	      certain users, such as those telnetting in, to a secured portion of
	      the filesystem. Note that after a <command>chroot</command>, the execution path for
	      system binaries is no longer valid.</para>

	    <para>The <command>chroot</command> command is also handy when running from an emergency
	      boot floppy (<command>chroot</command> to
	      <filename>/dev/fd0</filename>), or as an option to <command>lilo</command> when 
	      recovering from a system crash. Other uses include installation from
	      a different filesystem (an <command>rpm</command> option).  Invoke only as root, and
	      use with caution.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <indexterm>
	    <primary>umask</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>umask</secondary>
	  </indexterm>
	  <term><command>umask</command></term>
	  <listitem>
	    <para>User file creation MASK. Limit the default file attributes
	      for a particular user.  All files created by that user take
	      on the attributes specified by <command>umask</command>. The
	      (octal) value passed to <command>umask</command> defines the
	      the file permissions <emphasis>disabled</emphasis>. For
	      example, <command>umask 022</command> ensures that
	      new files will have at most 755 permissions (777 NAND 022).

                <footnote><para>NAND is the logical <quote>not-and</quote>
		  operator. Its effect is somewhat similar to
		  subtraction.</para></footnote>
	      
	      Of course, the user may later change the attributes
	      of particular files with <command>chmod</command>.The usual
	      practice is to set the value of <command>umask</command>
	      in <filename>/etc/profile</filename> and/or
	      <filename>~/.bash_profile</filename> (see <xref
	      linkend="files">).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>ldd</command></term>
	  <indexterm>
	    <primary>ldd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ldd</secondary>
	  </indexterm>
	  <listitem>
	    <para>Show shared lib dependencies for an executable file.</para>
	    <screen><prompt>bash$ </prompt><userinput>ldd /bin/ls</userinput>
<computeroutput>libc.so.6 => /lib/libc.so.6 (0x4000c000)
/lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x80000000)</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>logname</command></term>
	  <indexterm>
	    <primary>logname</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>logname</secondary>
	  </indexterm>
	  <listitem>
	    <para>Show current user's login name (as found in
	      <filename>/var/run/utmp</filename>). This is
	      equivalent to <command>whoami</command>, above.</para>
	    <screen><prompt>bash$ </prompt><userinput>logname</userinput>
<computeroutput>bozo</computeroutput></screen>	    
	    <screen><prompt>bash$ </prompt><userinput>whoami</userinput>
<computeroutput>bozo</computeroutput></screen>	    
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>tty</command></term>
	  <indexterm>
	    <primary>tty</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tty</secondary>
	  </indexterm>
	  <listitem>
	    <para>Echoes the name of the current user's terminal.
	      Note that each separate xterm window counts as a different
	      terminal.</para>
	    <screen><prompt>bash$ </prompt><userinput>tty</userinput>
<computeroutput>/dev/pts/1</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>stty</command></term>
	  <indexterm>
	    <primary>stty</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>stty</secondary>
	  </indexterm>
	  <listitem>
	    <para>Shows and/or changes terminal settings.</para>
	    
            <example id="secretpw">
              <title><command>secret password</command>: Turning off
              terminal echoing </title>
              <programlisting>&secretpw;</programlisting>
            </example>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>wall</command></term>
	  <indexterm>
	    <primary>wall</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>wall</secondary>
	  </indexterm>
	  <listitem>
	    <para>This is an acronym for <quote>write all</quote>, i.e.,
	      sending a message to all users every terminal logged on in the
	      network. It is primarily a system administrator's tool, useful,
	      for example, when warning everyone that the system will shortly go
	      down due to a problem (see <xref linkend="ex70">).</para>
	    <screen><computeroutput>wall System going down for maintenance in 5 minutes!</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>logger</command></term>
	  <indexterm>
	    <primary>logger</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>logger</secondary>
	  </indexterm>
	  <listitem>
	    <para>Appends a user-generated message to the system log
	      (<filename>/var/log/messages</filename>). You do not have
	      to be root to invoke <command>logger</command>.
	      <programlisting>logger Experiencing instability in network connection at 23:10, 05/21.
# Now, do a 'tail /var/log/messages'.</programlisting></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>dmesg</command></term>
	  <indexterm>
	    <primary>dmesg</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>dmesg</secondary>
	  </indexterm>
	  <listitem>
	    <para>Lists all system bootup messages to stdout. Handy for
	      debugging and ascertaining which device drivers were installed
	      and which system interrupts in use. The output of
	      <command>dmesg</command> may, of course, be parsed with
	      <command>grep</command>, <command>sed</command>, or
	      <command>awk</command> from within a script.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>fuser</command></term>
	  <indexterm>
	    <primary>fuser</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>fuser</secondary>
	  </indexterm>
	  <listitem>
	    <para>Identifies the processes (by pid) that are accessing
	      a given file, set of files, or directory. May also be
	      invoked with the <option>-k</option> option, which kills
	      those processes. This has interesting implications for
	      system security, especially in scripts preventing
	      unauthorized users from accessing system services.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>pidof</command></term>
	  <indexterm>
	    <primary>pidof</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>process id</secondary>
	  </indexterm>
	  <listitem>
	    <para>Identifies <emphasis>process id (pid)</emphasis> of a
	    running job. Job control commands, such as
	    <command>kill</command> and <command>renice</command>
	    act on the <emphasis>pid</emphasis> of a process,
	    rather than its name. This is the counterpart of the
	    <varname>$PPID</varname> internal variable (see <xref
	    linkend="variables2">).</para>

            <example id="killprocess">
              <title><command>pidof</command> helps kill a process</title>
              <programlisting>&killprocess;</programlisting>
            </example>

	  </listitem>
	</varlistentry>



	<varlistentry>
	  <term><command>nice</command></term>
	  <indexterm>
	    <primary>nice</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>nice</secondary>
	  </indexterm>
	  <listitem>
	    <para>Show or change the priority of a background
	      job. Priorities run from 19 (lowest) to -20
	      (highest). Only <emphasis>root</emphasis> may set the
	      negative (higher) priorities. Related commands are
	      <command>renice</command>, <command>snice</command>,
	      and <command>skill</command>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>nohup</command></term>
	  <indexterm>
	    <primary>nohup</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>nohup</secondary>
	  </indexterm>
	  <listitem>
	    <para>Keeps a command running even after user logs off.
	      The command will run as a foreground process unless followed
	      by <token>&</token>.  If you use <command>nohup</command>
	      within a script, consider coupling it with a
	      <command>wait</command> to avoid creating an orphan or
	      zombie process.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>free</command></term>
	  <indexterm>
	    <primary>free</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>free</secondary>
	  </indexterm>
	  <listitem>
	    <para>Shows memory and cache usage in tabular form. The output of this command
	      lends itself to parsing, using <command>grep</command>, <command>awk</command> or <command>Perl</command>.
	    </para>

	    <screen><prompt>bash$ </prompt><command>free</command>
<computeroutput>                total       used       free     shared    buffers     cached
   Mem:         30504      28624       1880      15820       1608       16376
   -/+ buffers/cache:      10640      19864
   Swap:        68540       3128      65412</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>sync</command></term>
	  <indexterm>
	    <primary>sync</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sync</secondary>
	  </indexterm>
	  <listitem>
	    <para>Forces an immediate write of all updated data from
	      buffers to hard drive. While not strictly necessary,
	      a <command>sync</command> assures the sys admin or
	      user that the data just changed will survive a sudden
	      power failure. In the olden days, a <userinput>sync
	      sync</userinput> was a useful precautionary measure before
	      a system reboot.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>init</command></term>
	  <indexterm>
	    <primary>init</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>init</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>init</command> command is the parent of all processes. Called in the
	      final step of a bootup, <command>init</command> determines the runlevel of the system
	      from <filename>/etc/inittab</filename>. Invoked by its alias
	      <command>telinit</command>, and by root only.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>telinit</command></term>
	  <indexterm>
	    <primary>telinit</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>telinit</secondary>
	  </indexterm>
	  <listitem>
	    <para>Symlinked to <command>init</command>, this is a means of changing the system runlevel,
	      usually done for system maintenance or emergency filesystem
	      repairs. Invoked only by root. This command can be dangerous - be
	      certain you understand it well before using!</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>runlevel</command></term>
	  <indexterm>
	    <primary>runlevel</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>runlevel</secondary>
	  </indexterm>
	  <listitem>
	    <para>Shows the current and last runlevel, that is, whether the system
	      is halted (runlevel <literal>0</literal>), in single-user mode
	      (<literal>1</literal>), in multi-user mode (<literal>2</literal>
	      or <literal>3</literal>), in X Windows (<literal>5</literal>), or
	      rebooting (<literal>6</literal>).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>halt</command></term>
	  <term><command>shutdown</command></term>
	  <term><command>reboot</command></term>
	  <indexterm>
	    <primary>halt</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>halt</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>shutdown</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>shutdown</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>reboot</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>reboot</secondary>
	  </indexterm>
	  <listitem>
	    <para>Command set to shut the system down, usually just prior to a power down.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>exec</command></term>
	  <indexterm>
	    <primary>exec</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>exec</secondary>
	  </indexterm>
	  <listitem>
	    <para>This is actually a system call that replaces the
	      current process with a specified command. It is mostly seen
	      in combination with <command>find</command>, to execute a
	      command on the files found (see <xref linkend="ex57">). When
	      used as a standalone in a script, it forces an exit
	      from the script when the <command>exec</command>'ed
	      command terminates. An <command>exec</command> is also
	      used to reassign file descriptors.  <userinput>exec
	      &lt;zzz-file</userinput> replaces stdin with the file
	      <filename>zzz-file</filename> (see <xref
	      linkend="redir1">).</para>

	    <example id="ex54">
	      <title>Effects of <command>exec</command></title>
	      <programlisting>&ex54;</programlisting>
	    </example>	    	   

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>ifconfig</command></term>
	  <indexterm>
	    <primary>ifconfig</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ifconfig</secondary>
	  </indexterm>
	  <listitem>
	    <para>Network interface configuration utility.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>route</command></term>
	  <indexterm>
	    <primary>route</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>route</secondary>
	  </indexterm>
	  <listitem>
	    <para>Show info about or make changes to the kernel routing table.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>netstat</command></term>
	  <indexterm>
	    <primary>netstat</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>netstat</secondary>
	  </indexterm>
	  <listitem>
	    <para>Show current network information and statistics, such as routing tables and
	      active connections.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>mknod</command></term>
	  <indexterm>
	    <primary>mknod</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mknod</secondary>
	  </indexterm>
	  <listitem>
	    <para>Creates block or character device files (may be necessary when installing
	      new hardware on the system).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>mount</command></term>
	  <indexterm>
	    <primary>mount</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mount</secondary>
	  </indexterm>
	  <listitem>
	    <para>Mount a filesystem, usually on an external device, such as a floppy
	      or CDROM. The file <filename>/etc/fstab</filename> provides a
	      handy listing of available filesystems, including options, that
	      may be automatically or manually mounted. The file 
	      <filename>/etc/mtab</filename> shows the currently mounted filesystems
	      (including the virtual ones, such as <filename class="directory">/proc</filename>).

	      <programlisting>mount -t iso9660 /dev/cdrom /mnt/cdrom
# Mounts CDROM
mount /mnt/cdrom
# Shortcut, if /mnt/cdrom listed in /etc/fstab</programlisting></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>umount</command></term>
	  <indexterm>
	    <primary>umount</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>umount</secondary>
	  </indexterm>
	  <listitem>
	    <para>Unmount a currently mounted filesystem. Before physically removing a
	      previously mounted floppy or CDROM disk, the device must be
	      <command>umount</command>'ed, else filesystem corruption may result.
	      <programlisting>umount /mnt/cdrom</programlisting></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>lsmod</command></term>
	  <indexterm>
	    <primary>lsmod</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>lsmod</secondary>
	  </indexterm>
	  <listitem>
	    <para>List installed kernel modules.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>insmod</command></term>
	  <indexterm>
	    <primary>insmod</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>insmod</secondary>
	  </indexterm>
	  <listitem>
	    <para>Force insertion of a kernel module. Must be invoked as root.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>modprobe</command></term>
	  <indexterm>
	    <primary>modprobe</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>modprobe</secondary>
	  </indexterm>
	  <listitem>
	    <para>Module loader that is normally invoked automatically in a startup script.</para>
	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term><command>depmod</command></term>
	  <indexterm>
	    <primary>depmod</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>depmod</secondary>
	  </indexterm>
	  <listitem>
	    <para>Creates module dependency file, usually invoked from startup script.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>rdev</command></term>
	  <indexterm>
	    <primary>rdev</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rdev</secondary>
	  </indexterm>
	  <listitem>
	    <para>Get info about or make changes to root device, swap space, or video
	       mode.  The functionality of <command>rdev</command> has generally been taken over by
	       <command>lilo</command>, but <command>rdev</command> remains
	       useful for setting up a ram disk. This is another dangerous command, if misused.
	     </para>
	   </listitem>
	 </varlistentry>
	
      </variablelist>
      <para>Using our knowledge of administrative commands, let us examine a system
	script. One of the shortest and simplest to understand scripts is
	<command>killall</command>, used to suspend running processes at system shutdown.</para>

	    <example id="ex55">
	      <title><command>killall</command>, from <filename class="directory">/etc/rc.d/init.d</filename></title>
	      <programlisting>&ex55;</programlisting>
	    </example>
      
      <para>That wasn't so bad. Aside from a little fancy footwork with variable
	matching, there is no new material there.</para>

      <formalpara><title>Exercise</title>
	  <para>In <filename class="directory">/etc/rc.d/init.d</filename>,
	  analyze the <command>halt</command> script. It is a bit longer than 
	  <command>killall</command>, but similar in concept. Make a copy of this script somewhere in
	  your home directory and experiment with it (do <emphasis>not</emphasis> run it as root). Do
	  a simulated run with the <option>-vn</option> flags 
	  (<userinput>sh -vn scriptname</userinput>). Add extensive comments. Change
	  the <quote>action</quote> commands to <quote>echos</quote>.</para></formalpara>

      <para>Now, look at some of the more complex scripts in
	<filename class="directory">/etc/rc.d/init.d</filename>. See if
	you can understand parts of them. Follow the above procedure
	to analyze them. For some additional insight, you might also
	examine the file <filename>sysvinitfiles</filename> in <filename
	class="directory">/usr/doc/initscripts-X.XX</filename>, which
	is part of the <quote>initscripts</quote> documentation.</para>

    </sect1> <!-- System and Administrative Commands -->

    <sect1 id="backticks">
      <title>Backticks (`COMMAND`)</title>
      <indexterm>
	<primary>`</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>`</secondary>
      </indexterm>
      <variablelist>
	<varlistentry>
	  <term>Command substitution</term>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>substitution</secondary>
	  </indexterm>
	  <listitem>
	    <para>Commands within backticks generate command line text.</para>
	    <para>The output of commands within backticks can be used
	      as arguments to another command or to load a variable.
	      <programlisting>rm `cat filename`
# <quote>filename</quote> contains a list of files to delete.

textfile_listing=`ls *.txt`
# Variable contains names of all *.txt files in current working directory.
echo $textfile_listing
#
textfile_listing2=$(ls *.txt)
echo $textfile_listing
# Also works.</programlisting>
	      </para>
	      <note><para>Using backticks for command substitution has been
	      superseded by the <command>$(COMMAND)</command>
	      form.</para></note>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Arithmetic expansion (commonly used with
	  <emphasis>expr</emphasis>)</term>
	  <indexterm>
	    <primary>arithmetic</primary>
	    <secondary>expansion</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>arithmetic</primary>
	    <secondary>expansion</secondary>
	  </indexterm>
	  <listitem>
	    <para><programlisting>z=`expr $z + 3`</programlisting>
	      Note that this particular use of backticks
	      has been superseded by double parentheses
	      <userinput>$((...))</userinput> or the very convenient
	      <command>let</command> construction.
	      <programlisting>z=$(($z+3))
# $((EXPRESSION)) is arithmetic expansion.
# Not to be confused with command substitution.

let z=z+3
let "z += 3"  #If quotes, then spaces and special operators allowed.</programlisting>
	      All these are equivalent. You may use whichever one
	      <quote>rings your chimes</quote>.
	    </para>
	  </listitem>
	</varlistentry>
      </variablelist>

    </sect1> <!-- Backticks (`...`) -->



    <sect1 id="io-redirection">
      <title>I/O Redirection</title>

      <para>There are always three default <quote>files</quote>
	open, <emphasis>stdin</emphasis> (the keyboard),
	<emphasis>stdout</emphasis> (the screen), and
	<emphasis>stderr</emphasis> (error messages output to the
	screen).  These, and any other open files, can be redirected.
	Redirection simply means capturing the output of a file, command,
	program, script, or even code block within a script (see <xref
	linkend="ex8"> and <xref linkend="rpmcheck">) and sending it as
	input to another file, command, program, or script.</para>

      <para>Each open file gets assigned a file descriptor.	
               <footnote><para>A <emphasis>file descriptor</emphasis>
		 is simply a number that the operating system assigns
		 to an open file to keep track of it.  Consider it
		 a simplified version of a file pointer. It is
		 analogous to a <emphasis>file handle</emphasis> in
		 C.</para></footnote>
	The file descriptors for <emphasis>stdin</emphasis>,
	<emphasis>stdout</emphasis>, and <emphasis>stderr</emphasis> are
	0, 1, and 2, respectively.  For opening additional files, there
	remain descriptors 3 to 9. It is sometimes useful to assign one of
	these additional file descriptors to <emphasis>stdin</emphasis>,
	<emphasis>stdout</emphasis>, or <emphasis>stderr</emphasis>
	as a temporary duplicate link.
	       <footnote><para>Using <replaceable>file descriptor
	       5</replaceable> might cause problems.  When Bash forks a
	       child process, as with <command>exec</command>, the child
	       inherits fd 5 (see Chet Ramey's archived e-mail, <ulink
	       url="http://www.geocrawler.com/archives/3/342/1996/1/0/1939805/">
	       SUBJECT: RE:  File descriptor 5 is held open</ulink>).
	       Best leave this particular fd alone.</para></footnote>
	This simplifies restoration to normal after complex redirection
	and reshuffling (see <xref linkend="redir1">).</para>

      <programlisting>    >
      # Redirect stdout to a file.
      # Creates the file if not present, otherwise overwrites it.

      ls -lR > dir-tree.list
      # Creates a file containing a listing of the directory tree.

    >>
      # Redirect stdout to a file.
      # Creates the file if not present, otherwise appends to it.

    2> &1
      # Redirects stderr to stdout.
      # Has the effect of making visible error messages that might otherwise not be seen.

    i> &amp;j
      # Redirects file descriptor <emphasis>i</emphasis> to <emphasis>j</emphasis>
      # All output of file pointed to by <emphasis>i</emphasis> gets sent to file pointed to by <emphasis>j</emphasis>

    <
      # Accept input from a file.
      # Companion command to <quote>></quote>, and often used in combination with it.
      grep search-word &lt;filename

    |
      # Pipe.
      # General purpose process and command chaining tool.
      # Similar to <quote>></quote>, but more general in effect.
      # Useful for chaining commands, scripts, files, and programs together.
      cat *.txt | sort | uniq > result-file
      # Sorts the output of all the .txt files and deletes duplicate lines,
      # finally saves results to <quote>result-file</quote>.
</programlisting>

      <note><para>Multiple instances of input and output redirection
        and/or pipes can be combined in a single command
        line.</para></note>

       <para><programlisting>command &lt; input-file &gt; output-file

command1 | command2 | command3 > output-file</programlisting></para>

      <variablelist>
	<varlistentry>
	  <term><token>n<&-</token></term>
	  <listitem>
	    <para>close input file descriptor
	    <replaceable>n</replaceable></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token><&-</token></term>
	  <listitem>
	    <para>close stdin</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>n>&-</token></term>
	  <listitem>
	    <para>close output file descriptor <replaceable>n</replaceable></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>>&-</token></term>
	  <listitem>
	    <para>close stdout</para>
	  </listitem>
	</varlistentry>
      </variablelist>

        <para>The <command>exec &lt;filename</command> command redirects
          <emphasis>stdin</emphasis> to a file. From that point on, all
	  <emphasis>stdin</emphasis> comes from that file, rather than its
	  normal source (usually keyboard input). This provides a method of
	  reading a file line by line and possibly parsing each line of input
	  using <command>sed</command> and/or <command>awk</command>.</para>

      <example id="redir1">
	<title>Redirecting <emphasis>stdin</emphasis> using
	  <command>exec</command></title>
	<programlisting>&redir1;</programlisting>
      </example>

        <para>Blocks of code, such as <command>while</command>,
	  <command>until</command>, and <command>for</command>
	  loops, even <command>if/then</command> test blocks can also
	  incorporate redirection of <emphasis>stdin</emphasis>. The
	  <token>&lt;</token> operator at the the end of the code block
	  accomplishes this.</para>

      <example id="redir2">
	<title>Redirected <emphasis>while</emphasis> loop</title>
	<programlisting>&redir2;</programlisting>
      </example>

      <example id="redir3">
	<title>Redirected <emphasis>until</emphasis> loop</title>
	<programlisting>&redir3;</programlisting>
      </example>

      <example id="redir4">
	<title>Redirected <emphasis>for</emphasis> loop</title>
	<programlisting>&redir4;</programlisting>
      </example>

      <example id="redir5">
	<title>Redirected <emphasis>if/then</emphasis> test</title>
	<programlisting>&redir5;</programlisting>
      </example>

      <para>Clever use of I/O redirection permits parsing and stitching
	together snippets of files and command output. One possible
	application of this might be generating report and log
	files.</para>

      <note><para><emphasis>Here documents</emphasis> are a special case of
        I/O redirection. See <xref linkend="here-docs">.</para></note> 


    </sect1> <!-- I/O Redirection -->


    <sect1 id="Recess-Time">
      <title>Recess Time</title>

      <epigraph>
	<attribution>Courtesy 'NIX "fortune cookies", with some
	  alterations and many apologies</attribution>
	<para>This bizarre little intermission gives the reader a chance
	  to relax and maybe laugh a bit.</para>

	<para>Fellow Linux user, greetings!  You are reading something
	  which will bring you luck and good fortune.  Just e-mail a
	  copy of this document to 10 of your friends.	Before you make
	  the copies, send a 100-line Bash script to the first person
	  on the list given at the bottom of this letter. Then delete
	  their name and add yours to the bottom of the list.</para>

	<para>Don't break the chain!  Make the copies within 48 hours.
	  Wilfred P. of Brooklyn failed to send out his ten copies and
	  woke the next morning to find his job description changed
	  to "COBOL programmer."  Howard L. of Newport News sent
	  out his ten copies and within a month had enough hardware
	  to build a 100-node Beowulf cluster dedicated to playing
	  <emphasis>xbill</emphasis>.  Amelia V. of Chicago laughed at
	  this letter and broke the chain.  Shortly thereafter, a fire
	  broke out in her terminal and she now spends her days writing
	  documentation for MS Windows.</para>

	<para>Don't break the chain!  Send out your ten copies today!</para>
      </epigraph>
      
    </sect1> <!-- Recess Time -->



    <sect1 id="regexp">
      <title>Regular Expressions</title>
      <para>In order to fully utilize the power of shell scripting, you need to
	master regular expressions.</para>

      <sect2><title>A Brief Introduction to Regular Expressions</title>

	<para>An expression is a set of characters that has an
	  interpretation above and beyond its literal meaning.	A quote
	  symbol (<token>"</token>), for example, may denote speech
	  by a person, ditto, or a meta-meaning for the symbols that
	  follow. Regular expressions are sets of characters that UNIX
	  endows with special features.</para>

	<para>The main uses for regular expressions (REs) are text
	  searches and string manipulation. An RE
	  <firstterm>matches</firstterm> a single character or a set
	  of characters.</para>
	<itemizedlist>
	  <listitem>
	    <indexterm>
	      <primary>*</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>*</secondary>
	    </indexterm>

	    <para>The asterisk <token>*</token> matches any number of
	      characters, <emphasis>including zero</emphasis>.</para>

	  </listitem>
	  <listitem>
	    <indexterm>
	      <primary>.</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>.</secondary>
	    </indexterm>

	    <para>The dot <token>.</token> matches any one character,
	      except a newline.</para>

	  </listitem>
	  <listitem>
	    <indexterm>
	      <primary>?</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>?</secondary>
	    </indexterm>

	    <para>The question mark <token>?</token> matches zero or
	      one of the previous RE. It is generally used for matching
	      single characters.</para>

	  </listitem>
	  <listitem>
	    <indexterm>
	      <primary>+</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>+</secondary>
	    </indexterm>

	    <para>The plus <token>+</token> matches one or more of the
	    previous RE. It serves a role similar to the <token>*</token>, but
	    does <emphasis>not</emphasis> match zero occurrences.</para>

	  </listitem>
	  <listitem>
	    <indexterm>
	      <primary>^</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>^</secondary>
	    </indexterm>
	    <para>The caret <token>^</token> matches the beginning of
	      a line, but sometimes, depending on context, negates the
	      meaning of a set of characters in an RE.
	    </para>
	  </listitem>

	  <listitem>
	    <indexterm>
	      <primary>$</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>$</secondary>
	    </indexterm>
	    <para>The dollar sign <token>$</token> at the end of a an
	    RE matches the end of a line.</para>
	  </listitem>
	  <listitem>
	    <indexterm>
	      <primary>[...]</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>[...]</secondary>
	    </indexterm>

	    <para>Brackets <token>[...]</token> enclose a set of characters
	      to match in a single RE.</para>

	    <para><replaceable>[xyz]</replaceable> matches the characters
	    <replaceable>x</replaceable>, <replaceable>y</replaceable>, or
	    <replaceable>z</replaceable>.</para>  

	    <para><replaceable>[c-n]</replaceable> matches any of the
	    characters in the range <replaceable>c</replaceable> to
	    <replaceable>n</replaceable>.</para>

	    <para><replaceable>[^b-d]</replaceable> matches
	      all characters <emphasis>except</emphasis> those
	      in the range <replaceable>b</replaceable> to
	      <replaceable>d</replaceable>. This is an instance of
	      <token>^</token> negating or inverting the meaning
	      of the following RE (taking on a role similar to
	      <replaceable>!</replaceable> in a different context).</para>

	  </listitem>

	  <listitem>
	    <indexterm>
	      <primary>\</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>\</secondary>
	    </indexterm>

	    <para>The backslash <token>\</token> escapes a special character,
	      which means that character gets interpreted literally.</para>

	     <para>A <replaceable>\$</replaceable> reverts back to its
	       literal meaning of <quote>dollar sign</quote>, rather than
	       its RE meaning of end-of-line.</para>
	  </listitem>


	  <listitem>
	    <indexterm>
	      <primary>\{ \}</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>\{ \}</secondary>
	    </indexterm>

	    <para>Escaped <quote>curly brackets</quote> <token>\{ \}</token>
	      indicate the number of occurrences of a preceding RE to
	      match.</para>

	    <para>It is necessary to escape the curly brackets since they have
	      a different special character meaning otherwise.</para>

	    <para><replaceable>[0-9]\{5\}</replaceable> matches exactly five
	      digits (characters in the range of 0 to 9).</para>

	    <caution><para>Curly brackets are not available as an RE in
	    <emphasis>awk</emphasis>.</para></caution>

	  </listitem>

	</itemizedlist>


	<para>"Sed & Awk", by Dougherty and Robbins (see
	  <xref linkend="biblio">) gives a very complete and lucid
	  treatment of REs.</para>

      </sect2> <!-- A Brief Introduction to Regular Expressions -->

      <sect2>
	<title>Using REs in scripts</title>
	<para>Sed, awk, and Perl, used as filters in scripts, take REs as arguments
	  when "sifting" or transforming files or I/O streams. See <xref
	  linkend="behead"> and <xref linkend="tree"> for illustrations
	  of this.</para>
      </sect2>
    </sect1> <!-- Regular Expressions -->

    <sect1 id="subshells">
      <title>Subshells</title>

      <para>Running a shell script launches another instance of the
      command processor. Just as your commands are interpreted at the
      command line prompt, similarly does a script batch process a list
      of commands in a file. Each shell script running is, in effect,
      a subprocess of the parent shell, the one that gives you the prompt
      at the console or in an xterm window.</para>

      <para>A shell script can also launch subprocesses. These
      <emphasis>subshells</emphasis> let the script do
      parallel processing, in effect executing multiple subtasks
      simultaneously.</para>
      
      <itemizedlist>
	<listitem>
	  <para>( command1; command2; command3; ... )</para>
	  <para>A command list embedded between
	  <replaceable>parentheses</replaceable> runs as a
	  subshell.</para>
	</listitem>
      </itemizedlist>

      <note><para>Variables in a subshell are <emphasis>not</emphasis>
      visible outside the block of code in the subshell.  These are,
      in effect, local variables.</para></note>

      <example id="subshell">
	<title>Variable scope in a subshell</title>
	<programlisting>&subshell;</programlisting>
      </example>

      <example id="parallel-processes">
	<title>Running parallel processes in subshells</title>
	<programlisting>
	(cat list1 list2 list3 | sort | uniq > list123)
	(cat list4 list5 list6 | sort | uniq > list456)
	# Merges and sorts both sets of lists simultaneously.
	
	wait #Don't execute the next command until subshells finish.
	
	diff list123 list456
	</programlisting>
	</example>

	  <note><para>A command block between <replaceable>curly
	  braces</replaceable> does <emphasis>not</emphasis> launch
	  a subshell.</para>
	  <para>{ command1; command2; command3; ... }</para></note>


    </sect1> <!-- Subshells -->


    
    <sect1 id="restricted-sh">
      <title>Restricted Shells</title>

      <para>Running a script or portion of a script in
      <emphasis>restricted</emphasis> mode disables certain commands that
      would otherwise be available. This is a security measure intended
      to limit the privileges of the script user and to minimize possible
      damage from running the script.</para>

      <para>Disabled commands in restricted shells

      <itemizedlist>
        <listitem>
	  <para>Using <replaceable>cd</replaceable> to change the working
	  directory.</para>
	</listitem><listitem>
	  <para>Changing the values of the <replaceable>$PATH</replaceable>,
	  <replaceable>$SHELL</replaceable>, <replaceable>$BASH_ENV</replaceable>,
	  or <replaceable>$ENV</replaceable> environmental variables.</para>
	</listitem><listitem>
	  <para>Reading or changing the <replaceable>$SHELLOPTS</replaceable>,
	  shell environmental options.</para>
	</listitem><listitem>
	  <para>Output redirection.</para>
	</listitem><listitem>
	  <para>Invoking commands containing one or more
	  <token>/'s</token>.</para>
	</listitem><listitem>
	  <para>Invoking <emphasis>exec</emphasis> to substitute a different
	  process for the shell.</para>
	</listitem><listitem>
	  <para>Various other commands that would enable monkeying
	  with or attempting to subvert the script for an unintended
	  purpose.</para>
	</listitem><listitem>
	  <para>Getting out of restricted mode within the script.</para>
	</listitem>  
      </itemizedlist></para>	  

      <example id="restricted">
	<title>Running a script in restricted mode</title>
	<programlisting>&restricted;</programlisting>
      </example>

    </sect1> <!-- Restricted Shells -->




    <sect1 id="process-sub">
      <title>Process Substitution</title>

      <para><replaceable>Process substitution</replaceable> is the
      counterpart to <emphasis>command substitution</emphasis>. Command
      substitution sets a variable to the result of a command,
      as in <replaceable>dir_contents=`ls -al`</replaceable> or
      <replaceable>xref=$( grep word datafile)</replaceable>. Process
      substitution feeds the output of a process to another process
      (in other words, it sends the results of a command to another
      command).</para>

      <itemizedlist>
	<listitem>
	  <para><replaceable>(command)&gt;</replaceable></para>
	  <para><replaceable>&lt;(command)</replaceable></para>
	  <para>These initiate process substitution. This uses a
	   <emphasis>named pipe</emphasis> (temp file) to send the results
	   of the process within parentheses to another process.</para>
	</listitem>
      </itemizedlist>

      <note><para>There are <emphasis>no</emphasis> spaces between the
       parentheses and the <quote><</quote> or <quote>></quote>.
       Space there would simply cause redirection from a subshell,
       rather than process substitution.</para></note>

      <para><programlisting>
      cat <(ls -l)
      # Same as     ls -l | cat

      sort -k 9 <(ls -l /bin) <(ls -l /usr/bin) <(ls -l /usr/X11R6/bin)
      # Lists all the files in the 3 main 'bin' directories, and sorts by filename.
      # Note that three (count 'em) distinct commands are fed to 'sort'.
      </programlisting></para>

    </sect1> <!-- Process Substitution -->




    <sect1 id="functions">
      <title>Functions</title>
      <para>Like <quote>real</quote> programming languages,
	<command>bash</command> has functions, though in a 
	somewhat limited implementation.  A function is a subroutine,
	a code block that implements a set of operations, a <quote>black
	box</quote> that performs a specified task.  Whenever there is
	repetitive code, when a task repeats with only slight variations,
	then writing a function should be investigated.</para>

      <para><cmdsynopsis>
	  <command>function</command>
	  <arg choice="plain"><replaceable>function-name</replaceable></arg> 
	  <arg choice="plain">{</arg><sbr>
	  <arg rep="repeat" choice="plain"><replaceable>command</replaceable></arg><sbr>
	  <arg choice="plain">}</arg><sbr>
	</cmdsynopsis>
	or 
	<cmdsynopsis>
	  <arg choice="plain"><replaceable>function-name</replaceable></arg> 
	  <arg choice="plain">()</arg>
	  <arg choice="plain">{</arg><sbr>
	  <arg rep="repeat" choice="plain"><replaceable>command</replaceable></arg><sbr>
	  <arg choice="plain">}</arg><sbr>
	</cmdsynopsis>
      </para>

      <para>This second form will cheer the hearts of C programmers.</para>

      <para>The opening bracket in the function may optionally be placed on the
	second line, to more nearly resemble C function syntax.</para>

      <para><cmdsynopsis>
	  <arg choice="plain"><replaceable>function-name</replaceable></arg> 
	  <arg choice="plain">()</arg><sbr>
	  <arg choice="plain">{</arg><sbr>
	  <arg rep="repeat" choice="plain"><replaceable>command</replaceable></arg><sbr>
	  <arg choice="plain">}</arg><sbr>
	</cmdsynopsis>
      </para>

      <para>Functions are called, <firstterm>triggered</firstterm>, simply by
	invoking their names.</para>

      <para>Note that the function definition must precede the first
	call to it. There is no method of <quote>declaring</quote>
	the function, as, for example, in C.</para>

      <example id="ex59">
	<title>Simple function</title>
	<programlisting>&ex59;</programlisting>
      </example>

      <para>More complex functions may have arguments passed to them
	and return exit values to the script for further
	processing.</para>

      <programlisting>function-name $arg1 $arg2</programlisting>

      <para>The function refers to the passed arguments by position (as if they were
	positional parameters), that is, <varname>$1</varname>,
	<varname>$2</varname>, and so forth.</para>

      <example id="ex60">
	<title>Function Taking Parameters</title>
	<programlisting>&ex60;</programlisting>
      </example>

      <note><para>In contrast to certain other programming languages,
	shell scripts permit passing only value parameters to functions.
	Variable names (which are actually pointers), if passed as
	parameters to functions, will be treated as string literals
	and cannot be dereferenced. <emphasis>Functions interpret their
	arguments literally.</emphasis></para></note>

      <variablelist>
	<varlistentry>
	  <term>exit status</term>
	  <listitem>
	    <para>Functions return a value, called an <firstterm>exit
	      status</firstterm>. The exit status may be explicitly
	      specified by a <command>return</command> statement,
	      otherwise it is the exit status of the last command in
	      the function (<errorcode>0</errorcode> if successful,
	      and a non-zero error code if not). This exit status
	      may be used in the script by referencing it as
	      <varname><replaceable>$?</replaceable></varname>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>return</command></term>
	  <indexterm>
	    <primary>return</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>return</secondary>
	  </indexterm>
	  <listitem>
	    <para>Terminates a function. The <command>return</command> statement
	      optionally takes an integer argument, which is returned to
	      the calling script as the <quote>exit status</quote> of the
	      function, and this exit status is assigned to the variable
	      <varname><replaceable>$?</replaceable></varname>.</para>

	    <example id="ex61">
	      <title>Converting numbers to Roman numerals</title>
	      <programlisting>&ex61;</programlisting>
	    </example>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><replaceable>local variables</replaceable></term>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>local</secondary>
	  </indexterm>
	  <listitem>
	    <para>A variable declared as <firstterm>local</firstterm> is one
	      that is visible only within the block of code in which it
	      appears. In a shell script, this means the variable has
	      meaning only within its own function.</para>

	    <example id="ex62">
	      <title>Local variable visibility</title>
	      <programlisting>&ex62;</programlisting>
	    </example>

	    <para>Local variables permit recursion (a recursive function
	      is one that calls itself), but this practice usually
	      involves much computational overhead and is definitely
	      <emphasis>not</emphasis> recommended in a shell
	      script.</para>

	    <example id="ex63">
	      <title>Recursion, using a local variable</title>
	      <programlisting>&ex63;</programlisting>
	    </example>

	  </listitem>
	</varlistentry>

      </variablelist>

    </sect1> <!-- Functions -->


    <sect1 id="aliases">
      <title>Aliases</title>
      <indexterm>
        <primary>alias</primary>
      </indexterm>

      <para>A bash <emphasis>alias</emphasis> is essentially nothing more than
        a keyboard shortcut, an abbreviation, a means of avoiding typing a
	long command sequence. If, for example, we include <command>alias
	lm="ls -l | more"</command> in the <emphasis>~/.bashrc</emphasis> file
	(see <xref linkend="files">), then each <userinput>lm</userinput>
	typed at the command line will automatically be replaced by a
	<command>ls -l | more</command>. This can save a great deal of typing
	at the command line and avoid having to remember complex combinations
	of commands and options. Setting <command>alias rm="rm -i"</command>
	(interactive mode delete) may save a good deal of grief, since
	it can prevent inadvertently losing important files.</para>

      <para>In a script, aliases have very limited usefulness. It would be
	quite nice if aliases could assume some of the functionality of
	the C preprocessor, such as macro expansion, but unfortunately
	Bash does not expand arguments within the alias body. Moreover,
	a script fails to expand an alias itself within <quote>compound
	constructs</quote>, such as <emphasis>if/then</emphasis>
	statements, loops, and functions. Almost invariably, whatever
	we would like an alias to do could be accomplished much more
	effectively with a function.</para>

    <example id="al">
      <title>Aliases within a script</title>
      <programlisting>&al;</programlisting>
    </example>

    <note><para>The <command>unalias</command> command removes a previously
      set <emphasis>alias</emphasis>.</para></note>

    <example id="unal">
      <title><command>unalias</command>: Setting and unsetting an alias</title>
      <programlisting>&unal;</programlisting>
    </example>

	    <screen><prompt>bash$ </prompt><userinput>./unalias.sh</userinput>
<computeroutput>
total 6
drwxrwxr-x    2 bozo     bozo         3072 Feb  6 14:04 .
drwxr-xr-x   40 bozo     bozo         2048 Feb  6 14:04 ..
-rwxr-xr-x    1 bozo     bozo          199 Feb  6 14:04 unalias.sh

./unalias.sh: llm: command not found
</computeroutput></screen>


    </sect1> <!-- Aliases -->





    <sect1 id="list-cons">
      <title>List Constructs</title>
      <indexterm>
	<primary>&&</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>&&</secondary>
      </indexterm>
      <indexterm>
	<primary>AND</primary>
	<secondary>list</secondary>
      </indexterm>
      <indexterm>
	<primary>||</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>||</secondary>
      </indexterm>
      <indexterm>
	<primary>OR</primary>
	<secondary>list</secondary>
      </indexterm>

      <para>The <quote>and list</quote> and <quote>or list</quote>
	constructs provide a means of processing a number of commands
	consecutively. These can effectively replace complex 
	nested <command>if</command>/<command>then</command> or even
	<command>case</command> statements. Note that the exit status 
	of an <quote>and list</quote> or an <quote>or list</quote> is
	the exit status of the last command executed.</para>

      <variablelist>
	<varlistentry>
	  <term>and list</term>
	  <listitem>
	    <para><programlisting>command-1 && command-2 && command-3 && ... command-n</programlisting>
	        Each command executes in turn provided that the previous command
	      has given a return value of <errorcode>true</errorcode>. At the
	      first <errorcode>false</errorcode> return, 
	      the command chain terminates (the first command returning <errorcode>false</errorcode>
	      is the last one to execute).</para>

	    <example id="ex64">
	      <title>Using an <quote>and list</quote> to test for command-line arguments</title>
	      <programlisting>&ex64;</programlisting>
	    </example>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>or list</term>
	  <listitem>
	    <para><programlisting>command-1 || command-2 || command-3 || ... command-n</programlisting>
	      Each command executes in turn for as long as the previous command
	      returns <errorcode>false</errorcode>. At the first
	      <errorcode>true</errorcode> return, the command chain terminates 
	      (the first command returning <errorcode>true</errorcode> is the
	      last one to execute). This is obviously the inverse of the
	      <quote>and list</quote>.</para>

	    <example id="ex65">
	      <title>Using <quote>or lists</quote> in combination with an <quote>and list</quote></title>
	      <programlisting>&ex65;</programlisting>
	    </example>

	  </listitem>
	</varlistentry>
	</variablelist>

	<para>Clever combinations of <quote>and</quote> and <quote>or</quote>
	lists are possible, but the logic may easily become convoluted and
	require extensive debugging.</para>

    </sect1> <!-- List Constructs -->

    <sect1 id="arrays">
      <title>Arrays</title>
      <para>Newer versions of <command>bash</command> support one-dimensional
	arrays.  Arrays may be declared with the <userinput>variable[xx]</userinput>
	notation or explicitly by a <userinput>declare -a variable</userinput>
	statement. To dereference (find the contents of) an array variable, use
	<firstterm>curly bracket</firstterm> notation, that is, <userinput>${variable[xx]}</userinput>.</para>

      <example id="ex66">
	<title>Simple array usage</title>
	<programlisting>&ex66;</programlisting>
      </example>

      <para>Arrays variables have a syntax all their own, and even standard bash operators
	have special options adapted for array use.</para>

      <example id="ex67">
	<title>Some special properties of arrays</title>
	<programlisting>&ex67;</programlisting>
      </example>

      <para>As seen in the previous example, either
	<replaceable>${array_name[@]}</replaceable> or
	<replaceable>${array_name[*]}</replaceable> refers to
	<emphasis>all</emphasis> the elements of the array.  Similarly,
	to get a count of the number of elements in an array, use either
	<replaceable>${#array_name[@]}</replaceable> or
	<replaceable>${#array_name[*]}</replaceable>.</para>

      <para>--</para>

      <para>Arrays permit deploying old familiar algorithms as shell scripts.
        Whether this is necessarily a good idea is left to the reader to
	decide.</para>

      <example id="bubble">
	<title>An old friend:
             <emphasis>The Bubble Sort</emphasis></title>
	<programlisting>&bubble;</programlisting>
      </example>
      
      <para>--</para>

      <para>Arrays enable implementing a shell script version of the <emphasis>Sieve of
	Erastosthenes</emphasis>. Of course, a resource-intensive application of this
	nature should really be written in a compiled language, such as C. It
	runs excruciatingly slowly as a script.</para>

      <example id="ex68">
	<title>Complex array application:
             <emphasis>Sieve of Erastosthenes</emphasis></title>
	<programlisting>&ex68;</programlisting>
      </example>

    </sect1> <!-- Arrays -->

    <sect1 id="files">
      <title>Files</title>


      <itemizedlist>

	<listitem>
	  <para><filename>/etc/profile</filename></para>
	  <para>systemwide defaults, mostly setting the environment (all shells, not just Bash)</para>
	</listitem>
	<listitem>
	  <para><filename>/etc/bashrc</filename></para>
	  <para>systemwide functions and and aliases for Bash</para>
	</listitem>

	<listitem>
	  <para><filename><varname>$HOME</varname>/.bash_profile</filename></para>
	  <para>user-specific Bash environmental default settings,
	    found in each user's home directory (the local counterpart
	    to <filename>/etc/profile</filename>)</para>
	</listitem>
	<listitem>
	  <para><filename><varname>$HOME</varname>/.bashrc</filename></para>
	  <para>user-specific Bash init file, found in each user's home
	    directory (the local counterpart to
	    <filename>/etc/bashrc</filename>).	Only interactive
	    shells and user scripts read this file. See
	    <xref linkend="sample-bashrc"> for a sample
	    <filename>.bashrc</filename> file.</para>
	</listitem>
      </itemizedlist>

      <para>These are the <emphasis>startup files</emphasis> for Bash. They
	contain the aliases (see <xref linkend="aliases">) and
	environmental variables made available to Bash running as
	a user shell and to all Bash scripts invoked after system
	initialization.</para>

    </sect1> <!-- Files -->


    <sect1 id="here-docs">
      <title>Here Documents</title>
      <indexterm>
	<primary><<</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary><<</secondary>
      </indexterm>
      <para>A <firstterm>here document</firstterm> uses a special form
	of I/O redirection (see <xref linkend="io-redirection">)
	to feed a command script to an interactive program, such
	as <command>ftp</command>, <command>telnet</command>, or
	<command>ex</command>.	Typically, the script consists of
	a command list to the program, delineated by a limit string.
	The special symbol <token><<</token> precedes the limit string.
	This has the effect of redirecting the output of a file into
	the program, similar to <programlisting>interactive-program
	< command-file</programlisting> where
	<filename>command-file</filename> contains
	  <programlisting>command #1
command #2
...</programlisting></para>

      <para>The <quote>here document</quote> alternative looks like this:
	<programlisting>#!/bin/bash
interactive-program &lt;&lt;LimitString
command #1
command #2
...
LimitString</programlisting></para>

      <para>Choose a limit string sufficiently unusual that it will not occur anywhere
	in the command list and confuse matters.</para>

      <para>Note that <quote>here documents</quote> may sometimes be used to good effect with
	non-interactive utilities and commands.</para>

      <example id="ex69">
	<title><command>dummyfile</command>: Creates a 2-line dummy file</title>
	<programlisting>&ex69;</programlisting>
      </example>

      <para>The above script could just as effectively have been implemented with
	<command>ex</command>, rather than <command>vi</command>. Here documents
	containing a list of <command>ex</command> commands are common enough to
	form their own category, known as <firstterm>ex scripts</firstterm>.</para>

      <example id="ex70">
	<title><command>broadcast</command>: Sends message to everyone logged in</title>
	<programlisting>&ex70;</programlisting>
      </example>

      <example id="ex71">
	<title>Multi-line message using <command>cat</command></title>
	<programlisting>&ex71;</programlisting>
      </example>

      <example id="ex72">
	<title><command>upload</command>: Uploads a file pair to <quote>Sunsite</quote>
	  incoming directory</title>
	<programlisting>&ex72;</programlisting>
      </example>

      <note>
	<para>Some utilities will not work in a 
	  <quote>here document</quote>. The pagers, <command>more</command> and 
	  <command>less</command> are among these.</para>

	<para>For those tasks too complex for a <quote>here document</quote>,
	  consider using the <command>expect</command> scripting language, which
	  is specifically tailored for feeding input into non-interactive programs.</para>
      </note>
    </sect1> <!-- Here Documents -->

    <sect1 id="zeros">
      <title>Of Zeros and Nulls</title>

      <variablelist>
	<varlistentry>
	  <term>Uses of <filename>/dev/null</filename></term>
	  <listitem>
	    <para>Think of <filename>/dev/null</filename> as a <quote>black
		hole</quote>. It is the nearest equivalent to a
		write-only file. Everything written to it disappears
		forever. Attempts to read or output from it result in
		nothing. Nevertheless, <filename>/dev/null</filename>
		can be quite useful from both the command line and in
		scripts.</para>

	    <para>Suppressing stdout or stderr (from <xref linkend="ex74">):
	      <programlisting>rm $badname 2>/dev/null
#           So error messages [stderr] deep-sixed.</programlisting>
	      </para>

	    <para>Deleting contents of a file, but preserving the file itself, with
	      all attendant permissions (from <xref linkend="ex1"> and <xref linkend="ex2">):
	      <programlisting>cat /dev/null > /var/log/messages
cat /dev/null > /var/log/wtmp</programlisting>
	      </para>

	    <para>Automatically emptying the contents of a log file (especially good for
	      dealing with those nasty <quote>cookies</quote> sent by Web commercial sites):
	      <programlisting>rm -f ~/.netscape/cookies
ln -s /dev/null ~/.netscape/cookies
# All cookies now get sent to a black hole, rather than saved to disk.</programlisting>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Uses of <filename>/dev/zero</filename></term>
	  <listitem>
	    <para>Like <filename>/dev/null</filename>,
	      <filename>/dev/zero</filename> is a pseudo file, but it actually
	      contains nulls (numerical zeros, not the ASCII kind). Output written to it
	      disappears, and it is fairly difficult to actually read the nulls in
	      <filename>/dev/zero</filename>, though it can be done with <command>od</command> or
	      a hex editor. The chief use for <filename>/dev/zero</filename> is
	      in creating an initialized dummy file of specified length intended
	      as a temporary swap file.</para>

	    <example id="ex73">
	      <title>Setting up a swapfile using <filename>/dev/zero</filename></title>
	      <programlisting>&ex73;</programlisting>
	    </example>

	  </listitem>
	</varlistentry>

      </variablelist>
    </sect1> <!-- Zeros and Nulls -->

    <sect1 id="debugging">
      <title>Debugging</title>
      <para>The Bash shell contains no debugger, nor even any debugging-specific
	commands or constructs.  Syntax errors or outright typos in the script
	generate cryptic error messages that are often of no help in debugging
	a non-functional script.</para>

      <example id="ex74">
	<title>test23, a buggy script</title>
	<programlisting>&ex74;</programlisting>
      </example>

      <para>Output from script:
	<screen><computeroutput>./test23: [37: command not found</computeroutput></screen>
	</para>

      <para>What's wrong with the above script (hint: after the <command>if</command>)?</para>


      <para>What if the script executes, but does not work as expected? This is the
	all too familiar logic error.</para>

      <example id="ex75">
	<title>test24, another buggy script</title>
	<programlisting>&ex75;</programlisting>
      </example>

      <para>To find out what's wrong with <xref linkend="ex75">, uncomment the
	<userinput>echo "$badname"</userinput> line. Echo statements are useful for
	seeing whether what you expect is actually what you get.</para>

      <para>Summarizing the symptoms of a buggy script,
	<orderedlist>
	  <listitem>
	    <para>It bombs with an error message <errorname>syntax error</errorname>, or</para>
	  </listitem>
	  <listitem>
	    <para>It runs, but does not work as expected 
	      (<errorname>logic error</errorname>)</para> 
	  </listitem>
	  <listitem>
	    <para>It runs, works as expected, but has nasty side effects
	      (<errorname>logic bomb</errorname>).</para> 
	  </listitem>
	</orderedlist>
      </para>
	
      <para>Tools for debugging non-working scripts include
	<orderedlist>
	  <listitem>
	    <para>echo statements at critical points in the script to trace the variables,
	      and otherwise give a snapshot of what is going on.</para>
	  </listitem>
	  <listitem>
	    <para>using the <command>tee</command> filter to check processes or
	      data flows at critical points.</para>
	  </listitem>
	  <listitem>
	    <para>setting option flags <option>-n -v -x</option></para>

	<para><userinput>sh -n scriptname</userinput> checks for syntax errors
	      without actually running the script. This is the equivalent of
	      inserting <userinput>set -n</userinput> or 
	      <userinput>set -o noexec</userinput> into the script. Note that
	      certain types of syntax errors can slip past this check.</para>

	    <para><userinput>sh -v scriptname</userinput> echoes each command before
	      executing it. This is the equivalent of inserting <userinput>set -v</userinput> or 
	      <userinput>set -o verbose</userinput> in the script.</para>
	    
	    <para><userinput>sh -x scriptname</userinput> echoes the result each
	      command, but in an abbreviated manner. This is the equivalent of
	      inserting <userinput>set -x</userinput> or 
	      <userinput>set -o xtrace</userinput> in the script.</para>

	    <para>Inserting <userinput>set -u</userinput> or 
		<userinput>set -o nounset</userinput> in the script runs it, but
		gives an <errorname>unbound variable</errorname> error message
		at each attempt to use an undeclared variable.</para>
	  </listitem>
	  <listitem>
	    <para>trapping at exit</para>
	<para>The <command>exit</command> command in a script actually sends a
	      signal <errorcode>0</errorcode>, terminating 
	      the process, that is, the script itself. It is often useful to trap
	      the <command>exit</command>, forcing a <quote>printout</quote> of
	      variables, for example. The <command>trap</command> must be the
	      first command in the script.</para>
	  </listitem>
	</orderedlist>
      </para>
	<variablelist>
	  <varlistentry>
	    <term><command>trap</command></term>
	    <listitem>
	      <para>Specifies an action on receipt of a signal; also useful for debugging.
	      <note><para>A <emphasis>signal</emphasis> is simply
	      a message sent to a process, either by the kernel or
	      another process, telling it to take some specified
	      action (usually to terminate).  For example, hitting a
	      <keycombo><keycap>Control</keycap><keycap>C</keycap></keycombo>,
	      sends a user interrupt, an INT signal, to a running
	      program.</para></note>

		<programlisting>trap 2 #ignore interrupts (no action specified) 
trap 'echo "Control-C disabled."' 2</programlisting>
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>

      <example id="ex76">
	<title>Trapping at exit</title>
	<programlisting>&ex76;</programlisting>
      </example>
	
      <example id="online">
	<title>Cleaning up after Control-C</title>
	<programlisting>&online;</programlisting>
      </example>

      <note><para><userinput>trap '' SIGNAL</userinput> (two adjacent
	apostrophes) disables SIGNAL for the remainder of the
	script. <userinput>trap SIGNAL</userinput> restores
	the functioning of SIGNAL once more. This is useful to
	protect a critical portion of a script from an undesirable
	interrupt.</para></note>

	<para><programlisting>
	trap '' 2  # Signal 2 is Control-C, now disabled.
	command
	command
	command
	trap 2     # Reenables Control-C
	</programlisting></para>

    </sect1> <!-- Debugging -->

    <sect1 id="options">
      <title>Options</title>

      <para>Options are settings that change shell and/or script
        behavior.</para> 
	
      <para>The <command>set</command> command (see <xref
	linkend="internal">) enables options within a script. At the
	point in the script where you want the options to take effect,
	use <command>set -o option-name</command> or, in short form,
	<command>set -option-abbrev</command>. These two forms are
	equivalent.</para>

      <para><programlisting>
      #!/bin/bash

      set -o verbose
      # Echoes all commands before executing.
      </programlisting></para>

      <para><programlisting>
      #!/bin/bash

      set -v
      # Exact same effect as above.
      </programlisting></para>

      <note><para>To <emphasis>disable</emphasis> an option within a script,
	use <command>set +o option-name</command> or <command>set
	+option-abbrev</command>.</para></note>

      <para><programlisting>
      #!/bin/bash

      set -o verbose
      # Command echoing on.
      command
      ...
      command

      set +o verbose
      # Command echoing off.
      command
      # Not echoed.


      set -v
      # Command echoing on.
      command
      ...
      command

      set +v
      # Command echoing off.
      command

      exit 0
      </programlisting></para>


      <para>An alternate method of enabling options in a script is
	to specify them immediately following the
	<replaceable>#!</replaceable> script header.</para>

      <para><programlisting>
      #!/bin/bash -x
      #
      # Body of script follows.
      </programlisting></para>


      <para>It is also possible to enable script options from the command
	line. Some options that will not work with
	<command>set</command> are available this way. Among these
	are <replaceable>-i</replaceable>, force script to run
	interactive.</para>

      <para><userinput>bash -v script-name</userinput></para>
      
      <para><userinput>bash -o verbose script-name</userinput></para>


      <para>The following is a listing of some useful options. They may be
	specified in either abbreviated form or by complete name.</para>

      <table>
	<title>bash options</title>
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Abbreviation</entry>
	      <entry>Name</entry>
	      <entry>Effect</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><option>-C</option></entry>
	      <entry>noclobber</entry>
	      <entry>Prevent overwriting of files by redirection (may be
		overridden by <token>>|</token>)</entry> 
	    </row>
	    <row>
	      <entry><option>-D</option></entry>
	      <entry>(none)</entry>
	      <entry>List double-quoted strings prefixed by <token>$</token>,
	      but do not execute commands in script</entry>
	    </row>
	    <row>
	      <entry><option>-a</option></entry>
	      <entry>allexport</entry>
	      <entry>Export all defined variables</entry>
	    </row>
	    <row>
	      <entry><option>-b</option></entry>
	      <entry>notify</entry>
	      <entry>Notify when jobs running in background terminate (not of
	        much use in a script)</entry>
	    </row>
	    <row>
	      <entry><option>-c xxx</option></entry>
	      <entry>(none)</entry>
	      <entry>Read commands from <emphasis>xxx</emphasis></entry>
	    </row>
	    <row>
	      <entry><option>-f</option></entry>
	      <entry>noglob</entry>
	      <entry>Filename expansion (globbing) disabled</entry>
	    </row>
	    <row>
	      <entry><option>-i</option></entry>
	      <entry>interactive</entry>
	      <entry>Script runs in <emphasis>interactive</emphasis> mode</entry>
	    </row>
	    <row>
	      <entry><option>-p</option></entry>
	      <entry>privileged</entry>
	      <entry>Script runs as <quote>suid</quote> (caution!)</entry>
	    </row>
	    <row>
	      <entry><option>-r</option></entry>
	      <entry>restricted</entry>
	      <entry>Script runs in <emphasis>restricted</emphasis>
	      mode (see <xref linkend="restricted-sh">).</entry>
	    </row>
	    <row>
	      <entry><option>-u</option></entry>
	      <entry>nounset</entry>
	      <entry>Attempt to use undefined variable
		outputs error message</entry>
	    </row>
	    <row>
	      <entry><option>-v</option></entry>
	      <entry>verbose</entry>
	      <entry>Print each command to stdout before executing it</entry>
	    </row>
	    <row>
	      <entry><option>-x</option></entry>
	      <entry>xtrace</entry>
	      <entry>Similar to <option>-v</option>, but expands commands</entry>
	    </row>
	    <row>
	      <entry><option>-e</option></entry>
	      <entry>errexit</entry>
	      <entry>Abort script at first error (when a command exits with
	        non-zero status)</entry>
	    </row>
	    <row>
	      <entry><option>-n</option></entry>
	      <entry>noexec</entry>
	      <entry>Read commands in script, but do not execute them</entry>
	    </row>
	    <row>
	      <entry><option>-s</option></entry>
	      <entry>stdin</entry>
	      <entry>Read commands from stdin</entry>
	    </row>
	    <row>
	      <entry><option>-t</option></entry>
	      <entry>(none)</entry>
	      <entry>Exit after first command</entry>
	    </row>
	    <row>
	      <entry><option>-</option></entry>
	      <entry>(none)</entry>
	      <entry>End of options flag. All other arguments
		are positional parameters.</entry>
	    </row>
	    <row>
	      <entry><option>--</option></entry>
	      <entry>(none)</entry>
	      <entry>Unset positional parameters.
		If arguments given (<option>--arg1arg2</option>),
		positional parameters set to arguments.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect1> <!-- Options -->
  
    <sect1 id="gotchas">
      <title>Gotchas</title>

    <epigraph>
      <attribution>Puccini</attribution>
      <para>Turandot: Gli enigmi sono tre, la morte una!</para>
      <para>Caleph: No, no! Gli enigmi sono tre, una la vita!</para>
    </epigraph>

      <para>Assigning reserved words or characters to variable names.
	<programlisting>var1=case
# Causes problems.
var2=23skidoo
# Also problems. Variable names starting with a digit are reserved by the shell.
# Try var2=_23skidoo. Starting variables with an underscore is o.k.
var3=xyz((!*
# Causes even worse problems.</programlisting>
	</para>

      <para>Using a hyphen or other reserved characters in a variable name.
	<programlisting>var-1=23
# Use 'var_1' instead.</programlisting>
	</para>

      <para>Using white space inappropriately (in contrast to other programming
	languages <command>bash</command> can be finicky about white space).
	<programlisting>var1 = 23
# 'var1=23' is correct.
let c = $a - $b
# 'let c=$a-$b' or 'let "c = $a - $b"' are correct.
if [ $a -le 5]
# 'if [ $a -le 5 ]' is correct.</programlisting>
	</para>

      <para>Using uninitialized variables (that is, using variables before a value is
	assigned to them). An uninitialized variable has a value of
	<quote>null</quote>, <emphasis>not</emphasis> zero.</para>

	<para>Mixing up <emphasis>=</emphasis> and <emphasis>-eq</emphasis> in
	a test. Remember, <emphasis>=</emphasis> is for comparing literal
	variables and <emphasis>-eq</emphasis> is for numbers.
	<programlisting>
	if [ $a = 273 ] # Wrong!
	if [ $a -eq 273 ] # Correct.
	</programlisting>
	</para>

      <para>Sometimes variables within <quote>test</quote> brackets
	([ ]) need to be quoted (double quotes).  Failure to do so may
	cause unexpected behavior. See <xref linkend="strtest">, <xref
	linkend="redir2">, and <xref linkend="arglist">.</para>

      <para>Commands issued from a script may fail to execute because the script owner
	lacks execute permission for them. If a user cannot invoke a command from
	the command line, then putting it into a script will likewise fail. Try
	changing the attributes of the command in question, perhaps setting the
	suid bit (as root, of course).</para>

      <para>Using bash version 2 functionality (see below)
	in a script headed with <userinput>#!/bin/bash</userinput> may
	cause a bailout with error messages. Your system may still have an
	older version of bash as the default installation (<command>echo
	$BASH_VERSION</command>). Try changing the header of the script
	to <userinput>#!/bin/bash2</userinput>.</para>

      <para>A script may not <command>export</command> variables back to its
	parent process, the shell, or to the environment. Just as we
	learned in biology, a child process can inherit from a parent,
	but not vice versa.
	  <programlisting>WHATEVER=/home/bozo
export WHATEVER
exit 0</programlisting>
          <screen><prompt>bash$ </prompt><command>echo $WHATEVER</command>
<computeroutput>

</computeroutput>
<prompt>bash$ </prompt></screen>
        Sure enough, back at the command prompt, $WHATEVER remains unset. 		  
	  </para>
      
      <para>Making scripts <quote>suid</quote> is generally a bad idea, as it
	may compromise system security. Administrative scripts should be run by
	root, not regular users.</para>

      <para>Using shell scripts for CGI programming may be problematic. Shell
        script variables are not <quote>typesafe</quote>, and this can cause
	undesirable behavior as far as CGI is concerned. Moreover, it is
	difficult to <quote>hacker-proof</quote> shell scripts.</para>

    </sect1> <!-- Gotchas -->



    <sect1 id="miscellany">
      <title>Miscellany</title>

    <epigraph>
      <attribution>Tom Duff</attribution>
      <para>Nobody really knows what the Bourne shell's grammar is. Even
        examination of the source code is little help.
      </para>
    </epigraph>

      <sect2>
        <title>Interactive and non-interactive scripts</title>
         
	 <para>Let us define an <emphasis>interactive</emphasis> script
	   as one that requires input from the user, usually with
	   <command>read</command> statements (see <xref linkend="ex36">).
	   <quote>Real life</quote> is actually a bit messier than
	   that, and the formal specifications of an interactive shell
	   (according to Ramey & Fox) are complex and confusing.
	   For now, assume an interactive script is one that is bound
	   to a tty, a script that a user has invoked from the console
	   or an xterm.</para>

	 <para>Init and startup scripts are necessarily non-interactive,
	   since they must run without human intervention. Many
	   administrative and system maintenance scripts are likewise
	   non-interactive.  Unvarying repetitive tasks cry out for
	   automation by non-interactive scripts.</para>

	 <para>Non-interactive scripts can run in the background, but
	   interactive ones hang, waiting for input that never comes.
	   Handle that difficulty by having an <command>expect</command>
	   script or embedded <replaceable>here document</replaceable>
	   (see <xref linkend="here-docs">) feed input to an interactive
	   script running as a background job.	In the simplest case,
	   redirect a file to supply input to a <command>read</command>
	   statement (<emphasis>read variable &lt;file</emphasis>).
	   These particular workarounds make possible general purpose
	   scripts that run in either interactive or non-interactive
	   modes.</para>

	 <para>If a script needs to test whether it is running in interactive
	   mode, it is simply a matter of finding whether
	   the <emphasis>prompt</emphasis> variable,
	   <replaceable>$PS1</replaceable> is set. (If the user is
	   being prompted for input, then the script needs to display
	   a prompt.)
	   <programlisting>if [ -z $PS1 ] # no prompt?
then
  # non-interactive
  ...
else
  # interactive
  ...
fi</programlisting>

           Alternatively, the script can test for the presence of
	   <emphasis>i</emphasis> in the <token>$-</token> flag.
           <programlisting>case $- in
*i*)    # interactive script
;;
*)      # non-interactive script
;;
# (Thanks to "UNIX F.A.Q.", 1993)</programlisting></para>


	 <note><para>Scripts may be forced to run in interactive
	   mode with the <token>i</token> option or with a
	   <emphasis>#!/bin/bash -i</emphasis> header. Be aware that this may
	   cause erratic script behavior or show error messages where no error
	   is present.</para></note>


      </sect2> <!-- Interactive and non-interactive scripts -->


      <sect2>
        <title>Optimizations</title>

	<para>Most shell scripts are quick 'n dirty solutions to non-complex
	  problems. As such, optimizing them for speed is not much of an
	  issue.  Consider the case, though, where a script carries out
	  an important task, does it well, but runs too slowly. Rewriting
	  it in a compiled language may not be a palatable option. The
	  simplest fix would be to rewrite the parts of the script
	  that slow it down. Is it possible to apply principles of code
	  optimization even to a lowly shell script?</para>

	<para>Check the loops in the script. Time consumed by repetitive
	  operations adds up quickly. Use the <command>time</command> and
	  <command>times</command> tools to profile computation-intensive
	  commands. Consider rewriting time-critical code sections in C, or
	  even in assembler.</para> 

	 <para>Try to minimize file i/o. Bash is not particularly efficient at
	   handling files, so consider using more appropriate tools for
	   this within the script, such as awk or Perl.</para>

	 <para>Try to write your scripts in a structured, coherent form, so
	   they can be reorganized and tightened up as necessary. Some of the
	   optimization techniques applicable to high-level languages may work
	   for scripts, but others, such as loop unrolling, are mostly
	   irrelevant. Above all, use common sense.</para>

      </sect2> <!-- Optimizations -->


      <sect2>
        <title>Assorted Tips</title>

      <itemizedlist>

	<listitem>

	  <para>To keep a record of which user scripts have run
	    during a particular sesssion or over a number of sessions,
	    add the following lines to each script you want to keep track
	    of. This will keep a continuing file record of the script
	    names and invocation times. </para>

	  <para>
	  <programlisting># Append (>>) following to end of save file.
date>> $SAVE_FILE   #Date and time.
echo $0>> $SAVE_FILE   #Script name.
echo>> $SAVE_FILE   #Blank line as separator.
# Of course, SAVE_FILE defined and exported as environmental variable in ~/.bashrc
# (something like ~/.scripts-run)</programlisting>
          </para>
	</listitem>

	<listitem>
	  <para>A shell script may act as an embedded command inside
	    another shell script, a <emphasis>Tcl</emphasis> or
	    <emphasis>wish</emphasis> script, or even a Makefile. It can
	    be invoked as as an external shell command in a C program
	    using the <replaceable>system()</replaceable> call, i.e.,
	   <replaceable>system("script_name");</replaceable>.</para>
	</listitem>

	<listitem>
	  <para>Put together a file of your favorite and most useful
	    definitions and functions, then <quote>include</quote>
	    this file in scripts as necessary with either
	    the <quote>dot</quote> (<command>.</command>)
	    or <command>source</command> command (see <xref
	    linkend="special-chars">).</para>
	</listitem>    

	<listitem>
	  <para>It would be nice to be able to invoke X-Windows widgets from a
	    shell script. There do, in fact, exist a couple of packages
	    that purport to do so, namely <emphasis>Xscript</emphasis> and
	    <emphasis>Xmenu</emphasis>, but these seem to be pretty much
	    defunct. If you dream of a script that can create widgets,
	    try <emphasis>wish</emphasis> (a <emphasis>Tcl</emphasis>
	    derivative), <emphasis>PerlTk</emphasis> (Perl with Tk
	    extensions), or <emphasis>tksh</emphasis> (ksh with Tk
	    extensions).</para>
	  </listitem>

      </itemizedlist>

      </sect2> <!-- Assorted Tips -->

    </sect1> <!-- miscellany -->



    <sect1 id="bash2">
      <title>Bash, version 2</title>
      <para>The current version of <command>bash</command>, the one you have
	running on your machine, is actually version 2. This update of the
	classic <command>bash</command> scripting language added array
	variables, string and parameter expansion, and a better method
	of indirect variable references, among other features.</para>

      <example id="ex77">
	<title>String expansion</title>
	<programlisting>&ex77;</programlisting>
      </example>

      <example id="ex78">
	<title>Indirect variable references - the new way</title>
	<programlisting>&ex78;</programlisting>
      </example>
	
      <example id="ex79">
	<title>Using arrays and other miscellaneous trickery
	  to deal four random hands from a deck of cards</title>
	<programlisting>&ex79;</programlisting>
      </example>

    </sect1> <!-- Bash, version 2 -->
  </chapter> <!-- Tutorial / Reference -->


  <chapter id="credits">
    <title>Credits</title>

      <para><ulink url="mailto:feloy@free.fr">Philippe Martin</ulink>
        translated this document into DocBook/SGML. While not on
        the job at a small French company as a software developer,
        he enjoys working on GNU/Linux documentation and software,
        reading literature, playing music, and for his peace of mind
        making merry with friends. You may run across him somewhere
        in France or in the Basque Country, or email him at <ulink
        url="mailto:feloy@free.fr">feloy@free.fr</ulink>.</para>

      <para>I would like to especially thank <emphasis>Patrick
        Callahan</emphasis>, <emphasis>Mike Novak</emphasis>, and
        <emphasis>Pal Domokos</emphasis> for catching bugs, pointing out
        ambiguities, and for suggesting clarifications and changes.  Their
        lively discussion of shell scripting and general documentation
        issues inspired me to try to make this HOWTO more readable.</para>

      <para>I'm grateful to Jim Van Zandt for pointing out errors and
        omissions in version 0.2 of this HOWTO. He also contributed an
        instructive example script.</para>

      <para>Many thanks to Jordi Sanfeliu <ulink
        url="mailto:mikaku@arrakis.es">mikaku@arrakis.es</ulink>
        for giving permission to use his fine tree script (<xref
        linkend="tree">).</para>

      <para>Emmanuel Rouat suggested corrections and additions on
	command substitution and aliases (see <xref linkend="backticks">
	and <xref linkend="aliases">). He also contributed a
	very nice sample <filename>.bashrc</filename> file (<xref
	linkend="sample-bashrc">).</para>

      <para>Florian Wisser enlightened me on some of the fine points of
        testing strings (see <xref linkend="strtest">).</para>	

      <para>Others making helpful suggestions were Gabor Kiss and Leopold
        Toetsch.</para>

      <para>My gratitude to <ulink url="mailto:chet@po.cwru.edu">Chet
	Ramey</ulink> for writing <command>Bash</command>, an elegant
	and powerful scripting tool.</para>

      <para>Thanks most of all to my wife, Anita, for her encouragement and
        emotional support.</para>	

  </chapter> <!-- Credits --> 


  <bibliography id="biblio">

    <biblioentry>
      <authorgroup>
	<author><firstname>Dale</firstname><surname>Dougherty</surname></author>
	<author><firstname>Arnold</firstname><surname>Robbins</surname></author>
      </authorgroup>
      <title>Sed and Awk</title>
      <edition>2nd edition</edition>
      <publisher>
	<publishername>O'Reilly and Associates</publishername>
      </publisher>
      <copyright>
	<year>1997</year>
      </copyright>
      <isbn>1-156592-225-5</isbn>
      <abstract><para>
	  To unfold the full power of shell scripting, you need at least a passing
	  familiarity with <command>sed</command> and
	  <command>awk</command>. This is the standard tutorial. It 
	  includes an excellent introduction to <quote>regular expressions</quote>. Read this
	  book.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>Aeleen</firstname><surname>Frisch</surname></author>
      </authorgroup>
      <title>Essential System Administration</title>
      <edition>2nd edition</edition>
      <publisher>
	<publishername>O'Reilly and Associates</publishername>
      </publisher>
      <copyright>
	<year>1995</year>
      </copyright>
      <isbn>1-56592-127-5</isbn>
      <abstract><para>This excellent sys admin manual has a decent introduction to shell
	  scripting for sys administrators and does a nice job of explaining the
	  startup and initialization scripts. The book is long overdue for a third
	  edition (are you listening, Tim O'Reilly?).</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>Stephen</firstname><surname>Kochan</surname></author>
	<author><firstname>Patrick</firstname><surname>Woods</surname></author>
      </authorgroup>
      <title>Unix Shell Programming</title>
      <publisher>
	<publishername>Hayden</publishername>
      </publisher>
      <copyright>
	<year>1990</year>
      </copyright>
      <isbn>067248448X</isbn>
      <abstract><para>The standard reference, though a bit dated by now.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>Cameron</firstname><surname>Newham</surname></author>
	<author><firstname>Bill</firstname><surname>Rosenblatt</surname></author>
      </authorgroup>
      <title>Learning the Bash Shell</title>
      <edition>2nd edition</edition>
      <publisher>
	<publishername>O'Reilly and Associates</publishername>
      </publisher>
      <copyright>
	<year>1998</year>
      </copyright>
      <isbn>1-56592-347-2</isbn>
      <abstract><para>This is a valiant effort at a decent shell primer, but somewhat deficient
	  in coverage on programming topics and lacking sufficient examples.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>Anatole</firstname><surname>Olczak</surname></author>
      </authorgroup>
      <title>Bourne Shell Quick Reference Guide</title>
      <publisher>
	<publishername>ASP, Inc.</publishername>
      </publisher>
      <copyright>
	<year>1991</year>
      </copyright>
      <isbn>093573922X</isbn>
      <abstract><para>A very handy pocket reference, despite lacking
      coverage of Bash-specific features.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>Jerry</firstname><surname>Peek</surname></author>
	<author><firstname>Tim</firstname><surname>O'Reilly</surname></author>
	<author><firstname>Mike</firstname><surname>Loukides</surname></author>
      </authorgroup>
      <title>Unix Power Tools</title>
      <edition>2nd edition</edition>
      <publisher>
	<publishername>O'Reilly and Associates</publishername>
      </publisher>
      <publisher>
	<publishername>Random House</publishername>
      </publisher>
      <copyright>
	<year>1997</year>
      </copyright>
      <isbn>1-56592-260-3</isbn>
      <abstract><para>Contains a couple of sections of very informative
       in-depth articles on shell programming, but falls short of being
       a tutorial. It reproduces much of the regular expressions tutorial
       from the Dougherty and Robbins book, above.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>Arnold</firstname><surname>Robbins</surname></author>
      </authorgroup>
      <title>Bash Reference Card</title>
      <publisher>
	<publishername>SSC</publishername>
      </publisher>
      <copyright>
	<year>1998</year>
      </copyright>
      <isbn>1-58731-010-5</isbn>
      <abstract>
          <para>Excellent Bash pocket reference (don't leave home
	    without it).  A bargain at $4.95, but
	    also available for free download <ulink
	    url="http://www.ssc.com/ssc/bash/">on-line</ulink> in pdf
	    format.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>Ellen</firstname><surname>Siever</surname></author>
	<author><surname>and the Staff of O'Reilly and Associates</surname></author>
      </authorgroup>
      <title>Linux in a Nutshell</title>
      <edition>2nd edition</edition>
      <publisher>
	<publishername>O'Reilly and Associates</publishername>
      </publisher>
      <copyright>
	<year>1999</year>
      </copyright>
      <isbn>1-56592-585-8</isbn>
      <abstract><para>The all-around best Linux command reference, even has a Bash section.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <title>The UNIX CD Bookshelf</title>
      <edition>2nd edition</edition>
      <publisher>
	<publishername>O'Reilly and Associates</publishername>
      </publisher>
      <copyright>
	<year>2000</year>
      </copyright>
      <isbn>1-56592-815-6</isbn>
      <abstract><para>An array of six UNIX books on CD ROM, including
	<emphasis>UNIX Power Tools</emphasis>, <emphasis>Sed
	and Awk</emphasis>, and <emphasis>Learning the Korn
	Shell</emphasis>. A complete set of all the UNIX references
	and tutorials you would ever need at about $70. Buy this one,
	even if it means going into debt and not paying the rent.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>


    <biblioentry>
      <abstract>
	<para>The O'Reilly books on Perl. (Actually, any O'Reilly books.)</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>The man pages for <command>bash</command> and
	  <command>bash2</command>, <command>date</command>,
	  <command>expect</command>, <command>expr</command>,
	  <command>find</command>, <command>grep</command>,
	  <command>gzip</command>, <command>ln</command>,
	  <command>patch</command>, <command>tar</command>, <command>tr</command>,
	  <command>xargs</command>.  The texinfo documentation on
	  <command>bash</command>, <command>dd</command>, <command>gawk</command>,
	  and <command>sed</command>.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>The excellent "Bash Reference Manual", by Chet Ramey and Brian Fox,
	  distributed as part of the "bash-2-doc" package (available as an rpm).
	  See especially the instructive example scripts in this package.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>Ben Okopnik's well-written <emphasis>introductory Bash
	  scripting</emphasis> articles in issues 53, 54, 55, 57, and 59
	  of the <ulink url="http://www.linuxgazette.com">Linux Gazette
	  </ulink>, and his explanation of <quote>The Deep, Dark Secrets
	  of Bash</quote> in issue 56.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract><para>Chet Ramey's <emphasis>bash - The GNU Shell</emphasis>,
        a two-part series published in issues 3 and 4 of the <ulink
        url="http://www.linuxjournal.com">Linux Journal</ulink>,
        July-August 1994.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>Giles Orr's <ulink
	url="http://www.linuxdoc.org/HOWTO/Bash-Prompt-HOWTO.html">Bash-Prompt
	HOWTO</ulink>.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>Mike G's <ulink
	url="http://www.linuxdoc.org/HOWTO/Bash-Prog-Intro-HOWTO.html">Bash-Programming-Intro
	HOWTO</ulink>.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>Mark Komarinski's <ulink
	url="http://www.linuxdoc.org/HOWTO/Printing-Usage-HOWTO.html">Printing-Usage
	HOWTO</ulink>.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>Trent Fisher's <ulink
	url="http://www.cs.pdx.edu/~trent/gnu/groff/groff.html">groff
	tutorial</ulink>.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>Chet Ramey's <ulink
	url="ftp://ftp.cwru.edu/pub/bash/FAQ">Bash F.A.Q.</ulink></para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>The <ulink
	url="http://www.cornerstonemag.com/sed/sedfaq.html">sed
	F.A.Q.</ulink></para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>Carlos Duarte's instructive <ulink
	url="http://www.dbnet.ece.ntua.gr/~george/sed/sedtut_1.html"><quote>Do
	It With Sed</quote></ulink> tutorial.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>The GNU <command>gawk</command> <ulink
	url="http://sunsite.ualberta.ca/Documentation/Gnu/gawk-3.0.6/gawk.html">
	reference manual</ulink> (<command>gawk</command> is the extended
	GNU version of <command>awk</command> available on Linux and
	BSD systems).</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>There is some nice material on I/O redirection (<xref
	linkend="io-redirection">) in <ulink
	url="http://sunsite.ualberta.ca/Documentation/Gnu/textutils-2.0/html_chapter/textutils_10.html">
	chapter 10 of the textutils documentation</ulink> at the <ulink
	url="http://sunsite.ualberta.ca/Documentation"> University of
	Alberta site</ulink>.</para>
      </abstract>
    </biblioentry>


  </bibliography>



  <appendix id="contributed-scripts">
      <title>Contributed Scripts</title>

    <para>These scripts, while not fitting into the text of this document, do
    illustrate some interesting shell programming techniques. They are useful,
    too. Have fun analyzing and running them.</para>

    <example id="manview">
      <title><command>manview</command>: A script for viewing formatted man pages
      </title>
      <programlisting>&manview;</programlisting>
    </example>

    <example id="rn">
      <title><command>rn</command>: A simple-minded file rename utility</title>
      <para>This script is a modification of <xref
      linkend="lowercase">.</para>
      <programlisting>&rn;</programlisting>
    </example>

    <example id="encryptedpw">
      <title><command>encryptedpw</command>: A script for uploading to an ftp site,
      using a locally encrypted password
      </title>
      <programlisting>&encryptedpw;</programlisting>
    </example>

    <para>+</para>
    
    <para>The following two scripts are by Mark Moraes of the University
    of Toronto. See the enclosed file <quote>Moraes-COPYRIGHT</quote>
    for permissions and restrictions.</para>

    <example id="behead">
      <title><command>behead</command>: A script for removing mail and news message headers
      </title>
      <programlisting>&behead;</programlisting>
    </example>

    <example id="ftpget">
      <title><command>ftpget</command>: A script for downloading files via ftp
      </title>
      <programlisting>&ftpget;</programlisting>
    </example>

    <para>+</para>

    <para>Antek Sawicki contributed the following script, which makes very
      clever use of the parameter substitution operators discussed in
      <xref linkend="Parameter-Substitution">.</para>

    <example id="pw">
      <title><command>password</command>: A script for generating random
      8-character passwords</title>
      <programlisting>&pw;</programlisting>
    </example>

    <para>+</para>

    <para>James R. Van Zandt contributed this script, which uses named pipes
      and, in his words, <quote>really exercises quoting and escaping</quote>.
      </para>

    <example id="fifo">
      <title><command>fifo</command>: A script for making daily backups, using 
      named pipes</title>
      <programlisting>&fifo;</programlisting>
    </example>

    <para>+</para>

    <para>Jordi Sanfeliu gave permission to use his elegant
      <emphasis>tree</emphasis> script.</para>

    <example id="tree">
      <title><command>tree</command>: A script for displaying a directory
      tree</title>
      <programlisting>&tree;</programlisting>
    </example>

  </appendix>
    <!-- End Contributed Scripts appendix -->



  <appendix id="sedawk">
      <title>A Sed and Awk Micro-Primer</title>

      <para>This is a very brief introduction to the <command>sed</command>
	and <command>awk</command> text processing utilities. We will
	deal with only a few basic commands here, but that will suffice
	for understanding simple sed and awk constructs within shell
	scripts.</para>

      <para><command>sed</command>: a non-interactive text file editor</para>

       <para><command>awk</command>: a field-oriented pattern processing
         language</para>

       <para>For all their differences, the two utilities share a similar
	 invocation syntax, both use regular expressions
	 (<xref linkend="regexp">), both read input by default
	 from <filename>stdin</filename>, and both output to
	 <filename>stdout</filename>. These are well-behaved UNIX tools,
	 and they work together well. The output from one can be piped
	 into the other, and their combined capabilities give shell
	 scripts some of the power of Perl.</para>

       <note><para>One important difference between the utilities is
	 that while shell scripts can easily pass arguments to
	 sed, it is more complicated for awk (see <xref linkend="coltotaler">).
	 </para></note>

    <sect1>
      <title>Sed</title>

      <para>Sed is a non-interactive line editor. It receives text
	input, whether from <filename>stdin</filename> or from a file,
	performs certain operations on specified lines of the input,
	then outputs the result to <filename>stdout</filename> or to
	a file.  Within a shell script, sed is usually one of several
	tool components in a pipe.</para>
 
      <para>Sed determines which lines of its input that it will
	operate on from the <emphasis>address range</emphasis>
	passed to it.  Specify this address range either
	by line number or by a pattern to match. For example,
	<replaceable>3d</replaceable> signals sed to delete line 3 of
	the input, and <replaceable>/windows/d</replaceable> tells sed
	that you want every line of the input containing a match to
	<quote>windows</quote> deleted.</para>

      <para>Of all the operations in the sed toolkit, we will focus
	primarily on the three most commonly used
	ones. These are <command>p</command>rinting (to
	<filename>stdout</filename>), <command>d</command>eletion,
	and <command>s</command>ubstitution.</para>


      <table>
	<title>sed operators</title>
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Operator</entry>
	      <entry>Name</entry>
	      <entry>Effect</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><option>/address-range/p</option></entry>
	      <entry>print</entry>
	      <entry>Print (specified address range)</entry>
	    </row>
	    <row>
	      <entry><option>/address-range/d</option></entry>
	      <entry>delete</entry>
	      <entry>Delete (specified address range)</entry>
	    </row>
	    <row>
	      <entry><option>s/pattern1/pattern2/</option></entry>
	      <entry>substitute</entry>
	      <entry>Substitute pattern2 for pattern1</entry>
	    </row>
	    <row>
	      <entry><option>/address-range/y/pattern1/pattern2/</option></entry>
	      <entry>transform</entry>
	      <entry>replace pattern1 with pattern2 (works just like
	        <command>tr</command>)</entry>
	    </row>
	    <row>
	      <entry><option>g</option></entry>
	      <entry>global</entry>
	      <entry>Operate on <emphasis>every</emphasis> pattern match
	        within each matched line of input</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <note><para>Unless the <option>g</option>
	(<emphasis>global</emphasis>) operator is appended to a
	<emphasis>substitute</emphasis> command, the substitution
	operates only on the first instance of a pattern match within
	each line.</para></note>

      <para>From the command line and in a shell script, a sed operation may
       require quoting and certain options.</para>

       <para><programlisting>sed -e '/^$/d'
# The -e option causes the next string to be interpreted as an instruction.       
# The "strong" quotes ('') protect the special characters in the instruction
# from reinterpretation as regular expressions by the body of the script.
# (This reserves RE expansion of the instruction for sed.)
</programlisting></para>

       <note><para>Both sed and awk use the <option>-e</option> option
	 to specify that the following string is an instruction or set
	 of instructions. If there is only a single instruction contained
	 within the string, then the option may be omitted.</para></note>

       <para><programlisting>sed -n '/xzy/p'
# The -n option tells sed to print only those lines matching the pattern.
# Otherwise all input lines would print.
</programlisting></para>

      <table>
	<title>examples</title>
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Notation</entry>
	      <entry>Effect</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><option>8d</option></entry>
	      <entry>Delete 8th line of input.</entry>
	    </row>
	    <row>
	      <entry><option>/^$/d</option></entry>
	      <entry>Delete all blank lines.</entry>
	    </row>
	    <row>
	      <entry><option>1,/^$/d</option></entry>
	      <entry>Delete from beginning of input up to, and including
	        first blank line.</entry>
	    </row>
	    <row>
	      <entry><option>/Jones/p</option></entry>
	      <entry>Print only lines containing <quote>Jones</quote> (with
	        <token>-n</token> option).</entry>
	    </row>
	    <row>
	      <entry><option>s/Windows/Linux/</option></entry>
	      <entry>Substitute <quote>Linux</quote> for first instance
	        of<quote>Windows</quote> found in each input line.</entry>
	    </row>
	    <row>
	      <entry><option>s/BSOD/stability/g</option></entry>
	      <entry>Substitute <quote>stability</quote> for every instance
	        of<quote>BSOD</quote> found in each input line.</entry>
	    </row>
	    <row>
	      <entry><option>/GUI/d</option></entry>
	      <entry>Delete all lines containing <quote>GUI</quote>.</entry>
	    </row>
	    <row>
	      <entry><option>s/GUI//g</option></entry>
	      <entry>Delete all instances of <quote>GUI</quote>, leaving the 
	        remainder of each line intact.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

     <note><para>Substituting a zero-length string for another is equivalent
       to deleting that string within a line of input. This leaves the
       remainder of the line intact. Applying <userinput>s/GUI//</userinput>   
       to the line <userinput>The most important parts of any application are
       its GUI and sound effects</userinput> results in
       <screen><computeroutput>The most important parts of any application are its  and sound effects</computeroutput></screen>.</para></note>

     <para>For illustrative examples of sed within shell scripts, see:
       <orderedlist>
         <listitem><para><xref linkend="ex3"></para></listitem>
	 <listitem><para><xref linkend="ex4"></para></listitem>
	 <listitem><para><xref linkend="ex57"></para></listitem>
         <listitem><para><xref linkend="rn"></para></listitem>
	 <listitem><para><xref linkend="grp"></para></listitem>
	 <listitem><para><xref linkend="col"></para></listitem>
         <listitem><para><xref linkend="behead"></para></listitem>
	 <listitem><para><xref linkend="tree"></para></listitem>
	 <listitem><para><xref linkend="stripc"></para></listitem>
       </orderedlist>
     </para>  

      <para>For a more extensive treatment of sed, check the appropriate
        references in the <xref linkend="biblio">.</para>

    </sect1>
    <!-- End sed primer -->


    <sect1 id="awk">
      <title>Awk</title>

     <para><command>Awk</command> is a full-featured text processing 
       language with a syntax reminiscent of <command>C</command>. While
       it possesses an extensive set of operators and capabilities,
       we will cover only a couple of these here - the ones most useful
       for shell scripting.</para>

     <para>Awk breaks each line of input passed to it into
       <emphasis>fields</emphasis>. By default, a field is a string of
       consecutive characters separated by white space, though there are
       options for changing the delimiter. Awk parses and operates on each
       separate field. This makes awk ideal for handling structured text
       files, especially tables, data organized into consistent chunks,
       such as rows and columns.</para>

     <para>Strong quoting (single quotes) and curly brackets enclose
       segments of awk code within a shell script.</para>

     <para><programlisting>awk '{print $3}'
# Prints field #3 to stdout.

awk '{print $1 $5 $6}'
# Prints fields #1, #5, and #6.</programlisting></para> 

     <para>We have just seen the awk <command>print</command> command
       in action. The only other feature of awk we need to deal with
       here is variables. Awk handles variables similarly to shell
       scripts, though a bit more flexibly.</para>

     <para><programlisting>{ total += ${column_number} }</programlisting>
       This adds the value of <emphasis>column_number</emphasis> to
       the running total of <quote>total</quote>. Finally, to print
       <quote>total</quote>, there needs to be an <command>END</command>
       command to terminate the processing.
       <programlisting>END { print total }</programlisting></para>

     <para>Corresponding to the <command>END</command>, there is a
       <command>BEGIN</command>, for a code block to be performed before awk
       starts processing its input.</para>

     <para>For examples of awk within shell scripts, see:
       <orderedlist>
         <listitem><para><xref linkend="ex44"></para></listitem>
	 <listitem><para><xref linkend="redir4"></para></listitem>
	 <listitem><para><xref linkend="stripc"></para></listitem>
         <listitem><para><xref linkend="coltotaler"></para></listitem>
       </orderedlist>
      </para>	 

     <para>That's all the awk we'll cover here folks, but there's lots
       more to learn. See the appropriate references in the <xref
       linkend="biblio">.</para>


     </sect1> 
    <!-- End awk primer -->

  </appendix>
    <!-- End sed/awk appendix -->



  <appendix id="sample-bashrc">
      <title>A Sample <filename>.bashrc</filename> File</title>

     <para>The <filename>~/.bashrc</filename> file determines the behavior of
       the shell, and of shell scripts. A proper understanding of this file
       can lead to more effective use of scripts.</para>

     <para>Emmanuel Rouat contributed the following very elaborate
       <filename>.bashrc</filename> file. He wrote it for a Solaris system,
       but it (mostly) works for other flavors of UNIX as well. Study this 
       file carefully, and feel free to reuse code snippets and functions from
       it in your own <filename>.bashrc</filename> file and even in your
       scripts.</para>


      <example id="bashrc">
	<title>Sample <filename>.bashrc</filename> file</title>
	<programlisting>&bashrc;</programlisting>
      </example>

  </appendix>
    <!-- End Sample .bashrc File appendix -->


  <appendix id="copyright">
    <title>Copyright</title>
    <para>The <quote>Advanced Bash-Scripting HOWTO</quote> is copyright,
      (c) 2000, by Mendel Cooper. This document may only be distributed
      subject to the terms and conditions set forth in the <ulink
      url="http://www.linuxdoc.org/manifesto.html">LDP License</ulink>
      These are very liberal terms, and they should not hinder
      any legitimate distribution or use of this HOWTO. The author
      especially encourages the use of this HOWTO, or portions thereof,
      for instructional purposes.</para>

    <para>A Korean translation of this HOWTO is in process. If you wish to
      translate it into another language, please feel free to do so, subject
      to the terms stated above. The author would appreciate being notified of
      such efforts.</para>
    
    <para>If this document is incorporated into a printed book, the author
      requests a courtesy copy. This is a request, not a requirement.</para>
  </appendix>
    <!-- End Copyright appendix -->


<!-- Uncomment line below to generate index. -->
<!--
&indice;
-->

</book>
<!--
</article>
-->
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-indent-step:2
sgml-indent-data:t
End:
-->

