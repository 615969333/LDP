#!/usr/bin/perl
#
# this utility converts a texinfo file into LDP WikiText format.
# 
use File::Basename;
use FileHandle;
use HTML::Entities;

$version = "0.1";

$errors = 0;
$error = 0;

# runtime options
# 
$maxerrors = 10;
$verbose = 0;

# files
# 
$requestedfile = "";
$outputfile = "";
$outfh = new FileHandle;
$logfile = "";
$logfh = new FileHandle;

# the following are flags to maintain state
# 
# docbook structure flags
#
$inabstract = 1;
$inappendix = 0;
$insect1 = 0;
$insect2 = 0;
$insect3 = 0;
$insect44 = 0;
$intable = 0;
$inrow = 0;
$incol = 0;
$tableformat = "";
$inorderedlist = 0;
$initemizedlist = 0;
$inlistitem = 0;
$informalpara = 0;
$inpara = 0;

# these maintain internal program state
#
$line = "";
$originalline = "";
$currentfile = "";
$currentline = "";
$saveline = "";
$badbracketlines = 0;
$badbracketstartline = 0;
$seekend = "";
$literalend = "";
$literal = "";

# here, we hold onto meta-data that we will need to build
# the article or book header structures.
#
$sgmlfile = "";
$title = "";
$authorname = "";
$buf = "";

# these are used when parsing the line for commands
# 
$command;
$tag;
$tagplain;
$contents;

# these hold information about the node we are currently in, if any
#
$nodename = "";
$nodenext = "";
$nodeprev = "";
$nodeup = "";
$nodeid = "";
$nodeinit = 0;

# remember this hierarchical information for every node
# we use it if the node doesn't specify a level.
#
%nodenames  = ();
%nodenexts  = ();
%nodeprevs  = ();
%nodeups    = ();
%nodelevels = ();

# holds user variables
#
%setvalues = ();
%ifsets = ();

# this is used to build a list of index entries to be written when requested
#
%indexes = ();

# These are used for keeping state on the most recent search of any of the following hashes
#
$pattern = "";
$action = "";
$replacement = "";

# In the following hash, the perl expressions are used to search
# each line of the input file. If matched, the Action field defines
# what to do with it.
#
# Note that @-Commands of this type must be at the beginning of the line.
#
# TODO: put these in a .conf file so it can be tweaked or customized
#
# Actions:
# 
#	DROPLINE	Drop it on the floor
#	DROPBLOCK	Drop the whole block on the floor
#	META		Meta-Data
#	BYE		Stop processing the file
#	INDEX		An index entry
#	ORDEREDLIST	Numbered (enumerated) list
#	ORDEREDLISTEND	End an enumerated list
#	SEEKEND		Skip everything until you find the corresponding @end tag
#	NODE		A Texinfo node
#	SECT?		One of the sectioning commands
#	APPENDIX?	One of the appendix commands
#	DEFINFOENCLOSE	Load a customized highlighting pattern
#	SET		Set a variable
#	CLEAR		Clear a variable
#	IFSET		Test a variable
#
#	@-Command			Action
%patterns = (
	'\\input\b'			=>'DROPLINE',
#	'\@\*'				=>'PARA',
	'^\@alias'			=>'ALIAS',
	'^\@author'			=>'META',
	'^\@bye\b'			=>'BYE',
	'^\@c\b'			=>'DROPLINE',
	'^\@cindex\b'			=>'INDEX',
	'^\@clear\b'			=>'CLEAR',
	'^\@comment\b'			=>'DROPLINE',
	'^\@contents\b'			=>'DROPLINE',
	'^\@defindex\b'			=>'DROPLINE',		# TODO
	'^\@definfoenclose'		=>'DEFINFOENCLOSE',
	'^\@dircategory'		=>'DROPLINE',
	'^\@direntry'			=>'SEEKEND',
	'^\@display\b'			=>'LITERALBLOCK',
	'^\@enumerate\b'		=>'ORDEREDLIST',
	'^\@end enumerate\b'		=>'ORDEREDLISTEND',
	'^\@example'			=>'LITERALBLOCK',
	'^\@format\b'			=>'LITERALBLOCK',
	'^\@headings\b'			=>'DROPLINE',
	'^\@html\b'			=>'SEEKEND',
	'^\@end html\b'			=>'DROLINE',
	'^\@ifhtml\b'			=>'SEEKEND',
	'^\@end ifhtml\b'		=>'DROPLINE',
	'^\@ifinfo\b'			=>'SEEKEND',
	'^\@end ifinfo\b'		=>'DROPLINE',
	'^\@ifnottex\b'			=>'SEEKEND',
	'^\@end ifnottex\b'		=>'DROPLINE',
	'^\@ifset\b'			=>'IFSET',		# handled like SEEKEND
	'^\@end ifset\b'		=>'DROPLINE',		# or ignored, so ignore this too
	'^\@ifclear\b'			=>'IFCLEAR',
	'^\@end ifclear\b'		=>'DROPLINE',
	'^\@iftex\b'			=>'DROPLINE',
	'^\@end iftex\b'		=>'DROPLINE',
	'^\@ignore\b'			=>'SEEKEND',
	'^\@itemize\b'			=>'ITEMIZEDLIST',
	'^\@end itemize\b'		=>'ITEMIZEDLISTEND',
	'^\@item\b'			=>'ITEM',
	'^\@itemx\b'			=>'ITEM',
	'^\@macro\b'			=>'MACRO',
	'^\@menu\b'			=>'SEEKEND',		# TODO
	'^\@node\b'			=>'NODE',
	'^\@page\b'			=>'DROPLINE',
	'^\@printindex\b'		=>'DROPLINE',		# TODO
	'^\@set\b'			=>'SET',
	'^\@setchapternewpage\b'	=>'DROPLINE',	
	'^\@setfilename\b'		=>'META',
	'^\@settitle\b'			=>'META',
	'^\@smallbook\b'		=>'DROPLINE',
	'^\@smallexample\b'		=>'LITERALBLOCK',
	'^\@sp\b'			=>'DROPLINE',
	'^\@table\b'			=>'TABLE',
	'^\@end table\b'		=>'TABLEEND',
	'^\@vtable\b'			=>'TABLE',
	'^\@end vtable\b'		=>'TABLEEND',
	'^\@tex\b'			=>'SEEKEND',
	'^\@titlepage\b'		=>'SEEKEND',

	'^\@top\b'			=>'SECT1',		# sectioning commands
	'^\@chapter\b'			=>'SECT1',
	'^\@section\b'			=>'SECT2',
	'^\@subsection\b'		=>'SECT3',
	'^\@subsubsection\b'		=>'SECT4',
	'^\@centerchap\b'		=>'SECT1',
	'^\@unnumbered\b'		=>'SECT1',
	'^\@unnumberedsec\b'		=>'SECT2',
	'^\@unnumberedsubsec\b'		=>'SECT3',
	'^\@unnumberedsubsubsec\b'	=>'SECT4',
	'^\@majorheading\b'		=>'SECT1',
	'^\@chapheading\b'		=>'SECT1',
	'^\@heading\b'			=>'SECT2',
	'^\@subheading\b'		=>'SECT3',
	'^\@subsubheading\b'		=>'SECT4',
	'^\@appendix\b'			=>'APPENDIX',
	'^\@appendixsec\b'		=>'SECT1',
	'^\@appendixsubsec\b'		=>'SECT2',
	'^\@appendixsubsubsec\b'	=>'SECT3',
);

# these are one-for-one string substitutions
# 
# most of them are ISO-8879 codes for international characters,
# used by HTML as well as XML, but there are exceptions.
# There is one special case, "@@", which is the escaped form of @.
# We do not handle @@ here, because it has to come after all other
# @-commands have been processed.
# 
# It's fine to replace these with nothing if you want them to be
# simply dropped on the floor.
#
# I keep these in general alphabetical order, except that @end tags
# are put right after their opening form.
#
# Note: Only the left side should be escaped!
#
%substitutions = (
	'@.'			=>'.',
	'@!'			=>'!',
	'@*'			=>'',
	'@s'			=>' ',
	'@"A'			=>'&Auml;',
	'@"E'			=>'&Euml;',
	'@"I'			=>'&Iuml;',
	'@"O'			=>'&Ouml;',
	'@"U'			=>'&Uuml;',
	'@"a'			=>'&auml;',
	'@"e'			=>'&euml;',
	'@"i'			=>'&iuml;',
	'@"o'			=>'&ouml;',
	'@"u'			=>'&uuml;',
	'@' . "'" . 'A'		=>'&Aacute;',
	'@' . "'" . 'E'		=>'&Eacute;',
	'@' . "'" . 'I'		=>'&Iacute;',
	'@' . "'" . 'O'		=>'&Oacute;',
	'@' . "'" . 'U'		=>'&Uacute;',
	'@' . "'" . 'a'		=>'&aacute;',
	'@' . "'" . 'e'		=>'&eacute;',
	'@' . "'" . 'i'		=>'&iacute;',
	'@' . "'" . 'o'		=>'&oacute;',
	'@' . "'" . 'u'		=>'&uacute;',
	'@,{c}'			=>'&cedil;',
	'@-'			=>'&macr;',
	'@\.'			=>'.',
	'@:'			=>'',
	'@='			=>'',
	'@\?'			=>'?',
	'@^A'			=>'&Acirc;',
	'@^E'			=>'&Ecirc;',
	'@^I'			=>'&Icirc;',
	'@^O'			=>'&Ocirc;',
	'@^U'			=>'&Ucirc;',
	'@^a'			=>'&acirc;',
	'@^e'			=>'&ecirc;',
	'@^i'			=>'&icirc;',
	'@^o'			=>'&ocirc;',
	'@^u'			=>'&ucirc;',
	'@`A'			=>'&Agrave;',
	'@`E'			=>'&Egrave;',
	'@`I'			=>'&Igrave;',
	'@`O'			=>'&Ograve;',
	'@`U'			=>'&Ugrave;',
	'@`a'			=>'&agrave;',
	'@`e'			=>'&egrave;',
	'@`i'			=>'&igrave;',
	'@`o'			=>'&ograve;',
	'@`u'			=>'&ugrave;',
#	'@\{'			=>'{',			# do these manually at the end so brackets match
#	'@\}'			=>'}',
	'@~A'			=>'&Atilde;',
	'@~E'			=>'&Etilde;',
	'@~I'			=>'&Itilde;',
	'@~O'			=>'&Otilde;',
	'@~U'			=>'&Utilde;',
	'@~a'			=>'&atilde;',
	'@~e'			=>'&etilde;',
	'@~i'			=>'&itilde;',
	'@~o'			=>'&otilde;',
	'@~u'			=>'&utilde;',
	'@center'		=>'',
	'@equiv'		=>'&equiv;',
	'@group'		=>'',
	'@end group'		=>'',
	'@exclamdown'		=>'&iexcl;',
	'@noindent'		=>'',
	'@refill'		=>'',
);

# these are inline tags that require some kind of programmatic control
# because they do strange things.
# 
%specsubstitutions = (
	'@anchor'		=>'ANCHOR',
	'@ref'			=>'REF',
	'@uref'			=>'UREF',
	'@xref'			=>'XREF',
	'@bullet'		=>'*',
	'@kbd'			=>'KBD',
	'@AA'			=>'&Aring;',
	'@aa'			=>'&aring;',
	'@AE'			=>'&AElig;',
	'@ae'			=>'&aelig;',
	'@copyright'		=>'&copy;',
	'@dots'			=>'&hellip;',
	'@minus'		=>'-',
	'@O'			=>'&Oslash;',
	'@o'			=>'&oslash;',
	'@result'		=>'=&gt;',
	'@TeX'			=>'TeX',
	'@enddots'		=>'&hellip;',
);

# These are special block wrapping tags. When we hit one of these,
# we simply wrap whatever comes between the (always paired) tags
# with a set of DocBook tags.
#
# Their handling is subtly different than the %tags.
# We don't just replace them with the DocBook tags, because we
# want any <para> tags to go inside them, not outside.
# 
%blocks = (
	'\@quotation\b'		=>'<blockquote>',
	'\@end quotation'	=>'</blockquote>',
);

# these are inline @-Commands which are replaced by a set of tags instead of one-for-one
# character substitution. Replacement is inline.
#
# there is also a special case, the "blank" tag, which does what you'd think.
# It removes the existing tag, but doesn't add the wrapper.
# 
# Example: @code{foo} becomes <literal>foo</literal>.
#
%tags = (
	'@acronym'		=>'abbrev',
	'@b'			=>"emphasis role='bold'",
	'@cite'			=>'citetitle',
	'@code'			=>'literal',
	'@command'		=>'command',
	'@dfn'			=>"emphasis role='bold'",
	'@key'			=>'keycap',
	'@email'		=>'email',
	'@emph'			=>'emphasis',
	'@env'			=>'envvar',
	'@footnote'		=>'footnote',
	'@file'			=>'filename',
	'@i'			=>'emphasis',
	'@samp'			=>'literal',
	'@sc'			=>'',
	'@t'			=>'programlisting',
	'@w'			=>'',
);

# this is where definfoenclose definitions go, and they are processed last
# 
%definfos = ();

# and this is where macros are stored
#
$inmacro = 0;
$macro = "";
%macros = {};
$macroargs = "";
%macroargs = ();
$macrotext = "";
%macrotext = ();

%aliases = ();

##############################################################################
##############################################################################
##############################################################################


while (1) {
	if ($ARGV[0] eq '') {
		last;
	} elsif ($ARGV[0] eq '--version') {
		&version;
		exit(0);
	} elsif (($ARGV[0] eq '-f') or ($ARGV[0] eq '--file')) {
		shift(@ARGV);
		$requestedfile = $ARGV[0];
	} elsif (($ARGV[0] eq '-o') or ($ARGV[0] eq '--output-to')) {
		shift(@ARGV);
		$outputfile = $ARGV[0];
	} elsif (($ARGV[0] eq '-l') or ($ARGV[0] eq '--log-to')) {
		shift(@ARGV);
		$logfile = $ARGV[0];
	} elsif (($ARGV[0] eq '-e') or ($ARGV[0] eq '--max-errors')) {
		shift(@ARGV);
		$maxerrors = $ARGV[0];
	} elsif (($ARGV[0] eq '-v') or ($ARGV[0] eq '--verbose')) {
		$verbose++;
	} elsif (($ARGV[0] eq '-h') or ($ARGV[0] eq '--help')) {
		&usage;
	} else {
		&raiseerror("unrecognized option: $ARGV[0]\n");
		$error = 1;
		&usage;
	}
	shift(@ARGV);
}

# be sure to open the log file before trying to write any messages to it!
# 
if ($logfile) {
	open ($logfh, "> $logfile") or die "cannot write to log file $logfile.\n";
}

$verbose = 3 if ($verbose > 3);
&message("verbose mode on.") if ($verbose == 1);
&message("debugging mode on.") if ($verbose ==2);
&message("insanity mode on.") if ($verbose ==3);

if ($outputfile) {
	&message("output will go to $outputfile") if ($verbose);
	open($outfh, "> $outputfile");
}

while (<DATA>) {
	$template .= $_;
}

&processfile ("$requestedfile");

&writefile;
close($outfh) if ($outputfile);
close($logfh) if ($logfile);

sub processfile {
	my($filename,
	   $basename,
	   $path,
	   $ext,
	   $includefile,
	   $linenumber,
	  );

	$macrolinecount = 0;
	
	my $fh = new FileHandle;

	$filename = @_[0];
	$filename = 'STDIN' unless ($filename);

	($basename, $path, $ext) = fileparse($filename);
	&message("processing $filename") if ($verbose);
	$linenumber = 0;

	open $fh, "<$filename" or raiseerror("cannot open $filename\n");
LINE:	while ($line = <$fh>) {
		chomp($line);

		$linenumber++;
		$currentfile = $filename;
		$currentline = $linenumber;

		&cleanline;
		$originalline = $line;
		$trimline;

		if ($seekend) {
			$seekend = '' if ($line =~ /$seekend/);
			next LINE;
		}
		
		&message("LINE $currentline: $line") if ($verbose > 1);

		$line =~ s/&/&amp;/g;		# keep before the &lt; &gt; so we don't clobber them
		$line =~ s/\</&lt;/g;
		$line =~ s/\>/&gt;/g;
		$line =~ s/\@\@\}/DCM_AT\}/g;
		$line =~ s/\@\{/DCM_LB/g;
		$line =~ s/\@\}/DCM_RB/g;

		# keep reading until we have only complete tags
		# 
		if ($saveline) {
			$line = $saveline . ' ' . $line;
			$saveline = '';
			&message("line restored, line: $line") if ($verbose > 1);
		}
		unless (&bracketsmatch($line)) {
			&message("bracket mismatch") if ($verbose > 2);
			$saveline = $line;
			next LINE;
		}

		if ($line =~ /^\@include/) {
			$includefile = $line;
			$includefile =~ s/^\@include\s+//;
			$includefile = $path . $includefile;
			$line = '';
			if (-e $includefile) {
				&message("including $includefile") if ($verbose);
				&processfile ("$includefile");
			} else {
				&raiseerror("include file $includefile not found.");
			}
		} elsif ($literalend) {
			if ($line =~ /$literalend/) {
				$literalend = '';
				&closeliteral;
			} else {
				&writeline;
			}
		} elsif ($inmacro) {
			($pattern, $action) = &matchpattern();
			if ($action eq 'SEEKEND') {
				$seekend = $pattern;
				$seekend =~ s/\@/\@end /;
				next LINE;
			} elsif ($action eq 'DROPLINE') {
				next LINE;
			}
			if ($line =~ /\@end\s+macro/) {
				#save macro
				$macroargs{$macro} = $macroargs;
				$macrotext{$macro} = $macrotext;
				&message("macro name: $macro args: $macroargs text: $macrotext") if ($verbose > 2);
				$inmacro = 0;
				$macroargs = '';
				$macrotext = '';
				$macrolinecount = 0;
			} elsif ($line =~ /\@quote-arg/) {
			} else {
				&message("macro line: $line") if ($verbose > 2);
				$macrotext .= $line;
				$macrolinecount++;
				if ($macrolinecount >= 10) {
					exit(1);
				}
			}
		} elsif ($intable) {
			&message("table: $line") if ($verbose > 2);
			($pattern, $action) = &matchpattern();
			if ($action eq 'TABLEEND') {
				&closetable;
			} elsif ($action eq 'ITEM') {
				&tablerow;
				&tablecol;
				$line =~ s/\@item\w*?\s+//;
				&message("cell: $line") if ($verbose > 2);
				$line = &trim($line);
				$line = $tableformat . "\{$line\}" unless ($tableformat eq '@asis');
				writeline;
				&closetablecol;
			} else {
				&tablecol;
				&writeline;
			}
		} else {
			($pattern, $action) = &matchblock();
			if ($action) {
				&message("matched block $pattern") if ($verbose > 2);
				&closepara;
				$buf .= $action;
				next LINE;
			}
			($pattern, $action) = &matchpattern();
			if ($action eq 'DROPLINE') {
				next LINE;
			} elsif ($action eq 'SEEKEND') {
				$seekend = $pattern;
				$seekend =~ s/\@/\@end /;
			} elsif ($action eq 'LITERALBLOCK') {
				$literalend = $pattern;
				$literalend =~ s/\@/\@end /;
				&literal;
			} elsif ($action eq 'ALIAS') {
				&alias;
			} elsif ($action eq 'MACRO') {
				&macro;
			} elsif ($action eq 'META') {
				&meta;
			} elsif ($action eq 'NODE') {
				&node;
			} elsif ($action eq 'SECT1') {
				&sect1;
			} elsif ($action eq 'SECT2') {
				&sect2;
			} elsif ($action eq 'SECT3') {
				&sect3;
			} elsif ($action eq 'SECT4') {
				&sect4;
			} elsif ($action eq 'APPENDIX') {
				&appendix;
			} elsif ($action eq 'PARA') {
				&closeformalpara;
				&para;
			} elsif ($action eq 'ORDEREDLIST') {
				&orderedlist;
			} elsif ($action eq 'ORDEREDLISTEND') {
				&closeorderedlist;
			} elsif ($action eq 'ITEMIZEDLIST') {
				&itemizedlist;
			} elsif ($action eq 'ITEMIZEDLISTEND') {
				&closeitemizedlist;
			} elsif ($action eq 'ITEM') {
				&item;
			} elsif ($action eq 'TABLE') {
				$tableformat = $line;
				$tableformat =~ s/^\@\w+\s+//;
				&message("table format: $tableformat") if ($verbose > 2);
				&table;
			} elsif ($action eq 'TABLEEND') {
				&closetable;
			} elsif ($action eq 'INDEX') {
				&message("indexing not yet supported") if ($verbose);
			} elsif ($action eq 'DEFINFOENCLOSE') {
				&definfoenclose;
			} elsif ($action eq 'SET') {
				&set;
			} elsif ($action eq 'CLEAR') {
				&clear;
			} elsif ($action eq 'IFSET') {
				$seekend = '\@end ifset' unless (&ifset());
			} elsif ($action eq 'IFCLEAR') {
				$seekend = '\@end ifclear' if (&ifset());
			} elsif ($action eq 'BYE') {
				&closesect1;
				last;
			} elsif ($action eq 'ERROR') {
				&raiseerror("Hit ERROR tag with $pattern on $line");
			} elsif ($action eq '') {
				&writeline;
			} else {
				&raiseerror("Unknown action: $action on command $pattern");
			}
		}
	}
	close($fh);
}

sub cleanline {
	$line =~ s/\x0c//;
}

sub writefile {
	&closeappendix;
	print $outfh $buf;
	print $outfh '</article>'. "\n";
}

####################
# PATTERN MATCHING #
####################

# this is for beginning-of-line @-commands
# 
sub matchpattern {
	foreach $key (keys %patterns) {
		if ($line =~ /$key/) {
			return ($key, $patterns{$key});
		}
	}
	return ('', '');
}

# this is for special wrapped blocks, like blockquotes
#
sub matchblock {
	foreach $key (keys %blocks) {
		if ($line =~ /$key/) {
			return ($key, $blocks{$key});
		}
	}
}

# the rest are all inline processing
#
sub convertinline {

	# Do this first to avoid @@foo from being
	# identified as a command later.
	$line =~ s/\@\@/\@/;

TAG:	while ($line =~ /\@\w+\{[^\{]*?\}/) {
	
		$command = $line;
		$command =~ s/.*(\@\w+\{[^{]*?\}).*/\1/;
		$tag = $command;
		$tag =~ s/(.*)\{.*/\1/;
		$tagplain = $tag;
		$tagplain =~ s/\@//;
		$contents = $command;
		$contents =~ s/.*\{(.*)\}/\1/;
		&message("line:     $line") if ($verbose > 1);
		&message("command:  $command") if ($verbose > 2);
		&message("tag:      $tag") if ($verbose > 2);
		&message("tagplain: $tagplain") if ($verbose > 2);
		&message("contents: $contents") if ($verbose > 2);

		# substitutions (only @{} type will get caught here)
		# 
		if (exists $substitutions{$tag}) {
			$replacement = $substitutions{$tag};
			&replaceinline;
			next TAG;
		}
		
		# macros
		#
		if (exists $macros{$tagplain}) {
			$macro = $macros{$tagplain};
			$macroargs = "\\\\" . $macroargs{$tagplain} . "\\\\";
			$macrotext = $macrotext{$tagplain};
	
			$macroarg = $command;
			$macroarg =~ s/^.*?\@$macro\{//;
			$macroarg =~ s/\}.*?$//;
			$macrotext =~ s/\@$macro\{([^\{]*?)\}/$macroarg/;
			$macrotext =~ s/$macroargs/$macroarg/g;
			$replacement = $macrotext;
			&replaceinline;
			next TAG;
		}

		# special character substitutions
		# 
		if (exists $specsubstitutions{$tag}) {
			$replacement = $specsubstitutions{$tag};
			&replacespecsubst;
			&replaceinline;
			next TAG;
		}
		
		# docbook wrapper tags
		# 
		if (exists $tags{$tag}) {
			$replacement = $tags{$tag};
			if ($replacement) {
				($tag, $attributes) = split(/ /, $replacement);
				if ($attributes) {
					$replacement = "\<$tag $attributes\>$contents\<\/$tag\>";
				} else {
					$replacement = "\<$tag\>$contents\<\/$tag\>";
				}
			} else {
				$replacement = $contents;
			}
			&replaceinline;
			next TAG;
		}

		if (exists $definfos{$tagplain}){
			$action = $definfos{$tagplain};
			($prefix, $suffix) = split(/,/,$action);
			$replacement = $prefix . $contents . $suffix;
			&message("definfo prefix: $prefix, suffix: $suffix, contents: $contents") if ($verbose > 1);
			&replaceinline;
			next TAG;
		}

		if (exists $setvalues{$contents}) {
			$replacement = $setvalues{$contents};
			&replaceinline;
			next TAG;
		}

		if (exists $aliases{$tag}) {
			$replacement = $aliases{$tag} . '{' . $contents . '}';
			&replaceinline;
			next TAG;
		}
		
		&raiseerror("cannot resolve $command");
		$replacement = "ERROR";
		&replaceinline;
	}
	
	# fix character-level substitutions.
	#
	for $key (keys %substitutions) {
		$key = quotemeta($key);
		$line =~ s/$key/$substitutions{$key}/g
	}
}

sub replaceinline {
	&message("replacing $command with $replacement") if ($verbose > 1);
	$command = quotemeta($command);
	$line =~ s/$command/$replacement/;
}

sub replacespecsubst {
	my $anchor;
	my $link;
	my $linkname;
	my $keystring;
	my @keycombos;
	my @keycaps;
	my $mykeys;

	if ($replacement eq 'REF') {
		&message("making xref on line $line") if ($verbose > 1);
		$link = $contents;
		$linktitle = &trim($link);
		$link = &linkfix($link);
		&message("link: $link, title; $linktitle") if ($verbose > 2);
		&raiseerror("NO ANCHOR in $line") unless ($link);

		# decide what kind of link to make based on whether it is 
		# to a section or not. Sections have titles that can be
		# referenced using an xref. Anchors do not, and we have to
		# render a full <link> tag.
		# 
		if ($nodelevels{$link}) {
			$replacement = "See \<xref linkend='$link' endterm='$link-title'\/\>";
		} else {
			$replacement = "See \<link linkend='$link'\>$linktitle\<\/link\>";
		}
		&message("made xref to tag $link on line: $line") if ($verbose > 1);
	} elsif ($replacement eq 'UREF') {
		$link = $contents;
		($link, $linkname) = split(/,/, $link);
		$link = &trim($link);
		$linkname = &trim($linkname);
		$linkname = $link unless ($linkname);
		$replacement = "\<ulink url='$link'\>$linkname\<\/ulink\>";
		&message("ulink: $link, linkname: $linkname, line: $line") if ($verbose > 2);
	} elsif ($replacement eq 'XREF') {
		($link, $linkname, $foo, $foo) = split(/,/, $contents);
		$link = &anchorfix(&trim($link));
		$linkname = &trim($linkname);
		$linkname = $link unless ($linkname);
		&message("xref, contents: $contents, link: $link, linkname: $linkname");
		if ($nodelevels{$link}) {
			$replacement = "\<xref linkend='$link' endterm='$link-title'\/\>";
		} else {
			$replacement = "\<link linkend='$link'\>$linkname\<\/link\>";
		}
	} elsif ($replacement eq 'ANCHOR') {
		$link = $contents;
		$link = &anchorfix($link);
		$replacement = "<anchor id='$link'\/\>";
	} elsif ($replacement eq 'KBD') {
		$keystring = $contents;
		@keycombos = split(/\s+/, $keystring);
		foreach $keycombo (@keycombos) {
			&message("keycombo: $keycombo");
			@keycaps = split('-', $keycombo);
			if (length(@keycaps) > 1) {
				$mykeys .= "\<keycombo action='simul'\>";
				foreach $keycap (@keycaps) {
					$mykeys .= "\<keycap\>$keycap\<\/keycap\>";
				}
				$mykeys .= '</keycombo>'
			} else {
				$mykeys .= "\<keycap\>$keycaps[0]\<\/keycap\>";
			}
		}
		$replacement = $mykeys;
	} else {
		$replacement = $specsubstitutions{$tag};
	}
}

sub anchorfix {
	my $anchor = $_[0];
	$anchor = lc(&trim($anchor));
	$anchor = decode_entities($anchor);
	$anchor =~ s/&/-and-/g;
	$anchor =~ s/;//g;
	$anchor = encode_entities($anchor);
	$anchor =~ s/&(\w)grave/\1/g;
	$anchor =~ s/&(\w)acute/\1/g;
	$anchor =~ s/&(\w)circ/\1/g;
	$anchor =~ s/&(\w)uml/\1/g;
	$anchor =~ s/&(\w)tilde/\1/g;
	$anchor =~ s/&(\w)cedil/\1/g;
	$anchor =~ s/&/-and-/g;
	$anchor =~ s/;//g;
	$anchor =~ s/\//-/g;
	$anchor =~ s/\s+/-/g;
	$anchor =~ s/'//g;
	$anchor =~ s/!//g;
	$anchor =~ s/--/-/g;
	$anchor =~ s/\+/plus/g;
	$anchor =~ s/\*/x/g;
	$anchor =~ s/\(//g;
	$anchor =~ s/\)//g;
	$anchor =~ s/\@/at/g;
	$anchor =~ s/^-+//;
	$anchor =~ s/-+$//;
	$anchor =~ s/\$/S/;
	$anchor =~ s/\.//;
	return $anchor;
}

#############
# META-DATA #
#############

# this routine processes meta-data @-Commands
# 
sub meta {
	return if (&metaarg('\@setfilename',	$sgmlfile));
	return if (&metaarg('\@settitle', 	$title));
	return if (&metaarg('\@author', 	$authorname));
	&raiseerror("Unknown meta-data command $line");
}

# Meta-data commands have arguments,
# so if the pattern matches, store the argument
# to the variable in $_[1]
#
sub metaarg {
	my $pattern = $_[0];
	if ($line =~ /$pattern/) {
		$_[1] = $line;
		$_[1] =~ s/$pattern//;
	}
}

################
# WRITE OUTPUT #
################

sub writeline {
	my $temp = &trim($line);
	
	&convertinline;
	unless (&bracketsmatch($line)) {
		&raiseerror("brackets do not match in line: $line");
		last;
	}

	unless ($literal) {
		if ($temp eq '') {
			&closeformalpara;
		} else {
			unless (($inpara) or ($intable)) {
				if (($nodename) and ($nodeinit == 0)) {
					&initnode;
				}
				&para;
			}
		}
	}
	$line =~ s/\@\@/\@/g;
	$line =~ s/DCM_AT/\@/g;
	$line =~ s/DCM_LB/\{/g;
	$line =~ s/DCM_RB/\}/g;
	$buf .= $line . "\n";
	if ($linenumber % 1000 == 0) {
		print $outfh $buf;
		$buf = '';
	}
}

##############################################
# STRUCTURAL TEXINFO -> DOCBOOK TRANSLATIONS #
##############################################

# this is for when the source never set a position for this node in the
# chapter-style hierarchy, which we use.
#
# We have to make a best guess based on the node's settings,
# so put it right under whoever it calls the "up" node.
# 
sub initnode {
	my $parentname = $nodeup;
	my $parentlevel = $nodelevels{$parentname};
	if ($parentlevel == "A") {
		&sect1;
	} elsif ($parentlevel == 1) {
		&sect2;
	} elsif ($parentlevel == 2) {
		&sect3
	} elsif ($parentlevel == 3) {
		&sect4;
	} else {
		&raiseerror("The parent node, $parentname, could not be found.");
	}
}

sub node {
	$line =~ s/\@node\b//;
	&convertinline;
	($nodename, $nodenext, $nodeprev, $nodeup) = split(/,/, $line);
	$nodename = &trim($nodename);
	$nodeid = &anchorfix($nodename);
	$nodeprev = &trim($nodeprev);
	$nodenext = &trim($nodenext);
	$nodeup   = &trim($nodeup);
	$nodeinit = 0;
	&message("Name: $nodename Next: $nodenext Previous: $nodeprev Up: $nodeup") if ($verbose > 1);
	&closeformalpara;
	if ($inabstract) {
		$inabstract = 0;
		&message("copying meta-data to docbook") if ($verbose);
		$template =~ s/%%TITLE/$title/;
		$template =~ s/%%ABSTRACT/$buf/;
		print $outfh $template . "\n";
		$buf = "";
	}
	$nodenames{$nodename} = $nodename;
	$nodenexts{$nodename} = $nodenext;
	$nodeprevs{$nodename} = $nodeprev;
	$nodeups{$nodename} = $nodeup;
}

sub appendix {
	&closeappendix;
	$buf .= "\<appendix id='$nodeid'\>\<title id='$nodeid-title'\>$nodename\<\/title\>";
	$inappendix = 1;
	$nodeinit = 1;
	$nodelevels{$nodename} = "A";
	&message("processing node $nodename at level $nodelevels{$nodename}") if ($verbose);
}

sub sect1 {
	&closesect1;
	$buf .= "\<sect1 id='$nodeid'\>\<title id='$nodeid-title'\>$nodename\<\/title\>";
	$insect1 = 1;
	$nodeinit = 1;
	$nodelevels{$nodename} = 1;
	&message("set node $nodename level to $nodelevels{$nodename}") if ($verbose > 0);
}

sub sect2 {
	&closesect2;
	if ($inappendix) {
		$buf .= "\<sect1 id='$nodeid'\>\<title id='$nodeid-title'\>$nodename\<\/title\>";
		$nodelevels{$nodename} = 1;
	} else {
		$buf .= "\<sect2 id='$nodeid'\>\<title id='$nodeid-title'\>$nodename\<\/title\>";
		$nodelevels{$nodename} = 2;
	}
	$insect2 = 1;
	$nodeinit = 1;
	$nodelevels{$nodename} = 2;
	&message("set node $nodename level to $nodelevels{$nodename}") if ($verbose > 0);
}

sub sect3 {
	&closesect3;
	if ($inappendix) {
		$buf .= "\<sect2 id='$nodeid'\>\<title id='$nodeid-title'\>$nodename\<\/title\>";
		$nodelevels{$nodename} = 2;
	} else {
		$buf .= "\<sect3 id='$nodeid'\>\<title id='$nodeid-title'\>$nodename\<\/title\>";
		$nodelevels{$nodename} = 3;
	}
	$insect3 = 1;
	$nodeinit = 1;
	$nodelevels{$nodename} = 3;
	&message("set node $nodename level to $nodelevels{$nodename}") if ($verbose > 0);
}

sub sect4 {
	&closesect4;
	if ($inappendix) {
		$buf .= "\<sect3 id='$nodeid'\>\<title id='$nodeid-title'\>$nodename\<\/title\>";
		$nodelevels{$nodename} = 3;
	} else {
		$buf .= "\<sect4 id='$nodeid'\>\<title id='$nodeid-title'\>$nodename\<\/title\>";
		$nodelevels{$nodename} = 4;
	}
	$insect4 = 1;
	$nodeinit = 1;
	$nodelevels{$nodename} = 4;
	&message("set node $nodename level to $nodelevels{$nodename}");
}

sub table {
	&closetable;
	$buf .= '<informaltable><tgroup col=' . "'2'" . '><tbody>' . "\n";
	$intable = 1;
}

sub tablerow {
	&closetablerow;
	$buf .= '<row>';
	$inrow = 1;
}

sub tablecol {
	&closetablecol;
	$buf .= '<entry>';
	$incol = 1;
}

sub orderedlist {
	&closeformalpara;
	$buf .= '<orderedlist>';
	$inorderedlist = 1;
}

sub itemizedlist {
	&closeformalpara;
	$buf .= '<itemizedlist>';
	$initemizedlist = 1;
}

sub item {
	if ($intable) {
		&tableitem;
	} else {
		&listitem;
	}
}

sub listitem {
	&closelistitem;
	$buf .= '<listitem>';
	$inlistitem = 1;
}

sub formalpara {
	my $title = $_[0];
	my $id = &anchorfix($title);

	&closeformalpara;
	#$buf .= "\<formalpara id='$id'\>\<title\>$title\<\/title\>\n\<para\>";
	$informalpara = 1;
	$inpara = 1;
	$nodeinit = 1;
}

sub para {
	&closeformalpara;
	$buf .= '<para>';
	$inpara = 1;
}

sub literal {
	if ($pattern =~ /\bformat\b/) {
		$literal = 'programlisting';
		$buf .= '<programlisting>' . "\n";
	} elsif ($pattern =~ /\bdisplay\b/) {
		$literal = 'screen';
		$buf .= '<screen>';
	} elsif ($pattern =~ /\bexample\b/) {
		$literal = 'programlisting';
		$buf .= '<programlisting>';
	} elsif ($pattern =~ /\bsmallexample\b/) {
		$literal = 'programlisting';
		$buf .= '<programlisting>';
	}
}

sub closeappendix {
	&closesect1;
	if ($inappendix) {
		$buf .= '</appendix>' . "\n";
		$inappendix = 0;
	}
}

sub closesect1 {
	&closesect2;
	if ($insect1) {
		$buf .= '</sect1>' . "\n\n";
		$insect1 = 0;
	}
}

sub closesect2 {
	&closesect3;
	if ($insect2) {
		if ($inappendix) {
			$buf .= '</sect1>' . "\n\n";
		} else {
			$buf .= '</sect2>' . "\n\n";
		}
		$insect2 = 0;
	}
}

sub closesect3 {
	&closesect4;
	if ($insect3) {
		if ($inappendix) {
			$buf .= '</sect2>' . "\n\n";
		} else {
			$buf .= '</sect3>' . "\n\n";
		}
		$insect3 = 0;
	}
}

sub closesect4 {
	&closeformalpara;
	if ($insect4) {
		if ($inappendix) {
			$buf .= '</sect3>' . "\n\n";
		} else {
			$buf .= '</sect4>' . "\n\n";
		}
		$insect4 = 0;
	}
}

sub closetable {
	&closetablerow;
	if ($intable) {
		$buf .= '</tbody></tgroup></informaltable>' . "\n";
		$intable = 0;
	}
}

sub closetablerow {
	&closetablecol;
	if ($inrow) {
		$buf .= '</row>' . "\n";
		$inrow = 0;
	}
}

sub closetablecol {
	if ($incol) {
		$buf .= '</entry>' . "\n";
		$incol = 0;
	}
}

sub closeorderedlist {
	&closelistitem;
	if ($inorderedlist) {
		$buf .= '</orderedlist>' . "\n";
		$inorderedlist = 0;
	}
}

sub closeitemizedlist {
	&closelistitem;
	if ($initemizedlist) {
		$buf .= '</itemizedlist>' . "\n";
		$initemizedlist = 0;
	}
}

sub closelistitem {
	&closeformalpara;
	if ($inlistitem) {
		$buf .= '</listitem>' . "\n";
		$inlistitem = 0;
	}
}

sub closeformalpara {
	&closepara;
	if ($informalpara) {
#		$buf .= '</formalpara>';
		$informalpara = 0;
	}
}

sub closepara {
	if ($inpara) {
		$buf .= '</para>';
		$inpara = 0;
	}
}

sub closeliteral {
	if ($literal) {
		$buf .= '</' . $literal . '>' . "\n";
		$literal = '';
	}
}


################
# CONDITIONALS #
################

sub set {
	my ($name,
	    $value);

	($foo, $name, $value) = split(/\s+/, $line);
	$value = 1 unless ($value);
	$setvalues{$name} = $value;
	&message("set $name to $value") if ($verbose > 1);
	$value = $setvalues{$name};
	&message("read back $value") if ($verbose > 2);
}

sub clear {
	my $name;

	($foo, $name) = split(/\s+/, $line);
	$setvalues{$name} = 0;
	&message("cleared $name") if ($verbose > 1);
}

sub ifset {
	my $name;

	($foo, $name) = split(/\s+/, $line);
	return $ifsets{$name};
}

#################
# META-LANGUAGE #
#################

sub alias {
	my $alias;
	
	($foo, $alias) = split(/\s/, $line);
	($alias, $command) = split(/=/, $alias);
	&message("alias: $alias, command: $command") if ($verbose > 2);
	$aliases{'@' . $alias} = $command;
}

sub macro {
	$line =~ s/\@macro\s+?(.*?)\{(.*?)\}/\1,\2/;
	($macro, $macroargs) = split(/,/, $line);
	$macro = &trim($macro);
	$macros{$macro} = $macro;
	$macrotext = '';
	$inmacro = 1;
	&message("adding macro $macro") if ($verbose > 2);
}

# load custom @-commands
# 
sub definfoenclose {
	my ($name,
	    $prefix,
	    $suffix,
	    $key,
	    $replacement);
	   
	$line =~ s/\@definfoenclose\s+//;
	($name, $prefix, $suffix) = split(/,/, $line);
	$replacement =  $prefix. ',' . $suffix;
	$definfos{$name} = $replacement;
	&message("custom definfoenclosure: \[$name\] \[$prefix\] \[$suffix\]") if (verbose > 1);
}

###########
# INDEXES #
###########

sub defindex {
	$line =~ s/^\@defindex\s+//;
	$indexes{$line} = 1;
}

####################
# SUPPORT ROUTINES #
####################

sub bracketsmatch {
	my $bline = ' ' . $_[0] . ' ';
	my $left = scalar split(/\{/, $bline) - 1;
	my $right = scalar split(/\}/, $bline) - 1;
	if ($right == $left) {
		$badbracketlines = 0;
		$badbracketstartline = $currentline + 1
	} else {
		$badbracketlines++;
		&message("unmatched \{\} (left: $left, right: $right) on line $line") if ($verbose > 1);
		if ($badbracketlines >= 20) {
			&raiseerror("Mismatched brackets starting on line $badbracketstartline: $line");
		}
	}
	return ($right == $left);	
}

sub trimline {
	$line = &trim($line);
}

sub trim {
	my $temp = $_[0];

	$temp =~ s/^\s+//g;
	$temp =~ s/\s+$//g;
	return $temp;
}

sub raiseerror {
	my $errmsg = "ERROR: $currentfile $currentline $_[0]\n";
	print STDERR $errmsg;
	$errors++;
	if (($maxerrors) and ($errors >= $maxerrors)) {
		print STDERR "aborting after $errors errors.\n";
		&writefile;
		exit(1);
	}
}

sub message {
	my $message;
	$message = $_[0];

	if ($logfile) {
		print $logfh "$message\n";
	} else {
		print "$message\n";
	}
}

sub version {
	print "texi2db version $version\n";
	print "Copyright (c) 2002 David Merrill \<david\@lupercalia.net\>.\n";
	print "\n";
	print "Converts a Texinfo file into DocBook.\n";
	print "\n";
	print "This free software; see the source for copying conditions. There is no\n";
	print "warranty; not even for merchantability or fitness for a particular purpose.\n";
}

sub usage {
	&version;
	print "\n";
	print "usage: texi2db [OPTIONS]... [FILE]\n";
	print "-f, --file FILE        read from file rather than STDIN.\n";
	print "-o, --output-to FILE   write to file rather than STDOUT.\n";
	print "-l, --log-to FILE      write status messages to file rather than STDOUT.\n";
	print "-v, --verbose          show diagnostic output.\n";
	print "                       use twice for lots of detail.\n";
	print "                       use thrice for insane amounts of detail.\n";
	print "-e, --max-errors MAX   show diagnostic output.\n";
	print "                       use '--max-errors 0' to disable.\n";
	print "-h, --help             show this usage message.\n";
	print "    --version          show the program version.\n";
	exit($error);
}

__END__
<?xml version='1.0'?>
<!DOCTYPE book PUBLIC '-//OASIS//DTD DocBook XML V4.1.2//EN'
                      "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">

<article>
  <artheader>
    <title>%%TITLE</title>
    <abstract>
      %%ABSTRACT
    </abstract>
  </artheader>

